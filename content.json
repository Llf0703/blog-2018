{"meta":{"title":"Llf0703's blog","subtitle":null,"description":null,"author":"Llf0703","url":"https://llf0703.com"},"pages":[{"title":"咕咕咕","date":"2018-07-23T09:32:13.868Z","updated":"2018-07-23T09:32:13.868Z","comments":true,"path":"gugugu/index.html","permalink":"https://llf0703.com/gugugu/index.html","excerpt":"","text":"蒟蒻Llf0703鸽了这篇文章 这不是404，只是用作占坑文章的临时页面，请返回上一页。"},{"title":"友链","date":"2018-05-26T02:54:15.250Z","updated":"2018-05-26T02:54:15.250Z","comments":true,"path":"links/index.html","permalink":"https://llf0703.com/links/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-06-13T06:47:28.818Z","updated":"2018-06-13T06:47:28.818Z","comments":true,"path":"tags/index.html","permalink":"https://llf0703.com/tags/index.html","excerpt":"","text":""},{"title":"时间轴","date":"2018-06-13T06:47:05.291Z","updated":"2018-06-13T06:47:05.291Z","comments":true,"path":"timeline/index.html","permalink":"https://llf0703.com/timeline/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-06-13T07:03:13.960Z","updated":"2018-06-13T07:03:13.960Z","comments":true,"path":"about/index.html","permalink":"https://llf0703.com/about/index.html","excerpt":"","text":"我是Llf，最弱的蒟蒻，完了 本博客部分文章的markdown源文件均可通过将 https://llf0703.com/p/*.html改为 https://md.llf0703.com/p/*.md 查看 这个东西会不时更新，也许有的最新文章看不了 BZOJ离线题库（By ruanxingzhi） CSDN博客: Llf_0703 luogu: Llf0703 BZOJ: Llf0703 Bilibili： Llf030703 逼乎: Llf Coding: Llf0703 Gayhub: Llf0703"}],"posts":[{"title":"NOIp2018后总结(置顶)","slug":"after-noip2018","date":"2018-11-10T16:00:00.000Z","updated":"2018-11-20T05:59:58.375Z","comments":true,"path":"p/after-noip2018.html","link":"","permalink":"https://llf0703.com/p/after-noip2018.html","excerpt":"","text":"NOIp2018情况100+40+10+64+15+4=233感觉分数就像个玩笑一样，不过今年NOIp确实给我开了一个玩笑，D1T2人人都会的傻逼题我只有40，D2T2推出了部分规律又把快速幂打爆了（开了bits而且函数名用的小写pow），D2T1也写爆了。 我个人感觉D1T2的爆炸是主要原因，导致D2整个心态都是崩的 （心态崩了我要妹子）。而D1T2我觉得可能有点心态的原因，考前就十分紧张，而且D1T1用20min写完后很久T2一点思路都没有的心理落差确实有点大。 不过归根到底还是实力的原因，如果有500分的实力，就算爆炸100来分拿1=也没问题。 感觉身边的大佬们也都考的不是很好，本来1=稳了的dyl大佬因为一点小失误爆0了，cyc大佬也只有300左右1=也很悬。 总之，考的非常差，不过我在D1的下午就已经做好了这种结局的心理准备。虽然口上说着退役了，但我内心其实还是感觉不服气，不甘心OI生涯就这样结束了。 没想到，又重蹈了NOIp2017的覆辙了呢。我不知道下面那句话所说的我还能坚持多久，但只要还有希望，我就会把这条路坚持走下去： 自己选择的路，跪着也要走完。 NOIp2018总结 D1T1 20min线段树分治写完，没什么说的。 D1T2 想了很久没想出正解，还好头脑清醒打了40分暴力。 D1T3 心态已经崩了，打了20分的暴力只得到10分。 D2T1 先打了60分，并不会基环树，也没有想到 $O(n\\times m)$ 算法然后用并查集缩点搞了下后40分，不过搞爆了。 D2T2 推dp推了很久，最后手算20分+部分规律走人，不过2和3的情况算错了只有15分。然后快速幂写爆了也就没有后面的分。 D2T3 心态彻底崩塌，暴力完全写爆，只有4分。 对前一年OI生涯的大致回忆在今年3月之前，我的OI几乎都处于入门水平，码力极差，连最短路都写不来，线性筛之类也没学过，数据结构更是闻所未闻。做的题也就只有洛谷上70题不到，最开始用的codevs也只有80题左右，而且都是水题。去机房要么打游戏，要么颓知乎。直到寒假最后一天才立誓认真学OI。 3月到5月因为不用中考，我自闭了三个月，洛谷上直接刷到了200多题，所谓的难题也多了很多。不过这么多题很多都是数据结构和一些毒瘤玩意，我自以为突飞猛进，实际上学了些几乎没什么卵用的东西，而基础还是特别差。甚至像学的很多毒瘤东西比如FFT、莫队、点分治、Splay之类的其实也没有真正掌握，现在也忘的差不多了。不过码力还是提升了很多，其实那些毒瘤东西和数据结构也并非完全无用，而且基础的算法和数据结构也提升很大。 6月就开始颓废了，几乎什么都没干，题也没做多少道。不过暑假期间去qbxt培训的还是有些效果的，而且8月做了很多水题，巩固了很多基础。但还是很菜。 9月开学了，每天拼死拼活写作业只为了在晚自习后半段去机房。晚上也还是很认真的在刷试炼场，提升也挺大的。特别是搜索这种暴力能力提升了很多。 10月考初赛考了84，估计是初赛考太好了把我复赛RP都用完了。然后就停课了，只上数学。停课了主要是做膜你题，提升也挺大的。不过后来颓的也挺多的，浪费了很多时间。考前两天不知道怎么的肠胃出了问题，拉肚子，吃不下东西，星期四晚上就被接回家了。D1早上和中午我也什么东西都没吃，不知道会不会有点影响。 然后NOIp之后担惊受怕的颓废了一周，从不去机房，晚自习写完作业了就看一个多小时的小说，后来程序下了，测了，爆了，哭了。虽然很早就料到多半是这种结局，但是真正来临的时候还是感觉很难接受。星期五（好吧是星期四晚上11点）dyl大佬给我发微信给我说了他的噩耗，感觉好了些（对dyl大佬感到很抱歉但是这是实话），毕竟还有人与我同在。 总结 并没有特备认真，颓了很多。 被数据结构带来的巨大成就感冲昏了头脑，走了很多弯路。 并没有弄清楚每一道题，像今年的D1T1我还在一年前做过但还是没有想起来，很多题也是是是而非就过了。 感觉学习没有体系，想到哪学哪。 明年的规划 从下周开始回到正轨，多做题，少颓废，弄清楚每一道题。 适时适当提升难度，不要畏惧难题。 每一道有价值的题都应该写题解，帮助自己理解和日后复习，而hexo显然不容易满足我这个想法，所以我计划买一台云主机，继续用typecho或者wordpress这些可以在线编辑博客的框架写博客。初步想法是懒得迁移了，重新开始写，把现在这个留下来，用其他子域名来访问。 目标 NOIp2019 500+！ SCOI2020 其他随感最终成绩下来了，如果说我之前还带着一些侥幸心理，那么今天就是真正的最终的审判了。 虽然早已接受这个事实，但今天中午还是十分郁闷，然后花了一中午写了这么多废话。 2019，rp++！ 以上。","categories":[{"name":"随感","slug":"随感","permalink":"https://llf0703.com/categories/随感/"}],"tags":[]},{"title":"NOIp2018游记","slug":"noip2018-summary","date":"2018-11-10T16:00:00.000Z","updated":"2018-11-20T04:58:56.757Z","comments":true,"path":"p/noip2018-summary.html","link":"","permalink":"https://llf0703.com/p/noip2018-summary.html","excerpt":"","text":"Day1一大早起来就很不爽，加上前几天肠胃又出了点问题，早饭几乎没吃什么东西就跑去考试了。 去的太早了，我校那些住酒店的都没到，遇上了dyl大佬并且吸收了些rp，然后又遇到了cyc大佬并膜了一会。过了很久才遇到我校大佬们，结果是他们从另一边过来了，我在那干等了10分钟。然后背了背字符串的板子（kmp、Manacher）就上504去考试了。 T1一眼线段树+分治，不过最初的想法是还要修改，打着打着才想起直接记录下现在修了多少就行了，20min敲完过大样例走人，时间复杂度应该是 $O(logn \\times logn)$ 。然后死磕T2也没搞出来，还以为是数论，心态崩了，还好脑子比较清醒就打了40分暴力走人。T3搞各种特殊情况搞了大概20就滚粗了。 估分100+40+20.下来一对怎么大佬们都A了第二题，剩下的再不济也有80，而且都会T1的 $O(n)$ 做法，就感觉自己凉了。真不知道为什么考场上就是没想到T2的甚至是65分的做法。 然后我去知乎回答了如何评价NOIP2018？，发现看来不止我一个人，心态好了一点。但下午看洛谷群发现人均280又感到凉了，感到十分悲桑，午饭也没吃。直到晚上心情终于好了些吃了点东西，然后就颓废到睡觉。 Day2凌晨还醒了很久才睡着，所以感觉也不太好。拖到7点半才出发，8点到了就直接进去了。（dyl大佬还在7点43微信问我到了没） T1就感觉不太会啊，先把60分搞定了，然后用并查集缩点搞了下环，大概70分钟才过大样例。但我总觉得我出环的时候处理有些锅，不过有12分是 每个城市最多与两个城市相连 而且边又有n条，所以肯定整张图都是环，所以就不涉及出环。那么就估个72吧。听说正解是基环树，不会，不后悔。 T2搞dp搞了半天没搞出来，手推把3和2的情况推错了，当有一个1的时候我写快速幂又直接用的小写的pow，关键是我还带了bits!刚发现的时候心态又崩了，不过没CE就已经是万幸了，转念一想没准不会给1的点呢。反正就差不多15了，基本确定了。 T3搞了下A3的6个点，用的 $O(n \\times m)$ 的dp，24分；然后又搞了下A2，那就意味着要么-1要么不变，12分；最后搞了下3、4点的8分。但后面的不太确定，就估个24吧。 总结总的估分：100+40+20+72+15+24=271。因为估的比较保守，不出意外的话应该会高一点，我个人感觉很失望，特别是D1T2的60分没拿到着实可惜。希望能拿个1=吧。感觉好多大佬都300以上1=稳了。 更多的总结之后再写，照片也有时间再发。滚回去搞文化课了，12月月考和期末怕是要垫底。","categories":[{"name":"游记","slug":"游记","permalink":"https://llf0703.com/categories/游记/"}],"tags":[{"name":"游记-NOIp","slug":"游记-NOIp","permalink":"https://llf0703.com/tags/游记-NOIp/"}]},{"title":"NOIp_2018.rp++!","slug":"noip2018-rp++","date":"2018-11-08T16:00:00.000Z","updated":"2018-11-11T12:02:49.046Z","comments":true,"path":"p/noip2018-rp++.html","link":"","permalink":"https://llf0703.com/p/noip2018-rp++.html","excerpt":"","text":"while (NOIp_2018.rp&lt;inf) NOIp_2018.rp++; 放些板子，早上熟悉一下。主要是数论和图论，数据结构还是比较熟练的。 int gcd(int x,int y) { if (y==0) return x; return gcd(y,x%y); } void exgcd(int a,int b,int &amp;x,int &amp;y) //ax+by=gcd(a,b) { if (b==0) x=1,y=0; else { exgcd(b,a%b,y,x); y-=a/b*x; } } inline void dijkstra() { priority_queue &lt;pr,vector&lt;pr&gt;,greater&lt;pr&gt; &gt; q; memset(vis,0,sizeof(vis)); for (int i=1;i&lt;=n;i++) dis[i]=1e9; dis[s]=0; q.push(mp(0,s)); while (!q.empty()) { int x=q.top().second; q.pop(); if (vis[x]) continue; vis[x]=1; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to,w=edge[i].w; if (mn[x]+x&lt;mn[y]) { mn[y]=mn[x]+w; q.push(mp(mn[y],y)); } } } } inline void spfa() { queue &lt;int&gt; q; for (int i=1;i&lt;=n;i++) dis[i]=1e9; memset(in,0,sizeof(in)); dis[s]=0; q.push(s); while (!q.empty()) { int x=q.front(); q.pop(); in[x]=0; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to,w=edge[i].w; if (dis[x]+w&lt;dis[y]) { dis[y]=dis[x]+w; if (!in[y]) { q.push(y); in[y]=1; } } } } } bool spfa(int x) //判负环 { in[x]=1; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to,w=edge[i].w; if (dis[x]+w&lt;dis[y]) { dis[y]=dis[x]+w; if (!in[y]) return spfa(y); else return 1; //有负环 } } in[x]=0; return 0; } inline void getnext()////p[k]表示前缀，p[j]表示后缀 { Next[0]=-1; int ly=y.length(),k=-1,j=0; while (j&lt;ly) { if (k==-1 || y[j]==y[k]) { j++; k++; Next[j]=k; } else k=Next[k]; } } inline void kmp() { int i=0,j=0,lx=x.length(),ly=y.length(); while (i&lt;lx) { if (j==-1 || x[i]==y[j]) i++,j++; else j=Next[j]; if (j==ly) { cout&lt;&lt;i-j+1&lt;&lt;endl; j=Next[j]; } } } inline int manacher() { int mx,id,mxlen=0; for (int i=0;i&lt;l;i++) { if (i&lt;mx) p[i]=min(p[2*id-i],mx-i); else p[i]=1; while (y[i-p[i]]==y[i+p[i]]) p[i]++; if (mx&lt;i+p[i]) { id=i; mx=i+p[i]; } mxlen=max(mxlen,p[i]-1); } return mxlen; } inline void get_prime() { memset(ss,1,sizeof(ss)); ss[0]=ss[1]=0; for (int i=2;i&lt;=n;i++) { if (ss[i]) zs[++cnt]=i; for (int j=1;j&lt;=cnt &amp;&amp; zs[j]*i&lt;=n;j++) { ss[zs[j]*i]=0; if (i%zs[j]==0) break; } } } inline ll POW(ll x,ll y) { ll m=1,n=x; while (y) { if (y&amp;1) m=m*n%k; y&gt;&gt;=1; n=n*n%k; } return m%k; }","categories":[],"tags":[]},{"title":"2018.10.30NOIP膜你赛(©qbxt)题解","slug":"contest-summary-3","date":"2018-10-29T16:00:00.000Z","updated":"2018-10-30T02:47:36.309Z","comments":true,"path":"p/contest-summary-3.html","link":"","permalink":"https://llf0703.com/p/contest-summary-3.html","excerpt":"","text":"其实我10.9就做了这套题，当时瞎jb搞都有230，可见这套题有多水。不过我今天才把这套题搞完，就来写个总结。 小G搭积木(box)当时我写的二分答案，下界是1，上界是n，然后贪心看能不能放得下即可。不过只有60分，具体原因尚不明确。 int n,m,x[5005],lef[5005]; inline bool cmp(int a,int b) { return a&gt;b; } inline bool can(int num) { for (int i=1;i&lt;=n;i++) lef[i]=x[i]; for (int i=num+1;i&lt;=n;i++) { int mx=0,mxleft=0; for (int j=num;j;j--) { if (lef[j]&gt;mxleft) { mx=j; mxleft=lef[j]; } } if (mxleft&lt;1) return 0; else lef[mx]=min(lef[mx]-1,x[i]); } return 1; } int main() { n=read(); for (int i=1;i&lt;=n;i++) x[i]=read(); sort(x+1,x+n+1,cmp); int l=0,r=n,mid; while (l&lt;r) { mid=(l+r)/2; if (can(mid)) r=mid-1; else l=mid+1; } printf(&quot;%d&quot;,l); return 0; } 看了题解才知道这题就是一个裸的贪心。 很容易想到，承重量大的肯定要放在下面才会最优。所以我们把积木按照承重量从小到大排序，然后枚举每一列看能否把当前积木放在它的下面。如果有多列都可以放，那么肯定放积木个数最多的那列最优；如果都放不下，就新开一列。 int f[5005],n,m,s[5005]; int main() { n=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); sort(s+1,s+n+1); m=1; f[1]=1; for (int i=2;i&lt;=n;i++) { bool putin=0; int mx=0,mxid=0; for (int j=1;j&lt;=m;j++) { if (f[j]&gt;s[i]) continue; putin=1; if (f[j]&gt;mx) { mx=f[j]; mxid=j; } } if (!putin) f[++m]=1; else f[mxid]++; } printf(&quot;%d&quot;,m); return 0; } 小G的城堡(castle)真·大水题 把题意翻译成人话就是前k个点必须能到达1号点，后面的点都不能到达1号点。 我们先考虑后面的点。因为前k个点都能与1号点相连，所以后面的点不能与前k个点相连，那么它们只能互相连，方案数就是 $ \\left( n-k\\right) ^{n-k} $。 然后考虑前k个点。我当时不知道用什么公式，但是发现k很小 $ (k&lt;=\\min (8,n)) $ ，所以就暴搜枚举每个点连哪个点即可： get_ans1()枚举连哪个点，dfs()验证每个点是否与1相连 bool dfs(int x) { if (x==1) return 1; vis[x]=1; int y=to[x]; if (can[y]) return 1; if (vis[y]) return 0; return can[x]=dfs(y); } void get_ans1(int x) { if (x==k+1) { memset(can,0,sizeof(can)); can[1]=1; for (int i=2;i&lt;=k;i++) { if (can[i]) continue; memset(vis,0,sizeof(vis)); if (!dfs(i)) return; } ans2++; return; } for (int i=1;i&lt;=k;i++) { if (x==i &amp;&amp; x!=1) continue; to[x]=i; get_ans1(x+1); to[x]=0; } return; } 然后得到一个表： int ans2_table[10]={0,1,2,9,64,625,7776,117649,2097152}; 不过好像有个结论是方案数为 $ k ^{k-1} $ 最后把两种方案数乘起来就是答案了。 #define ll long long #define ha 1000000007 ll n,k,cnt=1,ans2,to[10],ans2_table[10]={0,1,2,9,64,625,7776,117649,2097152}; bool vis[10],can[10]; inline ll get_ans() { ll x=n-k,y=n-k; ll z=1; while (y!=0) { if (y%2) z=(z*x)%ha; y/=2; x=((x%ha)*(x%ha))%ha; } return z; } int main() { n=read(); k=read(); ll ans=get_ans(); ans=(ans*ans2_table[k])%ha; printf(&quot;%lld&quot;,ans); return 0; } 跳跃(jump)我当时一拿到题就直接无脑记忆化搜索。$ f[pos][last] $ 表示当前位置是pos，上一次跳了last距离。 int dfs(int pos,int last) { if (pos&gt;mx) return 0; if (f[pos][last]!=-1) return f[pos][last]; f[pos][last]=have_gold[pos]; int maxx=max(dfs(pos+last,last),dfs(pos+last+1,last+1)); if (last&gt;1) maxx=max(maxx,dfs(pos+last-1,last-1)); f[pos][last]+=maxx; return f[pos][last]; } 然后70分就get了。当时还很开心，殊不知改下数组大小就能A了 看了题解才发现即使最开始 $ d=1 $ ，最多到跳350的距离其实就已经超过30000了 $ (\\dfrac {350\\times \\left( 350+1\\right) }{2} = 61425 &gt; 30000) $ ，所以把数组 $ f[1005][1005] $ 改成 $ f[30005][705] $ 就A了。 int gd,n,m,d,f[30005][1405],mx,have_gold[30005]; int dfs(int pos,int last) { if (pos&gt;mx) return 0; if (f[pos][last]!=-1) return f[pos][last]; f[pos][last]=have_gold[pos]; int maxx=max(dfs(pos+last,last),dfs(pos+last+1,last+1)); if (last&gt;1) maxx=max(maxx,dfs(pos+last-1,last-1)); f[pos][last]+=maxx; return f[pos][last]; } int main() { n=read(); d=read(); memset(f,-1,sizeof(f)); for (int i=1;i&lt;=n;i++) gd=read(),have_gold[gd]++,mx=max(mx,gd); printf(&quot;%d&quot;,dfs(d,d)); return 0; } upd:经lsq大佬提醒，如果d很大的话last也会很大，所以其实只维护偏移值才是正解，不过数据很水我那样也就过了。 这里放一个我后来参照std写的代码，其实原程序改一下应该就行了，但我懒的改。 int gd,n,m,d,f[30005][705],mx,have_gold[30005]; int main() { n=read(); d=read(); for (int i=1;i&lt;=n;i++) { gd=read(); have_gold[gd]++; mx=max(mx,gd); } for (int i=mx;i&gt;=d;i--) { for (int j=0;j&lt;=700;j++) { int k=j-350; if (d+k&lt;=0) continue; f[i][j]=have_gold[i]; int nxt=i+d+k; if (nxt&lt;=mx) f[i][j]+=max(f[nxt][j],max(f[nxt][j-1],f[nxt][j+1])); } } printf(&quot;%d&quot;,max(f[d][350],max(f[d][349],f[d][351]))); return 0; } 总结总的来说这套题打的还不错，有60+100+70=230分，不过第三题那30分确实很可惜。还是应该多分析一下题，不要无脑写完就跑，自己认为的暴力没准就是正解。 以上。","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[]},{"title":"ZJ第九套总结","slug":"contest-summary-zj9","date":"2018-10-28T16:00:00.000Z","updated":"2018-10-29T10:18:27.023Z","comments":true,"path":"p/contest-summary-zj9.html","link":"","permalink":"https://llf0703.com/p/contest-summary-zj9.html","excerpt":"","text":"购物(shopping)洛谷题目：P1658 购物 贪心水题。如果我们已经可以凑出 $ [1,n] $ 之间所有面值，那么携带 $ \\forall x\\in [1,n+1] $ 面值的硬币，我们一定可以凑出 $ [1,n+x] $ 之间所有面值。 要让硬币个数尽可能少，就让携带的每个硬币面值尽可能大，所以我们就在面值 $ \\in [1,n+1] $ 的硬币中取最大的即可。 很容易想到，如果最小面值都 $ &gt;1 $ 就肯定无解，输出 $ -1 $. int s[15],n,m,x; int main() { x=read(); n=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); sort(s+1,s+n+1); if (s[1]&gt;1) { printf(&quot;-1&quot;); return 0; } int can=1,ans=1; while (can&lt;x) { int i=n; while (s[i]&gt;can+1 &amp;&amp; i&gt;=2) i--; can+=s[i]; ans++; } printf(&quot;%d&quot;,ans); return 0; } 养猪(pig)Vijos题目：养猪 还有个洛谷的双倍经验：P1987 摇钱树，只是多组数据 贪心+dp。贪心策略是按P从大到小排序，然后01背包决定杀不杀即可。贪心证明如下： 假设最初的顺序是 A[1],A[2],...,A[x],A[x+1],...,A[n] 及 P[1],P[2],...,P[x],P[x+1],...,P[n] 对于第 $ x $ 和第 $x+1$ 头猪，杀了它们获得的利益和 $ W1 $ 是 A[x]-P[x]\\times (x-1)+A[x+1]-P[x+1]\\times x如果我们交换第 $ x $ 和第 $ x+1 $ 头猪，利益和 $ W2 $ 就变成了 A[x]-P[x]\\times x+A[x+1]-P[x+1]\\times (x-1)肯定是有更多利益我们才会交换，所以需要满足 W2-W1=P[x+1]-P[x]>0,即 P[x+1]>P[x]交换后就是 $ P[x]&gt;P[x+1] $ 了，所以按照p从大到小排序。 剩下的就是标准01背包，由于数据不大，用不用滚动数组都可以。方程式是： f[i][j]=\\max \\begin{equation}\\begin{cases} f[i-1][j] \\\\ f[i-1][j-1]+\\max(0,A[i]-P[i]*(j-1)) \\end{cases}\\end{equation}int n,k,f[1005][1005],ans; struct pig{ int a,p; } s[1005]; inline bool cmp(pig x,pig y) { return x.p&gt;y.p; } int main() { n=read(); k=read(); if (k&gt;n) k=n; for (int i=1;i&lt;=n;i++) s[i].a=read(); for (int i=1;i&lt;=n;i++) s[i].p=read(); sort(s+1,s+n+1,cmp); for (int i=1;i&lt;=n;i++) for (int j=k;j;j--) f[i][j]=max(f[i-1][j-1]+max(0,s[i].a-s[i].p*(j-1)),f[i-1][j]); for (int i=1;i&lt;=k;i++) ans=max(ans,f[n][i]); printf(&quot;%d&quot;,ans); return 0; } 数位平方和(count)洛谷题目：P1660 数位平方和 按题意记忆化DFS即可，需要记忆的就是h的值。 需要注意一定会出现环，当某一个值被搜索到第二次的时候返回即可。 ll k,a,b; ll hh[4000005],vis[4000005]; inline ll _min(ll x,ll y) { if (x&lt;=y) return x; return y; } inline ll s(ll x) { ll ans=0; while (x) { ll now=x%10,sum=1; for (ll i=1;i&lt;=k;i++) sum*=now; ans+=sum; x/=10; } return ans; } inline ll h(ll x) { if (hh[x]!=-1) return hh[x]; if (vis[x]==2) return x; ll sx=s(x); vis[x]++; ll ans=_min(x,_min(sx,h(sx))); vis[x]--; return hh[x]=ans; } int main() { k=read(); a=read(); b=read(); ll ans=0; for (int i=1;i&lt;=4000000;i++) hh[i]=-1; for (int i=a;i&lt;=b;i++) ans=(ans+h(i))%ha; printf(&quot;%lld&quot;,ans); return 0; } 扩散(ppg)洛谷题目：P1661 扩散 看起来四周扩散很复杂，但扩散的次数实质上就是两个点的曼哈顿距离 $ \\div 2 $ (向上取整)。所以只需要将没两个点之间连一条权值为 $ (|x1-x2|+|y1-y2|+1)\\div 2 $ 的边跑最小生成树即可，答案就是最小生成树中的最长边。 struct point{ int x,y; } pt[55]; struct Edge{ int st,ed,w; } edge[2505]; int n,m,a,b,c,fa[55],cnt,ans; inline void add(int u,int v,int w) { edge[++cnt].st=u; edge[cnt].ed=v; edge[cnt].w=w; } inline void init() { for (int i=1;i&lt;=n;i++) fa[i]=i; } int getfa(int x) { if (x==fa[x]) return fa[x]; fa[x]=getfa(fa[x]); return fa[x]; } inline bool merge(int x,int y) { int gfx=getfa(x),gfy=getfa(y); if (gfx==gfy) return 0; fa[gfx]=gfy; return 1; } inline bool cmp(Edge x,Edge y) { return x.w&lt;y.w; } inline void kruskal() { for (int i=1;i&lt;=cnt &amp;&amp; n;i++) { int x=edge[i].st,y=edge[i].ed; if (merge(x,y)) { n--; ans=max(ans,edge[i].w); } } } int main() { n=read(); init(); for (int i=1;i&lt;=n;i++) pt[i].x=read(),pt[i].y=read(); for (int i=1;i&lt;=n;i++) for (int j=i+1;j&lt;=n;j++) add(i,j,(abs(pt[i].x-pt[j].x)+abs(pt[i].y-pt[j].y)+1)&gt;&gt;1); sort(edge+1,edge+cnt+1,cmp); kruskal(); printf(&quot;%d&quot;,ans); return 0; } 总结今天考的非常爆炸，第一题把样例看错了，发现怎么就是多了1，想都没想就把答案-1了(-100s)；第二题按p排了序，方程式也是对的，就是最后没有取最大值(-100s)；第三题知道有环，也写了记搜，但是每个点搜到第一次就返回了，只A了一个点(-90s)；第四题真的没想出来，打了20分暴力(-80s)。然后就把一手320的好牌打成30分。。。 所以我觉得我还应注意以下两点： 不管题再简单也要把样例推几遍，更不能一晃而过 需要非常熟练掌握基础的dp模型 以上。","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[]},{"title":"让firefox拥有chrome外观-MaterialFox","slug":"materialfox","date":"2018-10-24T16:00:00.000Z","updated":"2018-10-25T13:04:18.527Z","comments":true,"path":"p/materialfox.html","link":"","permalink":"https://llf0703.com/p/materialfox.html","excerpt":"","text":"昨天Firefox发布了63.0正式版以及64.0beta版。我在看文章Firefox 63.0 正式版用户特性介绍时偶然发现一张图片中的Firefox看起来很像chrome。 然后在询问作者之后我发现了这个神奇的东西。我个人又挺喜欢圆角的Material Design，于是就配置了一下，效果还不错。 项目地址muckSponge/MaterialFox 使用方法 将项目clone到任意一个文件夹 git clone https://github.com/muckSponge/MaterialFox.git 进入about:support在“配置文件夹”中找到“打开文件”这个按钮，打开文件夹，并将刚刚clone内容中的Material文件夹复制到里面 进入about:config，搜索 svg.context-properties.content.enabled 双击将值改成 true。 重启Firefox即可 更多设置Firefox是不支持在设置里改变顶栏背景色、字体颜色之类的。这里我们就需要一个官方拓展：Firefox Color。在网站指引下安装拓展进行颜色修改即可。 效果","categories":[{"name":"安利","slug":"安利","permalink":"https://llf0703.com/categories/安利/"}],"tags":[{"name":"浏览器-Firefox","slug":"浏览器-Firefox","permalink":"https://llf0703.com/tags/浏览器-Firefox/"}]},{"title":"ZJ第七套总结","slug":"contest-summary-zj7","date":"2018-10-24T16:00:00.000Z","updated":"2018-10-25T12:11:47.720Z","comments":true,"path":"p/contest-summary-zj7.html","link":"","permalink":"https://llf0703.com/p/contest-summary-zj7.html","excerpt":"","text":"我决定，为了去除冗余的文章长度，所有代码删掉头文件和快读。 塔(tower)洛谷题目：P1651 塔 我几乎毫不犹豫就先花5分钟打了一发暴搜，检查没有发现任何问题，最后交上去就有80分： int h[55],n,m,a,b,c,ans; bool vis[55]; bool check(int cnt,int hmax,int sum,int last) { if (sum==hmax &amp;&amp; cnt==2) return 1; if (sum==hmax &amp;&amp; cnt==1) return check(2,hmax,0,0); if (sum&gt;hmax) return 0; for (int i=last+1;i&lt;=n;i++) { if (vis[i]) continue; vis[i]=1; if (check(cnt,hmax,sum+h[i],i)) return 1; vis[i]=0; } return 0; } inline bool cmp(int x,int y) { return x&gt;y; } int main() { n=read(); int sum=0; for (int i=1;i&lt;=n;i++) h[i]=read(),sum+=h[i]; sort(h+1,h+n+1,cmp); ans=-1; for (int i=sum&gt;&gt;1;i;i--) { if (check(1,i,0,0)) { ans=i; break; } } printf(&quot;%d&quot;,ans); return 0; } 可以说是十分划算了，要什么正解系列。 正解就是一个dp，用 $ f[i][j] $ 表示放到了第i个，两个塔的差值是j时高塔的最大高度。决策有三种： 不要 放到高塔，差值变大 放到低塔，差值变小（或者反超） 对应方程就是： f\\left[ i\\right] \\left[ j\\right] =\\max \\begin{equation}\\begin{cases} f[i-1][j] \\\\ f[i-1][j+s[i]] \\\\ f[i-1][j-s[i]]+s[i] (j>s[i]) \\\\ f[i-1][s[i]-j]+j (j","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[]},{"title":"ZJ第六套总结","slug":"contest-summary-zj6","date":"2018-10-23T16:00:00.000Z","updated":"2018-10-25T11:36:29.353Z","comments":true,"path":"p/contest-summary-zj6.html","link":"","permalink":"https://llf0703.com/p/contest-summary-zj6.html","excerpt":"","text":"其实徐妈口中的所谓的ZJ十套就是《全国青少年信息学竞赛培训教材复赛》中的十套膜你题。今天先应徐妈之要求把今天的总结了，以后再补之前的。 分组(group)洛谷题目：P1109 学生分组 大水题，直接放代码。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int n,l,r,a,sum,ans1,ans2,ans,s[55]; int main() { freopen(&quot;group.in&quot;,&quot;r&quot;,stdin); freopen(&quot;group.out&quot;,&quot;w&quot;,stdout); n=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); l=read(); r=read(); for (int i=1;i&lt;=n;i++) { sum+=s[i]; if (s[i]&gt;=l &amp;&amp; s[i]&lt;=r) continue; if (s[i]&gt;r) ans1+=s[i]-r; if (s[i]&lt;l) ans2+=l-s[i]; } ans=max(ans1,ans2); if (sum&gt;n*r || sum&lt;n*l) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans); fclose(stdin); fclose(stdout); return 0; } 阶乘(num)洛谷上并没有这道题。 找下规律，发现末尾都是偶数，而且如果没有5的话直接按照个位来乘就行了。但是遇到5、15之类的就非常恶心了，所以对于这些肯定要分类讨论。 可以知道，最后的0的来源肯定是2和5，显然，5的个数小于2的个数，所以我们考虑5。 首先假设没有5存在。即便这样 $ O(n) $ 的时间复杂度还是不现实的。由于只和最后一位有关，所以我们可以将其10个分为一组运算，这样最多算2009次就行了。 最后总的阶乘和 $ \\div 10^{x} $ 就是答案，我们不考虑5的话只需要最后 $ \\div 2^{x} $ 就行了（x是5的个数也是0的个数）。所以最后有多少个5我们 $ \\div 2 $ 多少个2就行了。可以发现 $ \\div 2 $ 后的对应关系 2—&gt;6 4—&gt;2 6—&gt;8 8—&gt;4 所以不断除5，并且把答案不断除2也就是变成对应关系就行了，其他的就按10分组直接算。显然要用高精。 然后我在考场上很开心的写完了TLE代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct bigint{ int s[5005],len; bigint(){memset(s,0,sizeof(s));len=0;} } n; int t,a,b,c,ans; inline bigint division(bigint x,int y) { bigint z; int sum=0,len=x.len; for (int i=len;i;i--) { sum=sum*10+x.s[i]; z.s[i]=sum/y; sum%=y; } while (!z.s[len]) len--; z.len=len; return z; } inline void clear(bigint &amp;x) { for (int i=1;i&lt;=x.len;i++) x.s[i]=0; x.len=0; } int main() { freopen(&quot;num.in&quot;,&quot;r&quot;,stdin); freopen(&quot;num.out&quot;,&quot;w&quot;,stdout); t=read(); while (t--) { clear(n); ans=1; char ch[2018]; scanf(&quot;%s&quot;,ch); for (int i=strlen(ch)-1;i&gt;=0;i--) n.s[++n.len]=ch[i]-&#39;0&#39;; if (n.len==1 &amp;&amp; n.s[1]==1) { printf(&quot;1\\n&quot;); continue; } while (n.len&gt;=1) { for (int i=1;i&lt;=n.s[1];i++) { if (i==5) continue; ans=(ans*i)%10; } n=division(n,5); int sum=n.s[1]+n.s[2]*10; if (sum%4==0) ans=(ans*6)%10; else if (sum%4==1) ans=(ans*8)%10; else if (sum%4==2) ans=(ans*4)%10; else if (sum%4==3) ans=(ans*2)%10; } printf(&quot;%d\\n&quot;,ans); } fclose(stdin); fclose(stdout); return 0; } 然后很开心的得了50. 考后看书才发现那个每一位上都循环乘一遍太浪费时间了，树上直接预处理了一个数组： int val[10]={1,1,2,6,4,4,4,8,4,6}; 时间复杂度变成了原来的 $ \\dfrac {1}{10} $ ，但还是50分。我想是不是高精度初始化和clear太浪费了，就把它删了，毕竟都是重新赋值。然后就有70分了。最后把函数直接写在了main函数里就A了。这TM卡常是有多严重啊 附上AC代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct bigint{ int s[3005],len; } n; int t,a,b,c,ans,val[10]={1,1,2,6,4,4,4,8,4,6}; int main() { freopen(&quot;num.in&quot;,&quot;r&quot;,stdin); freopen(&quot;num.out&quot;,&quot;w&quot;,stdout); t=read(); while (t--) { n.len=0; ans=1; char ch[2018]; scanf(&quot;%s&quot;,ch); for (int i=strlen(ch)-1;i&gt;=0;i--) n.s[++n.len]=ch[i]-&#39;0&#39;; if (n.len==1 &amp;&amp; n.s[1]==1) { printf(&quot;1\\n&quot;); continue; } while (n.len&gt;=1) { ans=(ans*val[n.s[1]])%10; int sum=0,len=n.len; for (int i=len;i;i--) { sum=sum*10+n.s[i]; n.s[i]=sum/5; sum%=5; } while (!n.s[len]) len--; n.len=len; sum=n.s[1]+n.s[2]*10; if (sum%4==0) ans=(ans*6)%10; else if (sum%4==1) ans=(ans*8)%10; else if (sum%4==2) ans=(ans*4)%10; else if (sum%4==3) ans=(ans*2)%10; } printf(&quot;%d\\n&quot;,ans); } fclose(stdin); fclose(stdout); return 0; } 拐弯(ddos)洛谷题目：P1649 [USACO07OCT]障碍路线Obstacle Course 真·玄学题目 我在11:23的时候花5分钟写了个DFS，然后忘了回溯爆0了。。。加了一句话多了60分。代码长这样： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int n,mp[105][105],st[2],ed[2],fx[4]={1,0,-1,0},fy[4]={0,1,0,-1},ans; bool vis[105][105]; void dfs(int x,int y,int last,int now) { if (x==ed[0] &amp;&amp; y==ed[1]) { vis[x][y]=1; ans=min(ans,now); return; } if (vis[x][y]) return; vis[x][y]=1; for (int i=0;i&lt;4;i++) { int tx=x+fx[i],ty=y+fy[i]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;n || mp[tx][ty]==0) continue; int sum; if (i==last || last==-1) sum=0; else sum=1; dfs(tx,ty,i,now+sum); } vis[x][y]=0; } int main() { n=read(); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { char ch; cin&gt;&gt;ch; if (ch==&#39;.&#39;) mp[i][j]=1; else if (ch==&#39;x&#39;) mp[i][j]=0; else if (ch==&#39;A&#39;) st[0]=i,st[1]=j,mp[i][j]=1; else ed[0]=i,ed[1]=j,mp[i][j]=1; } } ans=1e9; dfs(st[0],st[1],-1,0); if (!vis[ed[0]][ed[1]]) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans); return 0; } 这真的是我5分钟打出来的！除了头文件和快读是粘贴的。看来我搜索没有那么蒻了。 然后改成BFS就能过。。。只需要注意为了保证拐弯次数递增，每次需要把当前方向走到底再换方向走 AC代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; #define pr pair&lt;int,int&gt; #define mpr make_pair using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int n,mp[105][105],st[2],ed[2],fx[4]={1,0,-1,0},fy[4]={0,1,0,-1},ans[105][105]; inline void bfs() { queue &lt;pr&gt; q; q.push(mpr(st[0],st[1])); ans[st[0]][st[1]]=0; while (!q.empty()) { int x=q.front().first,y=q.front().second; q.pop(); if (x==ed[0] &amp;&amp; y==ed[1]) break; for (int i=0;i&lt;4;i++) { int tx=x,ty=y; for (;;) { tx+=fx[i]; ty+=fy[i]; if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;n || !mp[tx][ty]) break; if (ans[x][y]+1&lt;ans[tx][ty]) { ans[tx][ty]=ans[x][y]+1; q.push(mpr(tx,ty)); } } } } if (ans[ed[0]][ed[1]]==1e9) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans[ed[0]][ed[1]]-1); return; } int main() { n=read(); for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=n;j++) { ans[i][j]=1e9; char ch; cin&gt;&gt;ch; if (ch==&#39;.&#39;) mp[i][j]=1; else if (ch==&#39;x&#39;) mp[i][j]=0; else if (ch==&#39;A&#39;) st[0]=i,st[1]=j,mp[i][j]=1; else ed[0]=i,ed[1]=j,mp[i][j]=1; } } bfs(); return 0; } 赛马(horse)洛谷题目：P1650 田忌赛马 贪心。 以下内容转载自：https://www.luogu.org/blog/user55918/solution-p1650 开始也是先排序，可以使用sort快排 然后将田忌最大的马与国王进行比较 如果田忌最大的马大于国王，那么就胜场++ 如果田忌最大的马小于国王，那么就一定会输，所以用田忌最小的马输给国王最大的马 如果田忌最大的马等于国王，那么就比较最小的马 如果田忌最小的马大于国王，那么胜场++ 如果田忌最小的马小于国王，那么就输给国王 如果田忌最小的马等于国王，就用田忌最小的马对国王最大的马，如果国王最大的马大，那么财产要减200 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int n,x[2005],y[2005],ans; inline bool cmp(int x,int y) { return x&gt;y; } int main() { n=read(); for (int i=1;i&lt;=n;i++) x[i]=read(); for (int i=1;i&lt;=n;i++) y[i]=read(); sort(x+1,x+n+1,cmp); sort(y+1,y+n+1,cmp); int i=1,j=n,k=1,l=n; while (i&lt;=j) { if (x[i]&gt;y[k]) { ans+=200; i++; k++; } else if (x[i]&lt;y[k]) { ans-=200; j--; k++; } else if (x[j]&gt;y[l]) { ans+=200; j--; l--; } else { if (x[j]&lt;y[k]) ans-=200; j--; k++; } } printf(&quot;%d&quot;,ans); return 0; } 总结我今天的第一次提交分数是100+50+10+10=170，其中低级失误占的分数有50分，也就是那个忘了回溯。当然，这也反映出来我时间安排不当的问题。耗费大量时间在第二题，甚至连比较简单的贪心的第四题都没怎么写，而且第二题因为复杂度差了一点也只有50分。 总的来说现在低级失误还是越来越少了，但还是没有消失，所以还要多刷题啊！","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[]},{"title":"高精度算法模板","slug":"bigint","date":"2018-10-18T16:00:00.000Z","updated":"2018-11-09T03:58:43.404Z","comments":true,"path":"p/bigint.html","link":"","permalink":"https://llf0703.com/p/bigint.html","excerpt":"","text":"只是发个板子。虽说似乎NOIp近几年一般都是取膜而不是高精了，但我还是担心会考，所以就复习了一下。 定义用struct储存整个数和位数。整个数全部倒序方便计算。 struct bigint{ int s[5005],len; bigint(){memset(s,0,sizeof(s));len=0;} }; 加法inline bigint add(bigint x,bigint y) { bigint z; int len=max(x.len,y.len),add=0; for (int i=1;i&lt;=len;i++) { z.s[i]=x.s[i]+y.s[i]+add; add=z.s[i]/10; z.s[i]%=10; } if (add) z.s[++len]=add; z.len=len; return z; } 减法和加法原理相同，不过这里保证x&gt;y。所以 inline bigint sub(bigint x,bigint y) //x&gt;y { bigint z; int add=0,len=x.len; for (int i=1;i&lt;=len;i++) { z.s[i]=x.s[i]-y.s[i]-add; add=0; if (z.s[i]&lt;0) add=1,z.s[i]+=10; } z.len=len; return z; } 乘法高精乘低精原理也差不多，只是注意最后要把进位全部加完。 inline bigint times(bigint x,int y) { bigint z; int len=x.len,add=0; for (int i=1;i&lt;=len;i++) { z.s[i]=x.s[i]*y+add; add=z.s[i]/10; z.s[i]%=10; } while (add) { z.s[++len]=add%10; add/=10; } z.len=len; return z; } 高精乘高精写过了，但还没写成模板，暂时先咕咕咕了。 upd:2018.11.9 (NOIp前一天) 把这个flag拔了 bigint times(bigint x,bigint y) { bigint z; int lx=x.len,ly=y.len; for (int i=1;i&lt;=lx;i++) { int add=0; for (int j=1;j&lt;=ly;j++) { int now=x.s[i]*y.s[j]+add; z.s[i+j-1]+=now%10; if (z.s[i+j-1]&gt;=10) z.s[i+j-1]-=10,z.s[i+j]++; add=now/10; } if (add) z.s[i+ly]+=add; } z.len=lx+ly; while (!z.s[z.len]) z.len--; return z; } 除法高精除低精跟竖式一样，需要正着从高位往低位除。最后注意下把前导0去掉。 inline bigint division(bigint x,int y) { bigint z; int sum=0,len=x.len; for (int i=len;i;i--) { sum=sum*10+x.s[i]; z.s[i]=sum/y; sum%=y; } while (!z.s[len]) len--; z.len=len; return z; } 高精除高精写不来，noip估计也不会考。我太菜了。 比较大小返回1表示 $ x&gt;y $ ,-1表示 $ x&lt;y $ ,0表示 $ x=y $。按位比较即可。 inline int cmp(bigint x,bigint y) { if (x.len&gt;y.len) return 1; if (x.len&lt;y.len) return -1; for (int i=x.len;i;i--) { if (x.s[i]&lt;y.s[i]) return -1; if (x.s[i]&gt;y.s[i]) return 1; } return 0; } 输出逆序输出即可。 inline void print(bigint x) { for (int i=x.len;i;i--) printf(&quot;%d&quot;,x.s[i]); } 清空把数组和长度都赋为0。 inline void clear(bigint &amp;x) { for (int i=1;i&lt;=x.len;i++) x.s[i]=0; x.len=0; }","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[]},{"title":"2018.10.18日记","slug":"diary-20181018","date":"2018-10-17T16:00:00.000Z","updated":"2018-10-19T07:53:04.545Z","comments":true,"path":"p/diary-20181018.html","link":"","permalink":"https://llf0703.com/p/diary-20181018.html","excerpt":"","text":"那个啥，好吧我承认，这个东西是我10.19下午才赶出来的。 杂事无 正事今天打了第三套，非常不爽。打了一个多小时的第三题告诉我题目有问题，少了个省略号。徐妈说的要加时，但我又因为要上数学课最后一节课走了，然后最后就只有第一题有60分。回来我才发现第四题其实是最简单的一道题，洛谷评分只有PJ-。。。 然后下午调第二题调了一下午，现在都还没调出来。晚上又做第三题，可算是把高精板子全部打了一遍了，然后struct里面忘了赋初值又调了半天。真是荒废的一天。 感想比昨天还不爽 明天计划没啥计划了，见机行事，免得又咕咕咕了。","categories":[{"name":"日记","slug":"日记","permalink":"https://llf0703.com/categories/日记/"}],"tags":[]},{"title":"2018.10.17日记","slug":"diary-20181017","date":"2018-10-16T16:00:00.000Z","updated":"2018-10-17T13:42:10.628Z","comments":true,"path":"p/diary-20181017.html","link":"","permalink":"https://llf0703.com/p/diary-20181017.html","excerpt":"","text":"今天好废啊。感觉也没怎么颓，上午一场比赛，下午搞完比赛，晚上打了个板子然后只debug了一道题就过去了。计划还真就一语成畿地咕咕咕了。 杂事下午在我们体育课考试的时候与大佬们去打乒乓，去球馆又被赶出来了，然后就作死去操场上的球台去打乒乓。然后到处都是同班同学在考试，尴尬死了。 正事上午打了浙江十套的第一套，三道题都想出来了正解的思想，然鹅最后却只有80。。。第一题特判出了点锅，第二题算法稍微出了些问题，第三题连区间DP都写出来了，不过方程式有点锅。 下午就把这些题搞定了，然后去打乒乓。 晚上按计划做最短路相关。先打了一遍Dijkstra的模板，然后进试炼场做了洛谷P1462 通往奥格瑞玛的道路,然后就debug了一个小时，最后发现是我把排序后的数组在后面直接取下标使用。然后时间就差不多了。总结之类的明天补。 感想很不爽 明天计划继续搞图论。","categories":[{"name":"日记","slug":"日记","permalink":"https://llf0703.com/categories/日记/"}],"tags":[]},{"title":"2018.10.16日记·洛谷TG试炼场DP-lv1总结","slug":"diary-20181016","date":"2018-10-15T16:00:00.000Z","updated":"2018-10-16T13:52:55.639Z","comments":true,"path":"p/diary-20181016.html","link":"","permalink":"https://llf0703.com/p/diary-20181016.html","excerpt":"","text":"昨天计划完成情况因为上午下午都被徐妈拉去打onecode的天梯水题，所以咕咕咕了。只做完了dp的lv1模块。明天上午又有一套浙江的摸你题，所以把剩下的挪到明天应该就差不多了（大概吧） 杂事无 正事今天完成了onecode天梯的3和14，都是水题，就不写了。被14D坑惨了，加上快读全部TLE，cyc大佬的快读也是，然后他的fread也多WA了几个点。这TM绝壁是数据的锅，辣鸡OJ。 然后晚上做了洛谷TG试炼场的DP lv1 模块，还是大致总结一下。 洛谷P1005 矩阵取数游戏区间DP。对于每行，我们可以单独处理。用 $ f[l][r] $ 表示已经取了 $ l..r $ 这个区间后的得分最大值。然后记忆化搜索即可。 $ $ 肯定是爆long long了，按理来说应该要写高精的，但是我发现这玩意写高精如果没有运算符重载版的是真的恶心，然后__int128水过去了。 #include&lt;bits/stdc++.h&gt; #define ll __int128 using namespace std; inline ll read() { char ch=getchar(); ll f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } ll mp[85][85],n,m,f[85][85],ans,two[85]; ll dfs(int i,int l,int r) { if (f[l][r]!=-1) return f[l][r]; if (l==r) return f[l][r]=mp[i][l]*two[m]; return f[l][r]=max(dfs(i,l+1,r)+mp[i][l]*two[m-r+l],dfs(i,l,r-1)+mp[i][r]*two[m-r+l]); } void print(ll x) { if (x==0) return; print(x/10); putchar(x%10+&#39;0&#39;); } int main() { n=read(); m=read(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) mp[i][j]=read(); two[0]=1; for (int i=1;i&lt;=m;i++) two[i]=two[i-1]*2; for (int i=1;i&lt;=n;i++) { memset(f,-1,sizeof(f)); ans+=dfs(i,1,m); } if (ans==0) printf(&quot;0&quot;); else print(ans); return 0; } 洛谷P1373 小a和uim之大逃离首先容易想到把小a和uim两人的魔液量都记录下来，但这样空间就爆了。事实上，我们不关心他们具体的魔液量，只要他们两人魔液量的差是 $ (k+1) $ 的倍数就行了。所以记录两人魔液的差量就行了，如果超过 $ (k+1) $ 膜就行了。 用 $ f[i][j][l][t] $ 表示走到 $ (i,j) $ ，魔液差量为 $ l $ ，第 $ t $ 个人取 (因为k被用了)。方程式即为： f[i][j][l][0]=f[i-1][j][(l-mp[i][j]+k) mod k][1]+f[i][j-1][(l-mp[i][j]+k) mod k][1]f[i][j][l][t]=f[i-1][j][(l+mp[i][j]) mod k][0]+f[i][j-1][l+mp[i][j]) mod k][0]自觉这道题码风极其简洁丑陋。 #include&lt;bits/stdc++.h&gt; #define ha 1000000007 using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int f[805][805][16][2],mp[805][805];//到(i,j)，差值为k，l取 int n,m,k,ans; int main() { n=read(); m=read(); k=read(); k++; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) mp[i][j]=read()%k,f[i][j][mp[i][j]][0]=1; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) for (int l=0;l&lt;k;l++) for (int t=0;t&lt;=1;t++) f[i][j][l][t]=(f[i][j][l][t] + f[i-1][j][t ? (l+mp[i][j])%k : (l-mp[i][j]+k)%k][!t]%ha + f[i][j-1][t ? (l+mp[i][j])%k : (l-mp[i][j]+k)%k][!t]%ha)%ha; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) ans=(ans+f[i][j][0][1])%ha; printf(&quot;%d&quot;,ans); return 0; } 洛谷P2279 [HNOI2003]消防局的设立虽说放在DP板块，但贪心就能水过。。。 我们肯定要保证覆盖到叶节点，而对于每一个结点，他能覆盖到的地方就是最远到它爷爷，它孙子和它兄♂弟。它的爷爷节点就可以把它和它兄弟都覆盖了。 也就是说对于每个 叶节点或子节点及以下都已经被覆盖了 的点，选取它的爷爷节点一定是最优的。所以用一个优先队列每次找到深度最深的没有被覆盖的点的爷爷节点放上消防站，然后更新周围即可。 #include&lt;bits/stdc++.h&gt; #define pr pair&lt;int,int&gt; #define mp make_pair using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct Edge{ int next,to; } edge[2005]; int head[1005],deep[1005],cnt=1,n,m,a,b,c,fa[1005],ans; priority_queue &lt;pr&gt; q; bool vis[1005]; inline void add(int u,int v) { edge[cnt].to=v; edge[cnt].next=head[u]; head[u]=cnt++; } void dfs(int x,int f,int dep) { deep[x]=dep; fa[x]=f; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f) continue; dfs(y,x,dep+1); } } void dfs2(int x,int f,int dep) { if (dep&gt;2) return; vis[x]=1; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f) continue; dfs2(y,x,dep+1); } } inline void work(int x) { if (!x) x=1; //最高就是根节点 dfs2(x,0,0); } int main() { n=read(); for (int i=2;i&lt;=n;i++) { a=read(); add(a,i); add(i,a); } dfs(1,0,1); for (int i=1;i&lt;=n;i++) q.push(mp(deep[i],i)); while (!q.empty()) { int x=q.top().second; q.pop(); if (vis[x]) continue; work(fa[fa[x]]); ans++; } printf(&quot;%d&quot;,ans); return 0; } 洛谷P1220 关路灯也是区间DP。因为关灯不需要时间，所以路过后肯定把路上的灯都关上比较划算，这就意味着关了的等都是连续的并且可以看作一段区间。 用 $ f[l][r][0/1] $ 表示老张关了 $ l..r $ 区间的灯，然后站在左边/右边。转移的时候就加上所需的时间 $ \\times $ 两头没关的灯的功率和即可。算功率和预处理一个前缀和数组sum即可。转移方程式如下： f[l][r][1]=min(f[l][r-1][1]+(pos[r]-pos[r-1])*(sum[n]-sum[r-1]+sum[l-1]),f[l][r-1][0]+(pos[r]-pos[l])*(sum[n]-sum[r-1]+sum[l-1])); f[l][r][0]=min(f[l+1][r][0]+(pos[l+1]-pos[l])*(sum[n]-sum[r]+sum[l]),f[l+1][r][1]+(pos[r]-pos[l])*(sum[n]-sum[r]+sum[l])); 因为太菜了写不来递推式，我就用的记忆化搜索。 #include&lt;bits/stdc++.h&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int f[55][55][2],n,c,pos[55],v,sum[55]; int dfs(int l,int r,bool s) //0左1右 { if (l&gt;r) return 1e9; int &amp;ans=f[l][r][s]; if (ans!=-1) return ans; if (s) ans=min(dfs(l,r-1,s)+(pos[r]-pos[r-1])*(sum[n]-sum[r-1]+sum[l-1]),dfs(l,r-1,!s)+(pos[r]-pos[l])*(sum[n]-sum[r-1]+sum[l-1])); else ans=min(dfs(l+1,r,s)+(pos[l+1]-pos[l])*(sum[n]-sum[r]+sum[l]),dfs(l+1,r,!s)+(pos[r]-pos[l])*(sum[n]-sum[r]+sum[l])); return ans; } int main() { n=read(); c=read(); for (int i=1;i&lt;=n;i++) pos[i]=read(),v=read(),sum[i]=sum[i-1]+v; memset(f,-1,sizeof(f)); f[c][c][0]=f[c][c][1]=0; printf(&quot;%d&quot;,min(dfs(1,n,0),dfs(1,n,1))); return 0; } 奶牛那个题看了下题解，似乎是变形的背包，不想做了。 感想今天一共完成了11道题，因为DP难度较大所以和昨天其实也差不多。感觉还是计划赶不上变化，只有尽量完成计划。 明天的咕咕咕计划上午浙江第1套，下午及晚上 重做所有图论模板题并完成最短路问题板块。 以上。","categories":[{"name":"日记","slug":"日记","permalink":"https://llf0703.com/categories/日记/"}],"tags":[{"name":"算法-动态规划","slug":"算法-动态规划","permalink":"https://llf0703.com/tags/算法-动态规划/"}]},{"title":"2018.10.15日记","slug":"diary-20181015","date":"2018-10-14T16:00:00.000Z","updated":"2018-10-15T13:09:57.952Z","comments":true,"path":"p/diary-20181015.html","link":"","permalink":"https://llf0703.com/p/diary-20181015.html","excerpt":"","text":"今天是停课第一天，总的来说效率还是挺高的。不知道后面还能不能保持。 杂事今天最尴尬的事莫过于我被xtq大佬坑了，少上了节数学课（我只上数学）。不过好像都是做题，没讲新知识点，所以还好。 下午又被一个浙江来的老师虐的体无完肤，感觉自己学OI真的没前途了。 你洛谷才300多道题啊，我们那(ZJ)小学6年级学生题量都有这么多。 绿题及以下都是水题，蓝题和紫题算是中等题，你做的大多都是水题。 我当时考试的时候30分钟就把前两道题的正解打完了，然后睡了会儿，起来很快把第三题70分暴力打了。 我们当时打题都是劈里啪啦一顿打，如果你10分钟都还打不完暴力那NOIp差不多就完了。 你就搜个算法，然后把洛谷这一面所有题全部打完。想不到就去看题解，不一定要完全理解。 感觉自己遭受0x7fffffff点暴击，都不敢打水题了QAQ。 总的来说我的感受是：我好菜啊，我校好菜啊，我省好菜啊。 正事上午把高精的板块刷完了，然后把之前因为高精搁置的题处理完了。然后徐妈又让我们打了onecode天梯的第二套，全是水题，最后92分，如果我第三题开了long long就AK了。 下午去小黑屋打了好多道贪心的水题，可是我就连橙题都不能一遍过，还是太菜了。 晚上做了两道蓝题的DP，感觉海星。 今天总共做了15道题，还是很不错的。 感想虽然被虐的很惨，但是感觉他的话还是有很多道理的。尤其是要多做题，就算理解不了记下来方法就行了。不管是什么考试，其实题型都很难有变化，如果做过类似的题，至少思路这个最重要的部分就没问题了。而且像初二初三我理解了的算法还是忘了很多，还不如我背的数据结构熟练。 我个人感觉做水题还是很有帮助的，毕竟水题中经常会有些细节被我忽略，而这些细节难题中可能也会出现。毕竟“题多不压身”（我编的）。 明天计划完成动态规划lv1，重做所有图论模板题并完成最短路问题板块。 剩下的时间视情况安排。","categories":[{"name":"日记","slug":"日记","permalink":"https://llf0703.com/categories/日记/"}],"tags":[]},{"title":"NOIp前复习杂记","slug":"review-before-noip","date":"2018-10-13T16:00:00.000Z","updated":"2018-11-11T11:11:25.564Z","comments":true,"path":"p/review-before-noip.html","link":"","permalink":"https://llf0703.com/p/review-before-noip.html","excerpt":"","text":"每天大致的总结 10.23 完成ZJ第五套，打了些试炼场的图论题，学习Prim算法(我好菜啊，那么久都只会Kruskal)并填了半年前咕咕咕的坑: 最小生成树总结 10.24 完成ZJ第六套，下午优化一道题和完成那套题搞了一下午，又在WZX的怂恿下挑战了不编译写线段树和树剖直接交，都是先CE了一遍然后加了两个变量直接过的。做了一道prim的题然后就差不多了。 需要加强板块 高精 （差个重定义运算符版） 贪心 搜索 √ 二分、分治 二叉树，二叉排序树相关 图论相关模板 LCA（倍增） 二分图匹配 √ 强连通，割点等 最短路 √ 生成树 √ 字符串相关 KMP Trie hash 数论相关 DP Dark Fantasy 二进制相关知识 犯过的低级错误 数组排序后还是取下标直接使用：洛谷P1462 通往奥格瑞玛的道路 struct里面没赋初值：洛谷P1625 求和 差分约束最初没连负权边就写了Dijkstra后来发现不对又连了负权边却没改成SPFA：洛谷P1645 序列 在求两点的距离时没有注意double精度：洛谷P1265 公路修建 计划 10.15-10.29 做完洛谷试炼场提高 10.15 重点加强高精 10.16 完成动态规划lv1(完成)，重做所有图论模板题并完成最短路问题板块(未完成) 10.17 上午浙江第1套，下午及晚上 重做所有图论模板题并完成最短路问题板块 10.18 继续搞图论 10.19 打两套题，没啥计划了 我觉得计划赶不上变化，写日记又浪费时间，干脆不写了，只做些专题的复习。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[]},{"title":"初赛知识点复习(乱序)","slug":"noip-pretest-summary","date":"2018-10-10T16:00:00.000Z","updated":"2018-11-19T05:46:59.781Z","comments":true,"path":"p/noip-pretest-summary.html","link":"","permalink":"https://llf0703.com/p/noip-pretest-summary.html","excerpt":"","text":"排序希尔排序 作者： dreamcatcher-cx 出处： https://www.cnblogs.com/chengxiao/ 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在页面明显位置给出原文链接。 我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，n/2,(n/2)/2,...,1，称为增量序列。 希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。 例题：设一组初始记录关键字序列为(50，40，95，20，15，70，60，45)，则以增量d=4的一趟希尔排序结束后前4条记录关键字为（）。 A、40，50，20，95 B、15，40，60，20 C、15，20，40，45 D、45，40，15，20 答案：B std:sort std::sort 在数据量大时采用快排，分段递归排序；一旦分段后的数据小于某个值，就改用插入排序；如果递归层次过深，还会改用堆排序。 std::sort使用了快排，插入排序（希尔排序），堆排序。 例题：c++的std::sort实现中使用了以下哪些快速排序的算法（） A、快速排序 B、堆排序 C、基数排序 D、插入排序(希尔排序) 答案：ABD 归并排序运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。 时间效率：最好：$ O(log n) $ 最坏：$ O(n \\times log n) $ 其中归并就是将两个数组一个个比较即可，最多比较 $ 2n-1 $ 次。 例(NOIp2017 T11)：设 A 和 B 是两个长为 n 的有序数组，现在需要将 A 和 B 合并成一个排好序的 数组，请问任何以元素比较作为基本运算的归并算法最坏情况下至少要做 （ ）次比较。 答案：$ 2n-1 $ 排序的稳定性 稳定排序：插入排序、桶排序、基数排序 不稳定排序：快速排序、堆排序、希尔排序、归并排序、选择排序、冒泡排序 树哈夫曼树哈夫曼树是最优二叉树，即每个点的权值 $\\times$ 它到根节点的路径和最小。 哈夫曼树的构建方法是先将每个点单独构建成一颗只有自己的树，然后每次选取路径和最小的两棵树合并到一起，所有树合并完即构建成功。 例题：设某哈夫曼树中有199个结点，则该哈夫曼树中有（）个叶子结点。 A、 99 B、 100 C、 101 D、 102 答案：B 解析：把 $ n $ 个节点构建成哈夫曼树，相当于把 $ n $ 个只有根节点的子树合并成一个树，其中将任意两个子树合并成一个棵树需要增加一个节点，则一共需要增加 $ n-1 $ 个节点，才能使其变成一棵哈夫曼树，即这棵哈夫曼树一种有 $ 2n-1 $ 个树。$ 2 \\times n - 1 = 199 $ ，解得：$n = 100$ 表达式中缀表达式就是一般人用的表达式，初赛肯定不会考。 前缀表达式 以下内容转载至：https://www.cnblogs.com/chensongxian/p/7059802.html 就是把运算符放到数字的前面。 前缀转中缀：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 中缀转前缀： 初始化两个栈:运算符栈s1，储存中间结果的栈s2 从右至左扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较 遇到括号时 如果是右括号“)”，则直接压入s1 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最左边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式 后缀表达式就是把运算符放到数字的左边。 前缀转中缀：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 中缀转前缀：和中缀转后缀差不多，就是从左到右扫，最后逆序就行了。 例(NOIp2017 T7)：表达式 a (b + c) d 的后缀形式是（ ）。 A. a b c d + B. a b c + d C. a b c + d D. b + c a d 答案：B 个人看法中缀转前缀、后缀的方法其实根本用不上，只需要把选项转成中缀比对就行了。 当然，如果除了选择题的题考到了，那就另说吧。 图相关定义完全图：每对顶点都有边相连的图。完全无向图有 $ \\dfrac {n\\times \\left( n-1\\right) }{2} $ 条边，完全有向图有 $ n\\times \\left( n-1\\right) $条边。 连通图：每两个节点间都有路径相连的图。 例题例1：(NOIp2017 T8) 由四个不同的点构成的简单无向连通图的个数是（ ）。 答案：38 解析：按照分类标准连1条、连2条、连3条、连4条、连5条、连6条分类讨论。其中连1条、连2条由于无法构成无向连通图而舍掉。再对剩下的情况进行组合（因为无向），即在6条可能的边中连上3、4、5或6条，并将可以构成无向连通图的情况进行计数。不能构成的情况其实应该只有连3条边时才出现。比如ABCD 4个点三条边分别连接A-B、B-C、C-A就不行，一共四种不行的。算出来一共是42-4=38种。 例2：(NOIp2016 T8) G 是一个非连通简单无向图，共有 28 条边，则该图至少有（ ）个顶点。 答案：9 解析：因为是非连通图，所以至少有一个点不能连通，那么建一个完全图再把顶点+1即可。 $ \\dfrac {n\\times \\left( n-1\\right) }{2} = 28 $ ，解得 $ n=8 $ ，答案为 $ n+1=9 $。 递推时间复杂度的计算主定理(Master Theorem) 以下内容来自OI Wiki,全部内容在 CC BY-SA 4.0 和 SATA 协议之条款下提供，附加条款亦可能应用 根据SATA协议的相关要求，我已给了Star，并在此推荐此网站及感谢 @lr1d 和 @yeguanghao 对此内容的贡献。 我们可以使用 Master Theorem 来快速的求得关于递归算法的复杂度。 假设我们有递推关系式 T(n) = AT\\left(\\frac{n}{b}\\right)＋cn^k, \\qquad \\forall n > b那么 T(n) = \\begin{equation}\\begin{cases}\\Theta(n^{\\log_b a}) & a > b^k \\\\ \\Theta(n^k) & a< b^k \\\\ \\Theta(n^k\\log n ) & a = b^k \\end{cases}\\end{equation}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"比赛-初赛","slug":"比赛-初赛","permalink":"https://llf0703.com/tags/比赛-初赛/"}]},{"title":"科普基地国庆集训测试题总结","slug":"contest-summary-2","date":"2018-10-05T16:00:00.000Z","updated":"2018-11-19T05:46:59.901Z","comments":true,"path":"p/contest-summary-2.html","link":"","permalink":"https://llf0703.com/p/contest-summary-2.html","excerpt":"","text":"Day1 D1T1 剪刀石头布(stone)我一开始还真的以为模拟题的D1T1就是真的noipD1T1难度呢，现在想来还是太naive了。 最开始我没有注意到只能取最大或最小，以为都可以取，那么这道题就真的是D1T1难度了。当然，因为两位数要么最大，要么最小，所以这样我们也就解决了40%的点了。 对于每个一位数，直接取完就可以获胜，而只有10可以取到一位数，所以轮到10就输了，而如果要取到10只能选11~19。这样推下去，我们发现： 当n%10!=0时，小明肯定会将它取到%10=0来让自己获胜 当n%10==0时，小明只能把它取到第一种情况，小头就可以照1中小明的做以获胜 综上，我们得出结论： 当n%10!=0，输出”NO”; 当n%10==0，输出”YES” 然后我很开心地写完了， 很开心的得了40分。 while (t--) { n=read(); if (n%10==0) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); } 后来讲评的时候发现似乎只有1人AC，还有1人做法和我一样，但他没有看错题，就是铁了心要得40分的。 然后告诉我们正解竟然是搜索？！做法就是直接dfs，因为只要存在一种让小明胜利的方法，小明就一定能胜利（先手真好），所以搜到以后直接退出就行了。WTF？ 当然，对于搜到每一个数，结果一定是一样的，所以我们可以用个记忆化来优化。不加记忆化40，加了就A了 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int n,t,f[1000005]; bool dfs(int x) { if (f[x]!=-1) return f[x]; int y=x,mx=0,mn=1e9; while (y) { int res=y%10; mx=max(mx,res); if (res) mn=min(mn,res); y/=10; } if (dfs(x-mx) &amp;&amp; dfs(x-mn)) f[x]=0; else f[x]=1; return f[x]; } int main() { t=read(); memset(f,-1,sizeof(f)); f[0]=0; while (t--) { n=read(); if (dfs(n)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0; } D1T2 n染色(color)我在考场上推了整整两张草稿纸也没搞出个什么名堂，虽然似乎在数学上是个对的结论，但全部TLE。 正解就是个dp，$ f[i][j][k] $ 表示画到第i条边，用的是颜色j，上一条边的颜色是k。很显然，对于100%的数据肯定爆。 优化就是将后两维看成一个矩阵，因为不管是画到第几条边后两维的转移都是一样的，然后矩阵快速幂就行了。 代码先咕咕咕了，我真的会补上的。 先放个标程吧，我有时间再写。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 55,Mo = int(1e9) + 7; typedef long long LL; typedef int Matrix[MAXN][MAXN]; Matrix G,F,Tmp; LL N; int M; void Mul(Matrix &amp;a,Matrix &amp;b,Matrix &amp;c) { for(int i = 0;i &lt; M;i ++) for(int j = 0;j &lt; M;j ++) Tmp[i][j] = 0; for(int i = 0;i &lt; M;i ++) for(int k = 0;k &lt; M;k ++) if (a[i][k]) for(int j = 0;j &lt; M;j ++) if (b[k][j]) Tmp[i][j] = (Tmp[i][j] + a[i][k] * 1ll * b[k][j]) % Mo; for(int i = 0;i &lt; M;i ++) for(int j = 0;j &lt; M;j ++) c[i][j] = Tmp[i][j]; } int main() { freopen(&quot;color.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%lld%d&quot;, &amp;N, &amp;M); for(int i = 0;i &lt; M;i ++) for(int j = 0;j &lt; M;j ++) if (i != j) G[i][j] = 1; for(int i = 1;i &lt; M;i ++) F[0][i] = 1; N -= 2; for(;N;N &gt;&gt;= 1) { if (N &amp; 1) Mul(F,G,F); Mul(G,G,G); } int ans = 0; for(int i = 1;i &lt; M;i ++) ans = (ans + F[0][i]) % Mo; printf(&quot;%d\\n&quot;, ans * 1ll * M % Mo); return 0; } D1T3 Stree(stree)这道题是这套题唯一一道我有AC代码的题，不过我是在测完后20分钟后才A的。 对于30%的数据，很容易想到直接暴力。当然，我们也可以预处理一遍最小生成树，如果这条边在树里就直接输出，否则在跑一遍最小生成树。 其实这样我们就已经完成了正解的第一步了，也就是预处理最小生成树，而且在树里就直接输出。如果这条边不在最小生成树里，就意味着我们需要加上这条边，并且一定要删掉一条在树里的边。我们设加上的这条边的两端点为u和v，那么加上这条边后就一定会以这条边和u和v之前在树里的路径形成一个环，我们只需要在u和v原来的路径里找到一条边删掉就行了。 为了让权值和最小，我们肯定会选择删u和v路径中最大的边。这里可以用倍增LCA之类的方法解决，我用的是树剖。一般涉及到LCA的问题我都用树剖，主要是常数小。 树剖详解传送门: https://llf0703.com/p/shu-lian-pou-fen.html #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define ll long long using namespace std; inline ll read() { char ch=getchar(); ll f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct Edge{ ll stat,end,w,id; } edge[200005]; struct Edge2{ ll next,to,w,id; } e[400005]; struct Tree{ ll left,right,mx; } tree[800005]; ll fa[200005],n,m,cnt=1,dfsord,head[200005],deep[200005],w[200005],wnew[200005],id[200005],f[200005],son[200005],top[200005],siz[200005]; bool intree[200005]; inline bool cmp(Edge x,Edge y) //第一次按边权从大到小 { return x.w&lt;y.w; } inline bool cmp2(Edge x,Edge y) //第二次按原来顺序还原 { return x.id&lt;y.id; } ll getfa(ll x) { if (x==fa[x]) return fa[x]; fa[x]=getfa(fa[x]); return fa[x]; } inline void add(ll u,ll v,ll w) { e[cnt].to=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt++; } inline void pushup(int x) //线段树 { tree[x].mx=max(tree[x*2].mx,tree[x*2+1].mx); } void build(int x,int l,int r) { tree[x].left=l; tree[x].right=r; if (r-l==1) tree[x].mx=wnew[l]; else { build(x*2,l,(l+r)/2); build(x*2+1,(l+r)/2,r); pushup(x); } } ll query(int x,int l,int r) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].mx; else { ll ans=0,mid=(tree[x].left+tree[x].right)/2; if (l&lt;mid) ans=max(ans,query(x*2,l,r)); if (r&gt;mid) ans=max(ans,query(x*2+1,l,r)); return ans; } } void dfs1(int x,int fath,int dep) { f[x]=fath; deep[x]=dep; siz[x]=1; int mx=-1; for (int i=head[x];i;i=e[i].next) { int y=e[i].to; if (y==fath) continue; w[y]=e[i].w; dfs1(y,x,dep+1); siz[x]+=siz[y]; if (siz[y]&gt;mx) { mx=siz[y]; son[x]=y; } } } void dfs2(int x,int topf) { top[x]=topf; id[x]=++dfsord; wnew[dfsord]=w[x]; if (!son[x]) return; dfs2(son[x],topf); for (int i=head[x];i;i=e[i].next) { int y=e[i].to; if (y==f[x] || y==son[x]) continue; dfs2(y,y); } } inline ll qRangeMax(int u,int v) //查找路径最大 { ll ans=0; while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); ans=max(ans,query(1,id[top[u]],id[u]+1)); u=f[top[u]]; } if (deep[u]&gt;deep[v]) swap(u,v); ans=max(ans,query(1,id[u]+1,id[v]+1)); return ans; } int main() { freopen(&quot;stree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;stree.out&quot;,&quot;w&quot;,stdout); ll ans=0; n=read(); m=read(); for (int i=1;i&lt;=m;i++) { edge[i].stat=read(); edge[i].end=read(); edge[i].w=read(); edge[i].id=i; } sort(edge+1,edge+m+1,cmp); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=m;i++) { ll st=edge[i].stat,ed=edge[i].end,w=edge[i].w; ll gfa=getfa(st),gfb=getfa(ed); if (gfa==gfb) continue; fa[gfa]=gfb; //最小生成树过程 ans+=w; intree[edge[i].id]=1; //判断是否已在树里 add(st,ed,w); add(ed,st,w); } dfs1(1,0,1); dfs2(1,1); build(1,1,n+1); sort(edge+1,edge+m+1,cmp2); for (int i=1;i&lt;=m;i++) { if (intree[i]) //在树里直接输出 { printf(&quot;%lld\\n&quot;,ans); continue; } ll st=edge[i].stat,ed=edge[i].end,w=edge[i].w,mx; mx=qRangeMax(st,ed); printf(&quot;%lld\\n&quot;,ans-mx+w); } fclose(stdin); fclose(stdout); return 0; } Day2每天都有人催我写，我还是今天把它赶出来吧。咕咕咕？ D2T1 景点中心(scene)题目链接: https://vijos.org/p/1487 其实这道题很水，稍微推一下就可以出来，我在考场上不知道是脑子抽了还是怎么的竟然打了树剖。 我们一开始可以直接将1号点作为集合点，然后用一遍dfs将每个点到一号点的耗费算出来。我们在这里用dis[]表示。 很容易得到，对于每一个节点x的子节点y，所有点到它集合的耗费和dis[y]可以用如下的式子算出来： s[i] 代表第i个点的人数 dis[y]=dis[x]+w*(s[1]-2*s[y]); 然后再跑一遍dfs就行了。当然树上dp也可以做，但我dp太菜了就没写。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; inline ll read() { char ch=getchar(); ll f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct Edge{ ll next,to,w; } edge[200005]; ll head[100005],dis[100005],n,m,a,b,c,cnt=1,s[100005]; inline void add(int u,int v,int w) { edge[cnt].to=v; edge[cnt].next=head[u]; edge[cnt].w=w; head[u]=cnt++; } void dfs1(int x,int f) { for (int i=head[x];i;i=edge[i].next) { ll y=edge[i].to,w=edge[i].w; if (y==f) continue; dfs1(y,x); s[x]+=s[y]; dis[x]+=dis[y]+s[y]*w; } } void dfs2(int x,int f) { for (int i=head[x];i;i=edge[i].next) { ll y=edge[i].to,w=edge[i].w; if (y==f) continue; dis[y]=dis[x]+w*(s[1]-2*s[y]); dfs2(y,x); } } int main() { n=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); for (int i=1;i&lt;n;i++) { a=read(); b=read(); c=read(); add(a,b,c); add(b,a,c); } dfs1(1,0); dfs2(1,0); ll mn,mnsum=1e18; for (int i=1;i&lt;=n;i++) { if (dis[i]&lt;mnsum) { mnsum=dis[i]; mn=i; } } printf(&quot;%lld\\n%lld&quot;,mn,mnsum); return 0; } D2T2 方格游戏(fang)大水题，就是道入门难度的题强行套一个高精。 递推式如下: if (j==0) dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][2]; else if (j==1) dp[i][j]=dp[i-1][0]+dp[i-1][1]; else if (j==2) dp[i][j]=dp[i-1][0]+dp[i-1][2]; 其实这道题用__uint128_t就可以刚好水过。如果只知道__int128的话到100就会爆，但是大样例给了100，那么就可以特判水过了。 只是__uint128_t和__int128需要自己写个输出，不过写过快速io的话那就没什么问题。 void print(__uint128_t x) { if (x==0) return; print(x/10); putchar(x%10+&#39;0&#39;); } 这个东西只有64位系统下的gcc可以用，至于32位的ccf老爷机就别想了。我怎么感觉扯了这么多废话。 这道题大家都AC了，就不放代码了。 D2T3 运算符(calc)提交这道题请至: https://www.luogu.org/problemnew/show/U44496 说明：版权不归我所有，此题上传仅为学习，若有侵权请联系我删除 其实也很水，只需要掌握线性筛即可。就算不会线性筛小于1000的最多也就168个质数，打表即可。 我们用 $ f[i][j][k] $ 表示 $ i!j $ 中第k个质数的个数。递推式就是： f[i][j][k]=(f[i-1][j][k]+f[i][j-1][k])%ha初始值就是分解一下每个i，然后将结果存入*f[i][0]中即可。 inline void work(ll x) { ll y=x; for (int i=1;i&lt;=cnt &amp;&amp; zs[i]&lt;=y;i++) { while (x%zs[i]==0) { f[y][0][i]++; x/=zs[i]; } } } for (int i=1;i&lt;=n;i++) work(i); 全部代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #define ll long long #define ha 1000000009 using namespace std; inline ll read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } bool ss[1005]; int zs[170],cnt,n,k,f[1005][105][170],mx; inline void getprime() { memset(ss,1,sizeof(ss)); ss[0]=ss[1]=0; for (int i=2;i&lt;=mx;i++) { if (ss[i]) zs[++cnt]=i; for (int j=1;j&lt;=cnt &amp;&amp; zs[j]*i&lt;=mx;j++) { ss[zs[j]*i]=0; if (i%zs[j]==0) break; } } } inline void work(ll x) { ll y=x; for (int i=1;i&lt;=cnt &amp;&amp; zs[i]&lt;=y;i++) { while (x%zs[i]==0) { f[y][0][i]++; x/=zs[i]; } } } int main() { n=read(); k=read(); mx=max(n,k); getprime(); for (int i=1;i&lt;=n;i++) work(i); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=k;j++) for (int k=1;k&lt;=cnt;k++) f[i][j][k]=(f[i][j-1][k]+f[i-1][j][k])%ha; ll ans=1; for (int i=1;i&lt;=cnt;i++) ans=(ans*(f[n][k][i]+1))%ha; printf(&quot;%lld&quot;,ans); return 0; } 总结这两天题都很水，除了D1T3需要点简单的数据结构以外都是PJ难度的水题。但是每道题思维难度都比较高，都很难想到，或者说想复杂了（像我）。 我感觉可能noip就像这样，看了题解都会打，但是真正考场上能想出来并且能够AC的人又有多少呢？一直都是只要把暴力打好，打稳，并不需要学多少的辣鸡数据结构就可以拿一等奖甚至是高分。 所以我不应该再去搞些神仙算法和数据结构了，而就是应该把基础练稳练熟练扎实，争取每一次把自己能力所能拿到的分都拿到，我相信这样的成绩也一定会令人满意了。当然先过初赛最重要。 最后用一句lxl大佬的名言作结： 不要沉迷数据结构，会退役的。","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[{"name":"比赛-模拟题","slug":"比赛-模拟题","permalink":"https://llf0703.com/tags/比赛-模拟题/"}]},{"title":"近期做的几道搜索题的总结","slug":"search-summary-201809","date":"2018-09-27T16:00:00.000Z","updated":"2018-09-29T03:25:14.937Z","comments":true,"path":"p/search-summary-201809.html","link":"","permalink":"https://llf0703.com/p/search-summary-201809.html","excerpt":"","text":"我前段时期刷紫书才发现我搜索实在是菜的一匹，近期就在做这方面的题。今天突然有觉得自己该发一篇文章了，于是就有了这个。 洛谷P1379 八数码难题这道题其实并不是太难，说到这我想起了一位已经AFO搞物竞的同学花了三个月改了九个版本真正纯种暴搜最后拿了15的故事，主要难点集中在判重。这里我用的是康托展开。 康托展开是用来求在n个数的 所有排列组合中 某种排列组合的编号(就是从小到大的第几个)。 公式是 X=a[n] \\times (n-1)! + a[n-1] \\times (n-2)! +...+ a[1] \\times 0! a[i]表示第i个元素在未出现的元素(即第i~n位的数字中)中排列第几(也就是求后面有几个数字比ai小) 看公式其实原理就比较清楚了，下面就放个代码(求数列s的康托展开值) inline int get_hash(int *s) { int ans=0; for (int i=1;i&lt;=9;i++) { int sm=0; for (int j=i+1;j&lt;=9;j++) if (s[j]&lt;s[i]) sm++; ans+=fac[8-i+1]*sm; } return ans; } 整道题的代码我自己觉得还是很清晰的，就直接放代码吧 #include&lt;bits/stdc++.h&gt; using namespace std; struct MP{ int s[10],id,x0,y0; }; int vis[370005]; //vis[]始终标记的是康托展开值 int fac[]={1,1,2,6,24,120,720,5040,40320},fx[4]={0,1,0,-1},fy[4]={1,0,-1,0}; int mp[4][4],ans[10]={0,1,2,3,8,0,4,7,6,5}; inline int get_hash(int *s) //康托展开值 { int ans=0; for (int i=1;i&lt;=9;i++) { int sm=0; for (int j=i+1;j&lt;=9;j++) if (s[j]&lt;s[i]) sm++; ans+=fac[8-i+1]*sm; } return ans; } inline int to_line(int x,int y) //将二维坐标转换为一维 { return (x-1)*3+y; } inline void bfs(int stx,int sty) { queue &lt;MP&gt; q; MP stat; stat.x0=stx; stat.y0=sty; for (int i=1;i&lt;=3;i++) for (int j=1;j&lt;=3;j++) stat.s[to_line(i,j)]=mp[i][j]; stat.id=get_hash(stat.s); vis[stat.id]=1; //为了标记把初始值设为1，最后-1即可 q.push(stat); while (!q.empty()) { MP x=q.front(); q.pop(); int mapp[10]; for (int i=1;i&lt;=9;i++) mapp[i]=x.s[i]; //复制一份 for (int i=0;i&lt;4;i++) { int tx=x.x0+fx[i],ty=x.y0+fy[i]; if (tx&gt;3 || tx&lt;1 || ty&gt;3 || ty&lt;1) continue; //越界退出 int newpos=to_line(tx,ty),pos=to_line(x.x0,x.y0); //当前空格的位置和将要与之交换的位置 swap(mapp[pos],mapp[newpos]); int new_hash=get_hash(mapp); //得到新的康托展开值 if (vis[new_hash]) { swap(mapp[pos],mapp[newpos]); //不满足需要换回来 continue; } bool is_ans=1; //是否找到答案 MP y; //下面是完善拓展结点的信息 y.x0=tx; y.y0=ty; y.id=new_hash; for (int j=1;j&lt;=9;j++) { y.s[j]=mapp[j]; if (mapp[j]!=ans[j]) is_ans=0; } vis[y.id]=vis[x.id]+1; //vis[]顺便记录答案 if (is_ans) return; q.push(y); swap(mapp[pos],mapp[newpos]); } } } int main() { char x[10]; int s[10]; scanf(&quot;%s&quot;,x); int cnt=-1,stx,sty; for (int i=1;i&lt;=3;i++) { for (int j=1;j&lt;=3;j++) { mp[i][j]=x[++cnt]-&#39;0&#39;; if (mp[i][j]==0) stx=i,sty=j; //得到初始空格位置 } } bfs(stx,sty); int anshash=get_hash(ans); printf(&quot;%d&quot;,vis[anshash]-1); //最后-1，理由见上 return 0; } 洛谷P1074 靶形数独这题其实评分虚高，于是我又打了个入门难度平衡了一下。说的好像我有不打入门难度的题一样 刚开始看这评分还以为要用特殊的搜索方法+各种剪枝，事实上纯暴搜就有70，稍微改变下搜索顺序就AC了。 就跟真正的数独一样，我们要从已经填了的数字最多的那一行开始填。所以我们事先排个序，搜索时按照从多到少的顺序搜索即可。 值得一提的是我刚开始统计填了多少个数字时根本没有判断是不是0(也就意味着每一行都一样)都得了70分，不过很玄学的是开了O2以后就爆0了。所以这道题真的很水，大概普及难度就差不多了。 #include&lt;bits/stdc++.h&gt; using namespace std; int mp[10][10],ans; bool vis[3][10][10];//0横，1竖，2九宫格 int score[10][10]= {{0,0,0,0,0,0,0,0,0,0}, {0,6,6,6,6,6,6,6,6,6}, {0,6,7,7,7,7,7,7,7,6}, {0,6,7,8,8,8,8,8,7,6}, {0,6,7,8,9,9,9,8,7,6}, {0,6,7,8,9,10,9,8,7,6}, {0,6,7,8,9,9,9,8,7,6}, {0,6,7,8,8,8,8,8,7,6}, {0,6,7,7,7,7,7,7,7,6}, {0,6,6,6,6,6,6,6,6,6}}; struct line{ int num,id; } l[10]; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline int nine(int x,int y) //得到所在的九宫格编号 { return (x-1)/3*3+(y-1)/3+1; } void dfs(int id,int y) { int x=l[id].id; //得到从大到小第id行的行数 if (id==10) //搜完了统计答案 { int now=0; for (int j=1;j&lt;=9;j++) for (int k=1;k&lt;=9;k++) now+=mp[j][k]*score[j][k]; ans=max(ans,now); return; } if (y==10) //搜到最后一列后继续搜下一行 { dfs(id+1,1); return; } if (mp[x][y]) //已经填了，继续搜 { dfs(id,y+1); return; } for (int i=1;i&lt;=9;i++) //没填就填个数再搜 { if (vis[0][x][i] || vis[1][y][i] || vis[2][nine(x,y)][i]) continue; vis[0][x][i]=1; vis[1][y][i]=1; vis[2][nine(x,y)][i]=1; mp[x][y]=i; dfs(id,y+1); vis[0][x][i]=0; vis[1][y][i]=0; vis[2][nine(x,y)][i]=0; mp[x][y]=0; } return; } inline bool cmp(line x,line y) { return x.num&gt;y.num; } int main() { for (int i=1;i&lt;=9;i++) { l[i].id=i; for (int j=1;j&lt;=9;j++) { mp[i][j]=read(); if (mp[i][j]) l[i].num++; //统计已填个数 vis[0][i][mp[i][j]]=1; vis[1][j][mp[i][j]]=1; vis[2][nine(i,j)][mp[i][j]]=1; } } sort(l+1,l+10,cmp); //从大到小排序 ans=-1; //如果搜不到即无解就输出-1 dfs(1,1); printf(&quot;%d&quot;,ans); return 0; } 洛谷P1120 小木棍练习这道题对剪枝技能的提升很大，值得一刷。 总的来说这道题就是暴搜+各种神奇的剪枝。 搜索的思路就是先得到所有木棍的总长度，然后枚举各个可能的长度即能被总长度整除的长度，并以之进行搜索。当然事先需要将所有木棍从大到小排序，这样能加快搜索速度。 于是得到纯暴搜代码： len是当前枚举到的可能长度，num是有多少根，可以用总长度/可能长度得到，id是搜索到了第几根，sum是搜索到的当前的和 bool dfs(int len,int num,int id,int sum) { if (sum==len) { if (id==num) return 1; else return dfs(len,num,id+1,0); } int i=1; while (len-sum&lt;s[i]) i++; //跳过放不下的 bool can=0; for (;i&lt;=n;i++) { if (vis[i]) continue; vis[i]=1; can=dfs(len,num,id,sum+s[i]); if (can) return 1; vis[i]=0; } return 0; } 这个代码得了33分。于是考虑优化，我加了一句 if (len-sum-s[i]&lt;mn &amp;&amp; len!=sum+s[i]) break; 就是剩下的长度连最小的都放不下了就直接退出，相当于可以少搜索一层。现在39分了。但是后来发现这句话有些bug会导致WA于是就没用了。 我还是太菜了，只有去看题解。题解中写到当前搜索应该从上一次搜索用的下一根木棍开始搜。仔细一想，这样可以保证之前用的比后面用的木棍都大，可以去除很多重复。于是我就加了个last变量，下一次搜索从last+1开始。同时我自己还想到如果已经搜了num-1根了那么剩下的一定可以组成最后一根了，于是可以少搜一层，不过似乎并没有太大的作用。 现在搜索变成了这样： bool dfs(int len,int num,int id,int sum,int last) { if (sum==len) { if (id==num-1) return 1; //那个并没有什么卵用的优化 else return dfs(len,num,id+1,0,0); } bool can=0; int i=last+1; while (len-sum&lt;s[i]) i++; //从last+1开始 for (;i&lt;=n;i++) { if (vis[i]) continue; if (len-sum-s[i]&lt;mn &amp;&amp; len!=sum+s[i]) break; vis[i]=1; can=dfs(len,num,id,sum+s[i],i); if (can) return 1; vis[i]=0; } return 0; } 现在有了48分了。 我突然想到，i只是代表第几个，如果有重复的长度的话仅仅+1就会搜索很多次重复的情况。于是我事先预处理了一个nxt[]数组，表示排序后第一个与第i位不同的数在第几位： for (int i=n-1;i;i--) { if (s[i]==s[i+1]) nxt[i]=nxt[i+1]; else nxt[i]=i+1; } 搜索中的枚举步骤变成了这样： while (i&lt;=n) { if (vis[i]) { i++; continue; } vis[i]=1; can=dfs(len,num,id,sum+s[i],i); if (can) return 1; vis[i]=0; i=nxt[i]; } 现在57分了。我是真的没办法了，又去看了题解。接下来可谓是最重要的优化了： 对于每一次枚举，如果拼接失败，而且 当前已拼接的长度为0 或者 当前枚举的木棍长度=剩余未拼接长度 ，则停止枚举，直接退出循环。 感觉这个优化很难理解，更难想到，不过仔细想想还是比较容易理解的。 我们可以逆向来想一下。之所以退出循环，肯定是因为上一根拼的根本就不行。 如果当前已拼接的长度是0，那么当前枚举的木棍，肯定要在当前拼接的组用上。因为它必定会出现在剩下的任意一个组里，而如果当前拼接的是0，那么它出现在剩下的哪个组其实都一样。而如果拼接失败，则代表它拼在哪个组都不行，所以上一根就没对，直接退出。 如果当前枚举的木棍长度=剩余未拼接长度，那么把当前的这根拼上其实就转化为上面的情况了，所以同理。 总结一下所有优化： 事先排序，搜索时从大到小搜 每次枚举从上一次搜索用的下一根木棍开始搜 预处理nxt[]数组，跳过重复 如果拼接失败，而且当前已拼接的长度为0 或者 当前枚举的木棍长度=剩余未拼接长度 ，则停止枚举，直接退出循环 #include&lt;bits/stdc++.h&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int s[70],len[70],n,ans,mn,nxt[70]; bool vis[70]; inline bool cmp(int x,int y) { return x&gt;y; } bool dfs(int len,int num,int id,int sum,int last) { if (sum==len) { if (id==num-1) return 1; else return dfs(len,num,id+1,0,0); } bool can=0; int i=last+1; //优化2 while (len-sum&lt;s[i]) i=nxt[i]; while (i&lt;=n) { if (vis[i]) { i++; continue; } vis[i]=1; can=dfs(len,num,id,sum+s[i],i); if (can) return 1; vis[i]=0; if (sum==0 || sum+s[i]==len) break; //优化4 i=nxt[i]; } return 0; } int main() { n=read(); int cnt=0,sum=0,mx=0; for (int i=1;i&lt;=n;i++) { int a=read(); if (a&gt;50) continue; s[++cnt]=a; sum+=a; } n=cnt; sort(s+1,s+cnt+1,cmp); //优化1 mx=s[1]; mn=s[n]; int lcnt=0; for (int i=mx;i*2&lt;=sum;i++) { if (sum%i) continue; len[++lcnt]=i; } nxt[n]=n+1; for (int i=n-1;i;i--) //优化3 { if (s[i]==s[i+1]) nxt[i]=nxt[i+1]; else nxt[i]=i+1; } ans=sum;//全部拼成一根 for (int i=1;i&lt;=lcnt;i++) { if (dfs(len[i],sum/len[i],1,0,0)) { ans=len[i]; break; } } printf(&quot;%d&quot;,ans); return 0; } 洛谷P1378 油滴扩展裸的搜索。唯一需要注意的是如果两点距离&lt;0的话需要把最大半径取成0。还有最好全部用double，否则最大的那组数据可能有精度问题。 还有就是double输出应该用%f，cyc大佬某天WA掉就是因为用了%lf输出。 #include&lt;bits/stdc++.h&gt; #define pi acos(-1) using namespace std; double lx,rx,uy,dy; int cur[10],n; struct point{ double x,y,len; } pt[10]; bool vis[10]; inline double dis(int x1,int y1,int x2,int y2) { return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); } double dfs(int x) { if (x==n+1) return 0; double mx=0; for (int i=1;i&lt;=n;i++) { if (vis[i]) continue; cur[x]=i; vis[i]=1; double lmax=min(min(pt[i].x-lx,rx-pt[i].x),min(pt[i].y-dy,uy-pt[i].y)); //距离四条边的最短距离 for (int j=1;j&lt;x;j++) { double d=dis(pt[i].x,pt[i].y,pt[cur[j]].x,pt[cur[j]].y); lmax=min(lmax,max(d-pt[cur[j]].len,0.0)); //距离每个点的最小距离 } pt[i].len=lmax; double ans=pi*lmax*lmax+dfs(x+1); vis[i]=0; pt[i].len=0; mx=max(mx,ans); } return mx; } int main() { scanf(&quot;%d&quot;,&amp;n); double x,y,xx,yy; scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;xx,&amp;yy); lx=min(x,xx); rx=max(x,xx); uy=max(y,yy); dy=min(y,yy); for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;pt[i].x,&amp;pt[i].y); double s=(rx-lx)*(uy-dy); printf(&quot;%.0f&quot;,s-dfs(1)); // double输出用%f! return 0; } 以上。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-搜索","slug":"算法-搜索","permalink":"https://llf0703.com/tags/算法-搜索/"}]},{"title":"信息学科普基地Noip2017%你题第二试总结","slug":"contest-summary-1","date":"2018-09-18T16:00:00.000Z","updated":"2018-11-19T05:46:59.781Z","comments":true,"path":"p/contest-summary-1.html","link":"","permalink":"https://llf0703.com/p/contest-summary-1.html","excerpt":"","text":"题目 题解1.爬山(mountain)水题，直接搜索即可。 需要注意的是要用一个vis数组记录是否走过，否则在相等的时候会在两者之间不停地走下去，最后爆炸。我就是因为这个原因只有90分 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; using namespace std; int h[205][205],n,m,sx,sy,fx[4]={0,1,0,-1},fy[4]={1,0,-1,0},ans; bool vis[205][205]; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } void dfs(int x,int y) { vis[x][y]=1; bool hier=0; for (int i=0;i&lt;4;i++) { int tx=x+fx[i],ty=y+fy[i]; if (!vis[tx][ty] &amp;&amp; h[tx][ty]&gt;=h[x][y]) { hier=1; dfs(tx,ty); } } if (!hier) ans=max(ans,h[x][y]); return; } int main() { freopen(&quot;mountain.in&quot;,&quot;r&quot;,stdin); freopen(&quot;mountain.out&quot;,&quot;w&quot;,stdout); n=read(); m=read(); sx=read(); sy=read(); memset(h,-1,sizeof(h)); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) h[i][j]=read(); dfs(sx,sy); printf(&quot;%d&quot;,ans); return 0; } 2.字符串距离(string)这道题暴力就可以70 要什么正解系列 这道题的正解其实是找规律。显而易见，对于 $ T $ 中每个元素，它都会与 $ S $ 中的部分元素进行比较，只要确定与哪些元素比较即可。 下面就来推一下： S: a a a b b T: b a b a[1]: {1} a[2]: {2} a[3]: {3} 这是最开始的情况，其中a[i]代表 $ T $ 中第i个元素需要在 $ S $ 中比较哪几个元素。 S: a a a b b T: b a b a[1]: {1,2} a[2]: {2,3} a[3]: {3,4} 往后推一步。 S: a a a b b T: b a b a[1]: {1,2,3} a[2]: {2,3,4} a[3]: {3,4,5} 其实这个测试数据有点误导性，我一开始就搞错了。下面换一组数据再来推一下： S: a a a b b b b T: b a b b a a[1] {1,2,3} a[2] {2,3,4} a[3] {3,4,5} a[4] {4,5,6} a[5] {5,6,7} 完了。规律应该是显而易见了吧，对于 $ S $ 中第 $ i $ 个元素，它要与 $ T $ 中第 $ i $ ~ $ i+S.length()-T.length() $ 这些元素进行比较。之所以说容易被误导就是搞错成 $ i $ ~ $ i+T.length()-1 $ 进行比较。 我们可以用一个变量sum来记录当前长度为 $ S.length()-T.length()+1 $ 的区间内 $ a $ 的个数。当我们把 $ T $ 中元素往后推时，将区间同时后移一位。而区间中 $ a $ 的个数的变化只会发生在第 $ i-1 $ 和 $ i+T.length() $ 这两个元素中发生，只需要对应加减即可。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; int main() { freopen(&quot;string.in&quot;,&quot;r&quot;,stdin); freopen(&quot;string.out&quot;,&quot;w&quot;,stdout); string s,t; cin&gt;&gt;s&gt;&gt;t; int ls=s.length(),lt=t.length(); int sum=0,ans=0,len=ls-lt+1; for (int i=0;i&lt;len;i++) if (s[i]==&#39;a&#39;) sum++; int j=0; if (t[j]==&#39;a&#39;) ans+=len-sum; else ans+=sum; for (int i=len;i&lt;ls;i++) { if (s[i]==&#39;a&#39;) sum++; if (s[i-len]==&#39;a&#39;) sum--; j++; if (t[j]==&#39;a&#39;) ans+=len-sum; else ans+=sum; } printf(&quot;%d&quot;,ans); fclose(stdin); fclose(stdout); return 0; } 跳石头(stone)先 STO cyc大佬。 据大佬们说两次LIS+贪心就可以80分，但我却爆0了，果然还是太蒻了。 cyc大佬给我们讲了一个玄学的做法，至今也没有证明，不过就是能过这道题。而且仔细想想好像也挺有道理，也举不出反例来，所以就把它暂时当作正解吧。 解法就是维护两个数组s1[]和s2[]。对于每一个石头s[i],如果它大于s1[]中的最后一个元素，则把他加在后面；否则就在s1[]中找到一个它能够替换的值，并把它放进去。 能被替换的元素就是刚好要比当前石头s[i]大一些，而且加进去以后不会影响s1[]中单调性的元素，即 被替换元素 的前一个元素要小于s[i]。因为可以保证的是s1[]一定单增，所以这个被替换元素可以通过二分来查找到。 然后，将当前石头放入s1[]，然后将被替换的元素当作当前的石头与s2[]进行操作，与s1[]的操作同理。 最后，s1[]和s2[]中元素个数之和即为答案。 我刚写完cyc大佬就给我讲了证明方法，虽然不能严格证明，但是大致可以明白这个算法的道理。 大致这些操作可以分为两种情况： 对于每一个石头s[i],如果它大于s1[]中的最后一个元素，则把他加在后面 这种情况下就可以将答案+1，没有任何问题 否则就在s1[]中找到一个它能够替换的值，并把它放进去 我最开始就产生了疑问：s[i]的位置是肯定在此前就加进去的元素的后面的，如果用它替换掉中间一个值怎么行呢？ 其实，在这种情况下，答案是没有变化的。所以，我们其实并没有更新答案，这就是理解这种方法的精髓所在。 当我们将s[i]给替换到 $ left $ 这个位置时，可以保证 $ 1..left $ 这个区间内是真真正正确实可以跳到的石头。前面说过，我们并没有更新答案，所以后面那些元素根本不用管。 在最后一个元素被替换掉之前，后面即使再加入元素也只是之前情况下的答案+1，和当前情况没有任何关系，所以最后就可以取整个数组的元素个数作为答案；如果当前最后一个元素后来被替换掉了，则证明当前情况并不是最优解，而替换最后一个也不会产生顺序上的任何问题。 而第二个数组操作和第一个数组相同，证明也就同理了。 综上，这个算法是正确的，并不是玄学的。不得不感叹这个算法的巧妙性和cyc大佬的强大。 先放我的长但是自认为好懂些的代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int s[1005],n,m,ans,s1[1005],s2[1005]; int main() { freopen(&quot;stone.in&quot;,&quot;r&quot;,stdin); freopen(&quot;stone.out&quot;,&quot;w&quot;,stdout); n=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); int cnt1=0,cnt2=0; s1[++cnt1]=1; ans=1; for (int i=2;i&lt;=n;i++) { int x=s1[cnt1]; if (s[i]&gt;=s[x]) s1[++cnt1]=i,ans++; //直接放入，在这里就可以顺便统计ans else { int left; //被替换的元素在s1中的便号，注意不是s中的 int l=1,r=cnt1; while (l&lt;=r) //二分查找被替换元素 { int mid=(l+r)/2; if (s[s1[mid]]&gt;s[i]) left=mid,r=mid-1; else l=mid+1; } int leftpos=s1[left]; //这是被替换元素在s中的编号，用来下面比较大小 s1[left]=i; //将当前石头替换进去 int y=s2[cnt2]; if (s[leftpos]&gt;=s[y]) s2[++cnt2]=leftpos,ans++; //直接放入，统计ans else { int left2; //s2中被替换元素的编号 int l=1,r=cnt2; while (l&lt;=r) { int mid=(l+r)/2; if (s[s2[mid]]&gt;s[leftpos]) left2=mid,r=mid-1; else l=mid+1; } s2[left2]=leftpos; //替换。因为不需要统计更多的，所以到这就行了 } } } printf(&quot;%d&quot;,ans); return 0; } 下面放一个cyc大佬极简代码，据他说他还有更短的版本。 %cyc // By Dalao cyc,%cyc #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std; #define N 5005 int n, i, x, t[N]; int q[N][N]; void up(int p, int x) { if (x &gt;= q[p][t[p]]) { q[p][++t[p]] = x; return; } int l = 1, r = t[p], mid, u; while (l &lt;= r) { if (q[p][mid = (l + r) &gt;&gt; 1] &gt; x) { u = mid; r = mid - 1; } else { l = mid + 1; } } up(p + 1, q[p][u]), q[p][u] = x; } int main() { scanf(&quot;%d&quot;, &amp;n); for (i = 1; i &lt;= n; ++ i) scanf(&quot;%d&quot;,&amp;x), up(1,x); for (int i = 1; ; ++ i) { t[i] += t[i - 1]; if (t[i] == n) break; } printf(&quot;%d&quot;, t[2]); return 0; } 显而易见，cyc大佬还要统计后续数组的值，时间效率上肯定会差点，空间也会开大点。但是代码又短又巧妙，实在是太强辣！ 总结我个人的第一次提交只有160，得分为90+70+0，使用的算法的最高得分为100+70+80=250. 各题总结： 第一题情况考虑不完整，想到了相等的请况却没想到后续的问题 第二题没有找出规律，最后暴力没有失分，没什么非知识性的问题 第三题想到80分做法但写错，应该是对LIS算法的掌握不够熟练 总体失分原因: 对细节的思考不够到位 错误地追求每题AC，导致第二题花了很长时间没想到正解就心态比较爆炸，可能也是第三题爆炸的原因 对于部分算法掌握还不够熟练，人笨就要多刷题 总体来说这套题打的不理想，但是也发现了很多问题（我太菜了），所以还是很有价值的。 以上。","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[{"name":"比赛-模拟题","slug":"比赛-模拟题","permalink":"https://llf0703.com/tags/比赛-模拟题/"}]},{"title":"紫书第三章-数组与字符串 刷题总结","slug":"aoapc-book-3","date":"2018-08-06T03:00:00.000Z","updated":"2018-08-06T05:04:40.795Z","comments":true,"path":"p/aoapc-book-3.html","link":"","permalink":"https://llf0703.com/p/aoapc-book-3.html","excerpt":"","text":"我太菜了，已经沦落到天天刷水题的地步了。由于实在是太水了，我就只总结个别有价值的题。还有动规那一章迟早会总结完的（gugugu~） 例题3-6 UVa1584-Circular Sequence我一开始以为就是找到最小的那个然后再决定一下左边走还是右边走，后面才发现竟然只有4个字母，肯定有很多重复，而且还只有顺时针，显然这样不行。 然后做法就跟书上一样了，枚举从每个字母开始的字典序，和当前最优值比较即可。 话说这种水题总结来有什么意义，不过要是不总结我例题就没啥总结的了 #include&lt;bits/stdc++.h&gt; using namespace std; char cir[105]; int n,m,a,b,c; int main() { scanf(&quot;%d&quot;,&amp;n); while (n--) { scanf(&quot;%s&quot;,cir); int mnid=0,len=strlen(cir); for (int i=0;i&lt;len;i++) { for (int j=0;j&lt;len;j++) { if (cir[(i+j)%len]&lt;cir[(mnid+j)%len]) { mnid=i; break; } else if (cir[(i+j)%len]&gt;cir[(mnid+j)%len]) break; } } for (int i=0;i&lt;len;i++) printf(&quot;%c&quot;,cir[(mnid+i)%len]); printf(&quot;\\n&quot;); } return 0; } 习题3-3 UVa1225-Digit Counting似乎网上很多人直接暴力就行，我还离线处理排了一遍序，优化了个log。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,q[25],cnt,ans[10][25],now[10]; struct Query{ int q,id; } Q[25]; inline void work(int x) { while (x) { now[x%10]++; x/=10; } } inline bool cmp(Query x,Query y) { return x.q&lt;y.q; } int main() { cin&gt;&gt;m; for (int i=1;i&lt;=m;i++) { cin&gt;&gt;n; Q[i].q=n; Q[i].id=i; } sort(Q+1,Q+m+1,cmp); int j=1,last=-1; for (int i=1;i&lt;=m;i++) { for (;j&lt;=Q[i].q;j++) work(j); for (int k=0;k&lt;=9;k++) ans[k][Q[i].id]=now[k]; } for (int i=1;i&lt;=m;i++) { for (int j=0;j&lt;=8;j++) cout&lt;&lt;ans[j][i]&lt;&lt;&quot; &quot;; cout&lt;&lt;ans[9][i]&lt;&lt;endl; } return 0; } 3-5 UVa227-Puzzle我这道题做法大概是这样： 得到空格最开始位置 按照题意模拟，如果不合法，则标记后直接continue（否则会有多余输入） 因为操作有多行，所以每行都需要getline，读到0以后退出即可 坑点也挺多的，大概如下： 如果用getline的话最后一个字符如果没有是不会看成空格的，我后来直接改成不是字母就为空格 操作有多行 我最开始遇到不合法就直接退出，导致有输入被输到下一次操作 不合法操作除了越界还有操作不是ABLR！！！ 这道题格式要求很严，注意多余空格和换行都要过滤掉，如果不想PE的话还可以用uDebug测一下 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,a,b,c,kase; int main() { for (;;) { string s[5]; getline(cin,s[0]); int x=0,y=0; if (s[0][0]==&#39;Z&#39;) break; if (kase) cout&lt;&lt;endl; printf(&quot;Puzzle #%d:\\n&quot;,++kase); for (int i=1;i&lt;5;i++) getline(cin,s[i]); for (int i=0;i&lt;5;i++) { for (int j=0;j&lt;5;j++) { if (s[i][j]&lt;&#39;A&#39; || s[i][j]&gt;&#39;Z&#39;) { x=i; y=j; break; } } } bool done=0; bool can=1; for (;;) { string q; getline(cin,q); for (int i=0;i&lt;q.length();i++) { if (q[i]==&#39;0&#39;) { done=1; break; } if (!can) continue; else if (q[i]==&#39;A&#39;) { if (x==0) can=0; else { s[x][y]=s[x-1][y]; s[x-1][y]=&#39; &#39;; x--; } } else if (q[i]==&#39;B&#39;) { if (x==4) can=0; else { s[x][y]=s[x+1][y]; s[x+1][y]=&#39; &#39;; x++; } } else if (q[i]==&#39;L&#39;) { if (y==0) can=0; else { s[x][y]=s[x][y-1]; s[x][y-1]=&#39; &#39;; y--; } } else if (q[i]==&#39;R&#39;) { if (y==4) can=0; else { s[x][y]=s[x][y+1]; s[x][y+1]=&#39; &#39;; y++; } } else can=0; } if (done) { if (!can) printf(&quot;This puzzle has no final configuration.\\n&quot;); else { for (int i=0;i&lt;5;i++) { for (int j=0;j&lt;4;j++) cout&lt;&lt;s[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;s[i][4]; cout&lt;&lt;&quot;\\n&quot;; } } break; } } } return 0; } 3-8 UVa202-Repeating Decimals我最开始发现50位的话double肯定不够用啊，然后到网上一看才发现自己zz了。除的过程就跟竖式除法一样 $n \\times 10 / m$ 就行了，其它的枚举循环节即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,a,b,c; int s[100005],id[100005]; int main() { while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) { memset(s,0,sizeof(s)); memset(id,0,sizeof(id)); s[0]=n/m; printf(&quot;%d/%d = %d.&quot;,n,m,s[0]); n%=m; int cnt=1; while (n &amp;&amp; !id[n]) { id[n]=cnt; s[cnt]=n*10/m; n=n*10%m; cnt++; } if (!n) { for (int i=1;i&lt;cnt;i++) printf(&quot;%d&quot;,s[i]); printf(&quot;(0)\\n&quot;); } else { for (int i=1;i&lt;id[n];i++) printf(&quot;%d&quot;,s[i]); printf(&quot;(&quot;); for (int i=id[n];i&lt;=min(cnt-1,50);i++) printf(&quot;%d&quot;,s[i]); if (cnt&gt;50) printf(&quot;...&quot;); printf(&quot;)\\n&quot;); } printf(&quot; %d&quot;,!n ? 1 : cnt-id[n]); printf(&quot; = number of digits in repeating cycle\\n\\n&quot;); } return 0; } 完了，就酱。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"数据结构-字符串","slug":"数据结构-字符串","permalink":"https://llf0703.com/tags/数据结构-字符串/"}]},{"title":"2018暑假清北学堂济南集训游记","slug":"qbxt-2018-summer-summary","date":"2018-07-22T16:00:00.000Z","updated":"2018-09-20T12:52:36.281Z","comments":true,"path":"p/qbxt-2018-summer-summary.html","link":"","permalink":"https://llf0703.com/p/qbxt-2018-summer-summary.html","excerpt":"","text":"本来报的成都的班，结果取消了（多半是人不够），cyc，wzx和我就决定去济南，顺便提前去玩几天。颓废的气息 7.11早上和cyc坐动车去了曲阜，悲催的wzx因为坐了晚一点的车被困在成都了。晚上和cyc在酒店里颓CSGO和吃鸡，真是充实的一天。 7.12上午去了曲阜的三孔景区。感觉挺壮观的，环境也非常好（到处都是几百年的古树）。话说孔林和孔庙孔府离的好远啊，只有坐车去。从孔府出来就有人说35一个人去孔林，还好没听叫了个uber10块钱就过去了。孔林就只去看了孔子墓，周围绿水青山的，风水极好，听说只有孔姓后人才能埋在孔林，真是有福气。 中午退房以后就去火车站玩手机玩到4点，然后坐车去济南。晚上10点又去西站接wzx。这里要吐槽下济南城市布局，怎么火车站都在西边而且还这么远？而且第一条地铁也要2019年1月1日开通，真麻烦。 7.13我们三个上午骑车去了大明湖，然后坐在湖边打了一个多小时斗地主（真有意境）。后面大概逛了逛就回去了。 下午去看了山东情妇院博物馆（其实就是题词上面的“博物馆”看起来像情妇院，很久以前一个梗了）。本以为省博物馆位置肯定会好一些，结果所在的历下区又乱又差，到处都在施工，整的他们两个都在怀疑我是不是导航导错路了。而且全程上坡，累的一批，回来想着一直下坡很爽还tm车都找不到。（全济南共享单车都少，在成都我一直都是看到车后打开App扫，在济南我都是打开App找到车后扫，而且车都很旧，摩拜的新款车全都没有）。不过博物馆本身还是很有看头的，看完后对齐鲁大地的历史大概有了了解，虽然我主要都去关注字画去了，里面有一幅隶书是真的好看啊。 7.14起床晚了，他们两个哪都不想去，就颓废了一上午。中午惊喜地发现上课的地方就在我们这，然后搬行李过去报道。三床房没了，cyc就只有和另一个人拼一个房间。下午我们分工写一个局域网联机的斗地主，也没什么结果。 7.15QBXT集训-基础算法总结 上午主要讲的是一些基础算法，像什么搜索、二分、倍增、分治之类的。感觉还好。 下午考了套题，我才rk25，好菜啊。 7.16QBXT集训-数论总结 上午还是讲的基础算法，无话。 下午讲数论，终于算是系统地学了一遍数论了，我发现我之前的总结写的好水啊，还有bug。 7.17QBXT集训-数据结构总结 对于这一天的内容，我只想问：为什么课表上那么简单，讲的那么难？ 7.18QBXT集训-动态规划总结 数据结构和动规各讲一天半，下午开始讲动规。从头开始讲，所以还不算太难。 7.19又是一天dp，我感觉我dp怕是药丸。 7.20QBXT集训-动态规划总结 图论大多我都学过，但还是想巩固一下，结果大佬们纷纷表示不想听，于是难度就增加了，又听不懂了。我好菜啊！ 7.21QBXT集训-字符串总结 字符串我大概都还会，所以基本上就水了一上午。 下午又是一套%你题。lmj太毒瘤了！第一题找规律，我离线处理得了60分，然后死磕第二题，最后TLE了，然后总分60rk竟然都是18。lmj：这套题暴力都有240啊。 7.22讲了点往年试题，大家似乎都在水。最后lmj还成功上演了“一步扫雷”。 下午又去机场打斗地主打到晚上，飞机还延误一个小时。23号0点过终于到了。 总结这一趟过去收获还是挺大的，也见识了比我强太多的大佬，感觉自已好菜啊！ 总结还没写完，那些链接都只是在占坑，有时间慢慢补，就酱。 更新于2018.7.23","categories":[{"name":"游记","slug":"游记","permalink":"https://llf0703.com/categories/游记/"}],"tags":[]},{"title":"紫书第九章-动态规划初步 刷题总结","slug":"aoapc-book-9","date":"2018-05-26T00:39:00.000Z","updated":"2018-07-04T00:10:55.792Z","comments":true,"path":"p/aoapc-book-9.html","link":"","permalink":"https://llf0703.com/p/aoapc-book-9.html","excerpt":"","text":"很久没写过总结了。紫书做了那么多道题，但是我的动规并没有找到什么感觉，也就只有普及难度的可以不看题解写，剩下的都是看着题解写完的，我还是太弱了。这里还是来总结一下吧。 例题9-1 UVa1025-A Spy in the Metro$f[i][j]$表示在车站i，时刻是j，还剩多少时间（根紫书略有不同） 决策有三个，上左边的车，上右边的车，如果都不开往幼儿园就等一时刻的车。 注意还要判断某一时刻是否有车，$havel[i][t]$和$haver[i][t]$表示在i车站在t时刻是否有车。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,t,a,b,c,tright,tleft,Time,cnt; int T[55],tl,tr,f[55][255];//在车站i，时刻j，还剩多少时间 bool havel[55][255],haver[55][255];//在车站i，在t时刻是否有车 inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int main() { while (1) { memset(havel,false,sizeof(havel)); memset(haver,false,sizeof(haver)); memset(f,0,sizeof(f)); memset(T,0,sizeof(T)); n=read(); if (n==0) break; t=read(); for (int i=1;i&lt;n;i++) T[i]=read(); tright=read(); for (int i=1;i&lt;=tright;i++) { tr=read(); Time=tr; for (int j=1;j&lt;=n;j++) haver[j][Time]=true,Time+=T[j]; } tleft=read(); for (int i=1;i&lt;=tleft;i++) { tl=read(); Time=tl; for (int j=n;j&gt;=1;j--) havel[j][Time]=true,Time+=T[j-1]; } for (int i=1;i&lt;=n-1;i++) f[i][t]=2e9; f[n][t]=0; for (int j=t-1;j&gt;=0;j--) for (int i=1;i&lt;=n;i++) { f[i][j]=f[i][j+1]+1; if (i&gt;1 &amp;&amp; havel[i][j] &amp;&amp; j+T[i-1]&lt;=t) f[i][j]=min(f[i][j],f[i-1][j+T[i-1]]);//左 if (i&lt;n &amp;&amp; haver[i][j] &amp;&amp; j+T[i]&lt;=t) f[i][j]=min(f[i][j],f[i+1][j+T[i]]);//右 } printf(&quot;Case Number %d: &quot;,++cnt); if (f[1][0]&gt;=2e9) printf(&quot;impossible\\n&quot;); else printf(&quot;%d\\n&quot;,f[1][0]); } return 0; } 9-2 UVa437-The Tower of Babylon长和宽都会严格减小，直接记忆化搜索即可。 用$f[id][h]$表示第id个立方体，第h个数据做高。需要将每个立方体的三维按从小到大排序。 #include&lt;bits/stdc++.h&gt; #define Ans f[id][h] using namespace std; int n,m,a,b,c,h[4],f[40][4],ans,cnt; bool vis[40][4]; struct Edge{ int x,y,z; } edge[35]; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int dp(int id,int h) { if (vis[id][h]) return Ans; vis[id][h]=1; int E[2],hnow; if (h==1) E[0]=edge[id].y,E[1]=edge[id].z,hnow=edge[id].x; if (h==2) E[0]=edge[id].x,E[1]=edge[id].z,hnow=edge[id].y; if (h==3) E[0]=edge[id].x,E[1]=edge[id].y,hnow=edge[id].z;//判断当前哪两个数据做底面，哪一个是高 for (int i=1;i&lt;=n;i++) { if (edge[i].x&lt;E[0] &amp;&amp; edge[i].y&lt;E[1]) Ans=max(Ans,dp(i,3)+hnow); if (edge[i].x&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,2)+hnow); if (edge[i].y&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,1)+hnow); } return Ans; } int main() { for (;;) { memset(f,0,sizeof(f)); memset(vis,0,sizeof(vis)); ans=0; n=read(); if (n==0) break; for (int i=1;i&lt;=n;i++) { for (int j=1;j&lt;=3;j++) h[j]=read(); sort(h+1,h+4); edge[i].x=h[1]; edge[i].y=h[2]; edge[i].z=h[3]; for (int j=1;j&lt;=3;j++) f[i][j]=h[j]; } for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=3;j++) ans=max(ans,dp(i,j)); printf(&quot;Case %d: maximum height = %d\\n&quot;,++cnt,ans); } return 0; } 9-3 UVa1347-Tour将题目的走法改成两个人同时从左边出发，$f[i][j]$表示$1-max(i,j)$全部走过，且两人位置为i和j，还要走多少距离。可以定义i&gt;j，并且只允许走到i+1这个点。 决策就有两个：走到$f[i+1][j]$和$f[i+1][i]$ #include&lt;bits/stdc++.h&gt; using namespace std; double f[1005][1005]; int n,m,a,b,c,x[1005],y[1005]; inline double dis(int i,int j) { return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); } int main() { while (scanf(&quot;%d&quot;,&amp;n)!=EOF) { memset(f,0,sizeof(f)); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); for (int i=1;i&lt;n-1;i++) f[n-1][i]=dis(n-1,n)+dis(i,n); for (int i=n-2;i&gt;=2;i--) for (int j=1;j&lt;i;j++) f[i][j]=min(f[i+1][j]+dis(i,i+1),f[i+1][i]+dis(j,i+1)); cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;f[2][1]+dis(1,2)&lt;&lt;endl; } return 0; } 以上更新于2018.5.26 9-4 UVa116-单向TSP用$f[i][j]$来记录从起点到$(i,j)$的开销（和紫书上反过来了），注意边界判断就行了。唯一有点难度的就是输出路径，我感觉用的是有点像前向星的方法。 #include&lt;bits/stdc++.h&gt; using namespace std; int f[105][105],t[105][105],rd[105][105],newf[105]; int n,m; int main() { while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)) { for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;t[i][j]); int ans=1e9, last=0; for (int i=1;i&lt;=m;i++) f[i][n]=t[i][n]; if (n==1) { for (int i=1;i&lt;=m;i++) if (f[i][1]&lt;ans) ans=f[i][1],last=i; } else { for (int j=n-1;j&gt;=1;j--) for (int i=1;i&lt;=m;i++) { int dir[]={i,i+1,i-1}; if (i==1) dir[2]=m; if (i==m) dir[1]=1; sort(dir,dir+3); f[i][j]=f[dir[0]][j+1]+t[i][j]; rd[i][j]=dir[0]; for (int k=1;k&lt;3;k++) if (f[dir[k]][j+1]+t[i][j]&lt;f[i][j]) f[i][j]=f[dir[k]][j+1]+t[i][j],rd[i][j]=dir[k]; if (j==1 &amp;&amp; f[i][j]&lt;ans) ans=f[i][j],last=i; } } printf(&quot;%d&quot;,last); for (int i=rd[last][1],j=2;j&lt;=n;i=rd[i][j],j++) printf(&quot; %d&quot;,i); printf(&quot;\\n%d\\n&quot;,ans); } return 0; } 9-5 UVa12563-劲歌金曲数据范围真的假，直接01背包即可 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,t,a,b,c,k,kase,sum,ans; int cnt[55][10005],f[55][10005],s[55]; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } int main() { k=read(); while (k--) { n=read(); t=read(); for (int i=1;i&lt;=n;i++) s[i]=read(); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=t;j++) { cnt[i][j]=(i==1) ? 0 : cnt[i-1][j]; f[i][j]=(i==1) ? 0 : f[i-1][j]; if (j&gt;s[i]) { if (cnt[i][j]&lt;cnt[i-1][j-s[i]]+1) { cnt[i][j]=cnt[i-1][j-s[i]]+1; f[i][j]=f[i-1][j-s[i]]+s[i]; } else if (cnt[i][j]==cnt[i-1][j-s[i]]+1) f[i][j]=max(f[i][j],f[i-1][j-s[i]]+s[i]); } } printf(&quot;Case %d: %d %d\\n&quot;,++kase,cnt[n][t]+1,f[n][t]+678); } } 未完待续 以上内容更新于2018.7.3 9-6 UVa11400-照明系统设计跟书上的思路一样。每种灯泡要么都取，要么都不取。然后用一个类似LIS的动规方法，用$f[i]$表示前i种灯泡的最小开销，$sum[i]$表示前i种灯泡的数量$f[i]=min(f[i],f[j]+(sum[i]-sum[j])*node[i].c+node[i].k)(j&lt;i)$ #include&lt;bits/stdc++.h&gt; using namespace std; struct Node{ int v,k,c,l; } node[1005]; int n,m,a,b,sum[1005],f[1005]; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline bool cmp(Node a,Node b) { return a.v&lt;b.v; } int main() { for (;;) { n=read(); if (n==0) break; for (int i=1;i&lt;=n;i++) node[i].v=read(),node[i].k=read(),node[i].c=read(),node[i].l=read(); sort(node+1,node+n+1,cmp); for (int i=1;i&lt;=n;i++) sum[i]=node[i].l+sum[i-1]; f[0]=0; for (int i=1;i&lt;=n;i++) { int now=0x7fffffff; for (int j=0;j&lt;i;j++) now=min(now,f[j]+(sum[i]-sum[j])*node[i].c+node[i].k); f[i]=now; } printf(&quot;%d\\n&quot;,f[n]); } return 0; }","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-动态规划","slug":"算法-动态规划","permalink":"https://llf0703.com/tags/算法-动态规划/"}]},{"title":"基础数论学习总结","slug":"number-theory","date":"2018-05-09T12:46:00.000Z","updated":"2018-07-28T03:29:16.568Z","comments":true,"path":"p/number-theory.html","link":"","permalink":"https://llf0703.com/p/number-theory.html","excerpt":"","text":"原本打算先学Splay的，但想到提高组一般不考，而且我其它东西还差的多，就先把基础数论的东西复习一下，并且加深一下难度，还做了n多道水题，虽然主要是之前没过的。 1.整除这里就把整除的性质列一下： 如果$a \\mid b$且$b \\mid c$，那么$a \\mid c$ $a \\mid b$且$a \\mid c$等价于$\\forall x,y$，有$a \\mid (b \\times x + c \\times y)$ 设$m\\neq 0$,那么$a \\mid b $等价于$(m \\times a) \\mid (m \\times b)$ 设$x,y$满足$a \\times x+b \\times y=1$且$a \\mid n,b \\mid n$，那么$(a \\times b) \\mid n$ 若$b=q \\times d+c$,那么$d \\mid b$的充要条件是$d \\mid c$ 2.同余同余性质： 自反性 $a\\equiv a(mod m) $ 对称性 若$a\\equiv b(mod m)$则$b\\equiv a(mod m)$ 传递性 若$a\\equiv b(mod m),b\\equiv c(mod m)$，则$a\\equiv c(mod m)$ 同加性 若$a\\equiv b(modm)$，则$a+c\\equiv b+c(modm)$ 同乘性(1) 若$a\\equiv b(modm)$，则$a\\times c\\equiv b\\times c(modm)$ 同乘性(2) 若$a\\equiv b(modm),c\\equiv d(modm)$ ，则$a\\times c\\equiv b\\times d(modm)$ 同幂性 若$a\\equiv b(modm)$，则$a^{n}\\equiv b^{n} (modm)$ 3.最大公约数(gcd)辗转相除法基础方法，不再赘述 int gcd(int a,int b) { if (b==0) return a; return gcd(b,a%b); } 二进制算法不断去除因数2来提高gcd的效率 inline int gcd(int x,int y) { int i,j; if (x==0) return y; if (y==0) return x; for (i=0;0==(x&amp;1);i++) x&gt;&gt;=1;//去掉2 for (j=0;0==(y&amp;1);j++) y&gt;&gt;=1; if (i&gt;j) i=j; for (;;) { if (x&lt;y) x^=y,y^=x,x^=y; if (0==(x-=y)) return y&lt;&lt;i;//如果x==y gcd==x==y while (0==(x&amp;1)) x&gt;&gt;=1; } } 扩展欧几里得算法扩展欧几里得算法用来在已知$(a,b)$，求$(x,y)$，使$a\\times x+b\\times y=gcd(a,b)$ void exgcd(LL l,LL r,LL &amp;x,LL &amp;y) { if (r==0) x=1,y=0; else { exgcd(r,l%r,y,x); y-=l/r*x; } } 例题：洛谷P1516 青蛙的约会 #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; LL n,m,a,b,c,x,y,l,X,Y; inline int read() { char ch=getchar(); int x=0,f=1; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline LL exgcd(LL l,LL r,LL &amp;X,LL &amp;Y) { if (r==0) { X=1; Y=0; return l; } LL a=exgcd(r,l%r,Y,X); Y-=l/r*X; return a; } int main() { x=read(); y=read(); m=read(); n=read(); l=read(); LL deltav=(m&gt;=n) ? m-n : n-m; LL deltas=(m&gt;=n) ? y-x : x-y; LL k=exgcd(deltav,l,X,Y); if (deltas%k!=0) printf(&quot;Impossible&quot;); else printf(&quot;%lld&quot;,(X*(deltas/k)%(l/k)+(l/k))%(l/k)); return 0; } 4.逆元若$a\\times x\\equiv 1(modb)$，就称x是a的逆元。 可以将这个式子转化为$a\\times x+b\\times y=1$，然后用扩展欧几里得定理求解。 当然也有一种线性算法，在需要求连续逆元时是最优的算法。 以下内容来自https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan 首先我们有一个, $1^{-1}\\equiv 1(\\bmod p)$ 然后设 $p=k∗i+r,r&lt;i,1&lt;i&lt;p$ ,再将这个式子放到 $\\bmod {p}$ 意义下就会得到： $k∗i+r≡0(modp)$ 然后乘上 $i^{-1} , r^{-1}$ 就可以得到: $k*r^{-1}+i^{-1}\\equiv 0 (\\bmod p)$ $i^{-1}\\equiv -k*r^{-1} (\\bmod p)$ $i^{-1}\\equiv -\\lfloor \\frac{p}{i} \\rfloor*(p \\bmod i)^{-1} (\\bmod p)$ 模板题：洛谷P3811 【模板】乘法逆元 #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; LL n,p,inv[3000005]; int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;p); inv[1]=1; printf(&quot;%d\\n&quot;,inv[1]); for (int i=2;i&lt;=n;i++) { inv[i]=-(p/i)*inv[p%i]; inv[i]=(inv[i]%p+p)%p; printf(&quot;%d\\n&quot;,inv[i]); } return 0; } 5.中国剩余定理还是就放一个我看的吧 https://blog.csdn.net/acdreamers/article/details/8050018 例题：洛谷P3868 [TJOI2009]猜数字 可以用裸的中国剩余定理来做，但是要注意必须用快速乘，不然$10^{18}\\times 10^{18}$肯定会超范围。 #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; LL n,m,k; LL A[15],B[15]; inline LL read() { char ch=getchar(); LL f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline void exgcd(LL l,LL r,LL &amp;x,LL &amp;y) { if (r==0) x=1,y=0; else { exgcd(r,l%r,y,x); y-=l/r*x; } } inline LL gcd(LL a,LL b) { if (b==0) return a; return gcd(b,a%b); } inline LL qmul(LL a,LL b,LL mod) { LL ans=0,k=a,f=1; if (k&lt;0) k=-k,f*=-1; if (b&lt;0) b=-b,b*=-1; while (b) { if (b&amp;1) ans=(ans+k)%mod; k=(k+k)%mod; b&gt;&gt;=1; } return ans*f; } inline LL crt() { LL M=1,ans=0; for (int i=1;i&lt;=k;i++) M*=B[i]; for (int i=1;i&lt;=k;i++) { LL x,y,Mi=M/B[i]; exgcd(Mi,B[i],x,y); x=(x%B[i]+B[i])%B[i]; ans=(ans+qmul(qmul(Mi,x,M),A[i],M))%M; } return (ans&lt;0)?ans+M:ans; } int main() { k=read(); for (int i=1;i&lt;=k;i++) A[i]=read(); for (int i=1;i&lt;=k;i++) B[i]=read(); for (int i=1;i&lt;=k;i++) A[i]=(A[i]%B[i]+B[i])%B[i]; printf(&quot;%lld&quot;,crt()); return 0; } 6.素数筛普通筛法inline void getprime() { memset(ss,true,sizeof(ss)); int cnt=1; ss[0]=ss[1]=false; for (a=2;a&lt;=sqrt(n);a++) { if (ss[a]) zs[cnt++]=a; for (b=2;b&lt;=n/a;b++) ss[a*b]=false; } } 线性筛可以很容易的想到，普通筛法中筛了很多重复的数。而线性筛法可以避免重复。主要思路是运用得到了的素数来标记后面的合数。 inline void getprime() { memset(ss,true,sizeof(ss)); ss[0]=ss[1]=false; for (int i=2;i&lt;=n;i++) { if (ss[i]) zs[cnt++]=i; for (int j=1;j&lt;cnt &amp;&amp; zs[j]*i&lt;=n;j++) { ss[zs[j]*i]=false; if (i%zs[j]==0) break; } } } 以上内容更新于2018.5.9 线性筛法错误修正于2018.7.28","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://llf0703.com/tags/数论/"},{"name":"数学","slug":"数学","permalink":"https://llf0703.com/tags/数学/"}]},{"title":"点分治总结","slug":"dian-fen-zhi","date":"2018-04-26T11:28:00.000Z","updated":"2018-11-19T05:47:00.001Z","comments":true,"path":"p/dian-fen-zhi.html","link":"","permalink":"https://llf0703.com/p/dian-fen-zhi.html","excerpt":"","text":"markdown原文: https://md.llf0703.com/p/dian-fen-zhi.md 我自己感觉点分治是一种比较玄学神奇的算法，感觉自己也只是理解了一点皮毛而已。这里就谈谈点分治的实现方法和一些运用。 方法点分治其实是将一棵树的点不断分为多棵子树，分别得到子树节点到子树根的距离来进行处理。 既然要有一个点为根节点，那么应该选取哪一个点呢？ 既然要向下分治，如果把一个原来的叶节点作为分治的根节点，那么遍历每一个点的时间开销是非常大的。然而如果这个点的左右子树都达到最大，那么遍历的时间开销就要少很多。而子树的重心就能满足这个性质，所以我们选取子树的重心作为分治中心，即分治子树的根。 1.求重心首先我们需要了解重心是什么 树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心，删去重心后，生成的多棵树尽可能平衡。— 百度百科 提取关键词： 其所有的子树中最大的子树节点数最少 生成的多棵树尽可能平衡 第1点告诉我们怎么求重心，只需要记录每一个点的子树大小，然后按着定义做就行了。 第2点告诉我们选择重心作为分治点的原因，因为多棵树尽可能平衡，就可以使复杂度变得最优秀。 这个不是重点，直接上代码（感觉和树剖差不多）： 这里可以先不管vis[]，后面会解释sizenow是当前这个子树的大小，后面会讲到mx是当前分治到的最大的子树节点最小值 void getroot(int x,int f) { size[x]=1; son[x]=0; for (int i=head[x];i;i=edge[i].next)//遍历每一个子节点 { int y=edge[i].to; if (y==f || vis[y]) continue; getroot(y,x); size[x]+=size[y];//加上子节点的子树大小 son[x]=max(son[x],size[y]);//求最大的子树 } son[x]=max(son[x],sizenow-size[x]); if (son[x]&lt;mx)//使最大的子树节点最少 { mx=son[x]; root=x;//记录分治中心（根节点） } } 2.进行分治分治其实就是一个递归，不断地将子树进行处理就行了，注意要用vis[]标记已经访问防止重复。先上代码： solve就是解决问题，每一道题有不同的作用，这里不用管。 void divide(int x) { vis[x]=true;//标记已访问 solve(x,0,1); for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; solve(y,edge[i].w,0); mx=2147483646;root=0;sizenow=size[y];//得到当前树的大小，将mx和root初始化 getroot(y,0);//得到子树的分治中心 divide(root);//分治子树 } } 至于为什么有两次solve，主要是为了去重。原因如下： 以下内容来自https://blog.csdn.net/qq_39553725/article/details/77542223 对于以下这棵树：显然A点是它的重心。我们假设现在分治到了A点（当前点为A）我们一开始求解贡献时，会有以下路径被处理出来：A—&gt;AA—&gt;BA—&gt;B—&gt;CA—&gt;B—&gt;DA—&gt;EA—&gt;E—&gt;F (按照先序遍历顺序罗列)那么我们在合并答案是会将上述6条路径两两进行合并。这是注意到：合并A—&gt;B—&gt;C 和 A—&gt;B—&gt;D 肯定是不合法的！！因为这并不是一条树上(简单)路径，出现了重边，我们要想办法把这种情况处理掉。处理方法很简单，减去每个子树的单独贡献。例如对于以B为根的子树，就会减去：B—&gt;BB—&gt;CB—&gt;D这三条路径组合的贡献读者可能会有疑问，这与上面的6条路径并不一样啊。我们再回过头来看一看这两句代码：ans = ans + solve(tr,0);ans = ans - solve(v,t[i].len);注意到了吧，solve函数的第二个初始值并不相同。我们在处理子树时，将初始长度设为连接边长，这样做就相当于个子树的每个组合都加上了A—&gt;的路径，从而变得与上面一样。个人认为这是点分治一个极其重要的地方，读者们一定要理解清楚。 好了，分治就完了。不过和树剖一样，只是剖分完是并没有什么卵用的，还需要具体问题具体分析。 具体例题1.洛谷P3806 【模板】点分治1题目链接：https://www.luogu.org/problemnew/show/P3806 对于这道题询问的距离为k的点是否存在，我们可以用一种类似桶排序的笨方法，将距离作为数组下标，统计到这个距离就将数组++，最后不为0就存在，反之不存在。 要得到两点之间的距离，只需要记录两个点分别到根的距离，然后相加即可。 这里的query函数用作求当前分治到的树中点到根的距离，solve用于相加得到两点间距离并统计。 #include&lt;bits/stdc++.h&gt; using namespace std; struct Edge{ int next,to,w; } edge[20005]; int size[20005],son[20005],dis[20005],head[20005]; bool vis[20005]; int sum[10000005];//存距离是否存在，注意大小和n不一样 int n,m,k,a,b,c,ord,cnt=1,mx,root,sizenow; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline void add(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++; } void getroot(int x,int f) { size[x]=1; son[x]=0; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; getroot(y,x); size[x]+=size[y]; son[x]=max(son[x],size[y]); } son[x]=max(son[x],sizenow-size[x]); if (son[x]&lt;mx) { mx=son[x]; root=x; } } void query(int x,int f,int dist) { dis[++ord]=dist;//得到到根的距离 for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; query(y,x,dist+edge[i].w);//查询子节点 } } void solve(int x,int length,bool s) //s=false时要去重 { ord=0; query(x,0,length); for (int i=1;i&lt;=ord-1;i++) for (int j=i+1;j&lt;=ord;j++) { if (s==true) sum[dis[i]+dis[j]]++; else sum[dis[i]+dis[j]]--; //进行统计 } } void divide(int x) { vis[x]=true; solve(x,0,1); for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; solve(y,edge[i].w,0); mx=2147483646;root=0;sizenow=size[y]; getroot(y,0); divide(root); } } int main() { memset(vis,false,sizeof(vis)); n=read();m=read(); for (int i=1;i&lt;n;i++) { a=read();b=read();c=read(); add(a,b,c); add(b,a,c); } root=0;mx=2147483646;sizenow=n; getroot(1,0); divide(root); for (int i=1;i&lt;=m;i++) { a=read(); if (sum[a]) printf(&quot;AYE\\n&quot;); else printf(&quot;NAY\\n&quot;); } return 0; } 2.[国家集训队]聪聪可可题目链接： 洛谷 P2634： https://www.luogu.org/problemnew/show/P2634 BZOJ P2152： https://www.lydsy.com/JudgeOnline/problem.php?id=2152 这里使用一个mod3[3]数组来记录两点间距离%3后的值分别为0,1,2的个数。 对每个节点求出其子树内的dis，经过该点的路径数即为mod3[1]*mod3[2]*2+mod3[0]^2。 因为要求答案互质，所以还需要一个求最大公约数的操作。 #include&lt;bits/stdc++.h&gt; using namespace std; struct Edge{ int next,to,w; } edge[40005]; int head[40005],size[40005],son[40005],mod3[3]; bool vis[40005]; int n,m,a,b,c,cnt=1,ord,root,mx,sizenow,ans; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline void add(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++; } inline void init(int sizen) { mx=2147483647;root=0;sizenow=sizen; } void getroot(int x,int f) { size[x]=1; son[x]=0; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y] || y==f) continue; getroot(y,x); size[x]+=size[y]; son[x]=max(son[x],size[y]); } son[x]=max(son[x],sizenow-size[x]); if (mx&gt;son[x]) { mx=son[x]; root=x; } } void query(int x,int f,int dist) { mod3[dist%3]++; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y] || y==f) continue; query(y,x,dist+edge[i].w); } } inline int solve(int x,int length) { memset(mod3,0,sizeof(mod3)); query(x,0,length); return mod3[0]*mod3[0]+mod3[1]*mod3[2]*2; } void divide(int x) { vis[x]=true; ans+=solve(x,0); for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; ans-=solve(y,edge[i].w); init(size[y]); getroot(y,0); divide(root); } } int gcd(int x,int y)//求最大公约数 { if (y==0) return x; return gcd(y,x%y); } int main() { n=read(); for (int i=1;i&lt;n;i++) { a=read();b=read();c=read(); add(a,b,c); add(b,a,c); } init(n); getroot(1,0); divide(root); printf(&quot;%d%c%d&quot;,ans/gcd(ans,n*n),&#39;/&#39;,n*n/gcd(ans,n*n)); return 0; } 3.[IOI2011]Race题目链接： 洛谷 P4149：https://www.luogu.org/problemnew/show/P4149 BZOJ P2599: https://www.lydsy.com/JudgeOnline/problem.php?id=2599 BZOJ是权限题，若没交钱就用洛谷，或者用离线BZOJ题库（by ruanxingzhi）：https://bzoj.llf0703.com/p/2599.html 洛谷上这道题是@larryzhong大佬提供的，比我小3岁却吊打我，在这里先%%%为敬 因为这道题需要得到边数最小，我们对于距离为i的点建立tmp[i]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边 点分治，每次先对每棵子树遍历，求出每个点i到root的距离dis[i]，以及走过的边数d[i]，那么ans=min(ans,tmp[k-dis[i]]+d[i]). 遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵。最后所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf） #include&lt;bits/stdc++.h&gt; #define maxint 1e9 using namespace std; struct Edge{ int next,to,w; } edge[400005]; bool vis[200005]; int size[200005],son[200005],dis[200005],head[400005],esum[200005]; //tmp[i]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边 //每个点i到root的距离dis[i]，以及走过的边数esum[i] int tmp[1000005]; int n,m,k,a,b,c,cnt=1,sizenow,mx,ans,root; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return x*f; } inline void add(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++; } inline void init(int sizen) { mx=maxint; root=0; sizenow=sizen; } void getroot(int x,int f) { size[x]=1; son[x]=0; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y] || y==f) continue; getroot(y,x); size[x]+=size[y]; son[x]=max(son[x],size[y]); } son[x]=max(son[x],sizenow-son[x]); if (mx&gt;son[x]) { mx=son[x]; root=x; } } void query(int x,int f,int dist,int edgesum) { dis[x]=dist; esum[x]=edgesum; if (dis[x]&lt;=k) ans=min(ans,tmp[k-dis[x]]+esum[x]); for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; query(y,x,dist+edge[i].w,edgesum+1); } } //遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵 void update(int x,int f,bool s) { if (dis[x]&lt;=k) if (s) tmp[dis[x]]=min(tmp[dis[x]],esum[x]); else tmp[dis[x]]=maxint; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; update(y,x,s); } } void divide(int x) { vis[x]=true; tmp[0]=0;//每次进入dfs_solve时tmp[0]=0，因为这个当前的根到自己距离为0，走过了0条边 for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; query(y,0,edge[i].w,1); update(y,0,true); } for (int i=head[x];i;i=edge[i].next)//所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf） { int y=edge[i].to; if (vis[y]) continue; update(y,0,false); } for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; init(size[y]); getroot(y,0); divide(root); } } int main() { n=read();k=read(); for (int i=1;i&lt;=k;i++) tmp[i]=maxint; ans=maxint; for (int i=1;i&lt;n;i++) { a=read();b=read();c=read(); a++;b++; add(a,b,c); add(b,a,c); } init(n); getroot(1,0); divide(root); if (ans==maxint) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans); return 0; } 4.洛谷 P4178 Tree题目链接： https://www.luogu.org/problemnew/show/P4178 这道题好像比上面那道还简单一点，我也不知道我为什么先刷的上面那一道 注意的是可以在统计有多少个路径权值&lt;=k时可以进行一次排序，直接枚举两个端点就可以处理了，可以节省时间。 #include&lt;bits/stdc++.h&gt; #define inf 0xfffffff using namespace std; struct Edge{ int next,to,w; } edge[80005]; bool vis[40005]; int dis[40005],size[40005],son[40005],head[40005]; int root,mx,sizenow,cnt=1,n,m,a,b,c,ord,k,ans; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline void add(int u,int v,int w) { edge[cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt++; } inline void init(int sizen) { mx=inf; sizenow=sizen; root=0; } void getroot(int x,int f) { size[x]=1; son[x]=0; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; getroot(y,x); size[x]+=size[y]; son[x]=max(son[x],size[y]); } son[x]=max(son[x],sizenow-size[x]); if (mx&gt;son[x]) { mx=son[x]; root=x; } } void query(int x,int f,int dist) { dis[++ord]=dist; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f || vis[y]) continue; query(y,x,dist+edge[i].w); } } inline int solve(int x,int length) { ord=0; query(x,0,length); sort(dis+1,dis+ord+1); int ans=0,stat=1; while (stat&lt;ord) { if (dis[stat]+dis[ord]&lt;=k) { ans+=ord-stat; stat++; } else ord--; } return ans; } void divide(int x) { ans+=solve(x,0); vis[x]=true; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (vis[y]) continue; ans-=solve(y,edge[i].w); init(size[y]); getroot(y,0); divide(root); } } int main() { n=read(); for (int i=1;i&lt;n;i++) { a=read();b=read();c=read(); add(a,b,c); add(b,a,c); } k=read(); init(n); getroot(1,0); divide(root); printf(&quot;%d&quot;,ans); return 0; } 以上内容更新于2018.4.26","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-点分治","slug":"算法-点分治","permalink":"https://llf0703.com/tags/算法-点分治/"}]},{"title":"题解-洛谷P4092 [HEOI2016/TJOI2016]树","slug":"luogu-solution-p4092","date":"2018-04-24T12:06:00.000Z","updated":"2018-06-11T12:40:05.352Z","comments":true,"path":"p/luogu-solution-p4092.html","link":"","permalink":"https://llf0703.com/p/luogu-solution-p4092.html","excerpt":"","text":"第一次写树剖没看题解A题，发现题解洛谷题解区大佬里竟然没有一个做法一样的，实在是太激动了 树剖学习：https://llf0703.com/p/shu-lian-pou-fen.html 题目链接: 洛谷 P4092 BZOJ P4551 方法裸树剖，直接用线段树维护每一段区间中被标记的最深的节点就行了。先全部赋值为-1，然后向上传递时直接取两段中的最大值即可（因为越深的点dfs序越大） 还有需要注意的是查询中在链上往上跳时只要找到了有标记的节点就需要输出，否则不是最深的点。 代码#include&lt;bits/stdc++.h&gt; using namespace std; struct Edge{ int next,to; } edge[200005]; struct Tree{ int left,right,deepest; } tree[800005]; int head[200005],size[200005],fa[200005],son[200005],deep[200005],top[200005],id[200005],dfsid[200005]; int cnt=1,n,m,a,b,c,dfsord; char x; inline int read()//快读 { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } inline void add(int u,int v)//加边 { edge[cnt].to=v; edge[cnt].next=head[u]; head[u]=cnt++; } void build(int x,int l,int r)//建树 { tree[x].left=l; tree[x].right=r; tree[x].deepest=-1;//注意要赋值为-1 if (r-l&gt;1) { build(x*2,l,(l+r)/2); build(x*2+1,(l+r)/2,r); } } void change(int x,int l,int r) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) tree[x].deepest=l;//只有一个元素时标记的最深的节点就是它自己 else { int mid=(tree[x].left+tree[x].right)/2; if (l&lt;mid) change(x*2,l,r); if (r&gt;mid) change(x*2+1,l,r); tree[x].deepest=max(tree[x*2].deepest,tree[x*2+1].deepest);//取两段上最深的节点 } } int query(int x,int l,int r) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].deepest; else { int mid=(tree[x].left+tree[x].right)/2,ans=-1;//同样注意初值 if (l&lt;mid) ans=max(ans,query(x*2,l,r)); if (r&gt;mid) ans=max(ans,query(x*2+1,l,r)); return ans; } } void dfs1(int x,int f,int dep) { deep[x]=dep; fa[x]=f; size[x]=1; int mx=-1; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==f) continue; dfs1(y,x,dep+1); size[x]+=size[y]; if (size[y]&gt;mx) { mx=size[y]; son[x]=y; } } } void dfs2(int x,int topf) { top[x]=topf; id[x]=++dfsord; dfsid[dfsord]=x;//因为是输出节点原序号，这里得到dfs序对应的节点序号 if (!son[x]) return; dfs2(son[x],topf); for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to; if (y==fa[x] || y==son[x]) continue; dfs2(y,y); } } inline void uprange(int u) { change(1,id[u],id[u]+1); } inline int qrange(int u,int v) { int ans=-1; while (top[u]!=top[v]) { if (deep[id[u]]&lt;deep[id[v]]) swap(u,v); ans=query(1,id[top[u]],id[u]+1); if (ans!=-1) return dfsid[ans];//只要找到就返回 u=fa[top[u]]; } if (deep[u]&gt;deep[v]) swap(u,v); ans=query(1,id[u],id[v]+1); return dfsid[ans]; } int main() { n=read();m=read(); for (int i=1;i&lt;n;i++) { a=read();b=read(); add(a,b); add(b,a); } dfs1(1,0,1); dfs2(1,1); build(1,1,n+1); change(1,1,2);//注意先将根节点打上标记 for (int i=1;i&lt;=m;i++) { cin&gt;&gt;x; a=read(); if (x==&#39;C&#39;) uprange(a); else printf(&quot;%d\\n&quot;,qrange(a,1)); } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[{"name":"算法-树链剖分","slug":"算法-树链剖分","permalink":"https://llf0703.com/tags/算法-树链剖分/"},{"name":"数据结构-线段树","slug":"数据结构-线段树","permalink":"https://llf0703.com/tags/数据结构-线段树/"},{"name":"OJ-洛谷","slug":"OJ-洛谷","permalink":"https://llf0703.com/tags/OJ-洛谷/"},{"name":"OJ-BZOJ","slug":"OJ-BZOJ","permalink":"https://llf0703.com/tags/OJ-BZOJ/"},{"name":"省选-河北","slug":"省选-河北","permalink":"https://llf0703.com/tags/省选-河北/"},{"name":"省选-天津","slug":"省选-天津","permalink":"https://llf0703.com/tags/省选-天津/"}]},{"title":"二分图匹配","slug":"bipartite-matching","date":"2018-04-21T05:24:00.000Z","updated":"2018-06-11T12:42:54.207Z","comments":true,"path":"p/bipartite-matching.html","link":"","permalink":"https://llf0703.com/p/bipartite-matching.html","excerpt":"","text":"我是看这篇学懂的，真的写得很好，所以我就不在这里总结了，只发个模板 https://blog.csdn.net/dark_scope/article/details/8880547 模板题：洛谷 P3386【模板】二分图匹配 #include&lt;bits/stdc++.h&gt; using namespace std; bool edge[1005][1005]; bool used[1005]; int mch[1005]; int n,m,e,a,b,c,ans; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return x*f; } bool find(int x) { for (int i=1;i&lt;=m;i++) if (!used[i] &amp;&amp; edge[x][i]) { used[i]=true; if (!mch[i] || find(mch[i])) { mch[i]=x; return true; } } return false; } int main() { memset(edge,false,sizeof(edge)); n=read();m=read();e=read(); for (int i=1;i&lt;=e;i++) { int u=read(),v=read(); if (v&gt;m) continue; edge[u][v]=true; } for (int i=1;i&lt;=n;i++) { memset(used,false,sizeof(used)); ans+=find(i); } printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-二分图匹配","slug":"算法-二分图匹配","permalink":"https://llf0703.com/tags/算法-二分图匹配/"}]},{"title":"题解-洛谷P2486 [SDOI2011]染色","slug":"luogu-solution-p2486","date":"2018-04-19T11:50:00.000Z","updated":"2018-06-11T12:46:15.098Z","comments":true,"path":"p/luogu-solution-p2486.html","link":"","permalink":"https://llf0703.com/p/luogu-solution-p2486.html","excerpt":"","text":"题目链接： 洛谷 P2486 BZOJ P2243 方法可以想到，颜色段的个数也是具有可加性的，但是如果两段连接处（即线段树中左子树的最右边的点和右子树的最左端的点）的颜色是相同的话，中间就只能算作一段，需要将颜色段个数-1。 所以我们在线段树里多加两个变量，分别为这一段最左端的点颜色和最右端的颜色，合并时和查询时判断一下即可。 注意的是查询链上时也需要判断。每次查询时记录一下左端点颜色，每一次判断一下当前剖到的右端点与上一次剖到的左端点是否相同即可。又由于有u和v两个节点要不停交换，所以用lastc1和lastc2两个变量来存上一次的左端点颜色，当u和v交换时，lastc1和lastc2也需要对应交换。当u和v在一条链上的时候，两边端点都需要比较。 查询链时代码 int qrange(int u,int v) { int ans=0,lastc1=lastc2=-1; while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) { swap(u,v); swap(lastc1,lastc2);//同时交换 } ans+=query(1,id[top[u]],id[u]+1); if (rcol==lastc1) ans--;//将当前右端点同上一次左端点比较 lastc1=lcol; u=fa[top[u]]; } if (deep[u]&lt;deep[v]) //注意交换顺序，不要弄反 { swap(u,v); swap(lastc1,lastc2); } ans+=query(1,id[v],id[u]+1); if (rcol==lastc1) ans--; if (lcol==lastc2) ans--;//都要比较 return ans; } 其中lcol和rcol在query函数中就顺便获得了 其它的就是标准的树链剖分了。传送门：树链剖分总结 - Llf’s blog 代码 同样，我的线段树是[left,right)形式，调用时要将右边端点+1 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=200005; struct Edge{ int next,to; } edge[MAXN]; struct Tree{ int left,right,leftc,rightc,sum,delta;//leftc和rightc分别是左右端点颜色 } tree[MAXN*4]; int deep[MAXN],top[MAXN],son[MAXN],fa[MAXN],size[MAXN],id[MAXN],w[MAXN],wnew[MAXN],head[MAXN]; int n,m,a,b,c,cnt=1,dfsord,rcol,lcol,lastc1,lastc2; inline int read() { char ch=getchar(); int x=0,f=1; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return x*f; } inline void add(int u,int v) { edge[cnt].to=v; edge[cnt].next=head[u]; head[u]=cnt++; } inline void pushup(int x) { tree[x].sum=tree[x*2].sum+tree[x*2+1].sum; if (tree[x*2].rightc==tree[x*2+1].leftc) tree[x].sum--; tree[x].leftc=tree[x*2].leftc; tree[x].rightc=tree[x*2+1].rightc; } inline void update(int x) { tree[x*2].sum=tree[x*2+1].sum=1; tree[x*2].leftc=tree[x*2].rightc=tree[x*2+1].leftc=tree[x*2+1].rightc=tree[x].delta; tree[x*2].delta=tree[x*2+1].delta=tree[x].delta; tree[x].delta=0; } void build(int x,int l,int r) { tree[x].left=l; tree[x].right=r; tree[x].delta=0; if (r-l==1) { tree[x].leftc=tree[x].rightc=wnew[l]; tree[x].sum=1; } else { build(x*2,l,(l+r)/2); build(x*2+1,(l+r)/2,r); pushup(x); } } void change(int x,int l,int r,int delta) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) { tree[x].sum=1; tree[x].leftc=tree[x].rightc=delta; tree[x].delta=delta; } else { if (tree[x].delta!=0) update(x); if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta); if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta); pushup(x); } } int query(int x,int l,int r) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) { if (l==tree[x].left) lcol=tree[x].leftc; if (r==tree[x].right) rcol=tree[x].rightc; return tree[x].sum; } else { if (tree[x].delta!=0) update(x); int ans=0; if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r); if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r); if (tree[x*2].rightc==tree[x*2+1].leftc &amp;&amp; l&lt;(tree[x].left+tree[x].right)/2 &amp;&amp; r&gt;(tree[x].left+tree[x].right)/2) ans--; return ans; } } void dfs1(int x,int f,int dep) { deep[x]=dep; fa[x]=f; size[x]=1; int mx=-1; for (int i=head[x];i!=-1;i=edge[i].next) { int y=edge[i].to; if (y==f) continue; dfs1(y,x,dep+1); size[x]+=size[y]; if (size[y]&gt;mx) { mx=size[y]; son[x]=y; } } } void dfs2(int x,int topf) { top[x]=topf; id[x]=++dfsord; wnew[dfsord]=w[x]; if (!son[x]) return; dfs2(son[x],topf); for (int i=head[x];i!=-1;i=edge[i].next) { int y=edge[i].to; if (y==fa[x] || y==son[x]) continue; dfs2(y,y); } } void uprange(int u,int v,int delta) { while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); change(1,id[top[u]],id[u]+1,delta); u=fa[top[u]]; } if (deep[u]&gt;deep[v]) swap(u,v); change(1,id[u],id[v]+1,delta); } int qrange(int u,int v) { int ans=0,lastc1=lastc2=-1; while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) { swap(u,v); swap(lastc1,lastc2); } ans+=query(1,id[top[u]],id[u]+1); if (rcol==lastc1) ans--; lastc1=lcol; u=fa[top[u]]; } if (deep[u]&lt;deep[v]) { swap(u,v); swap(lastc1,lastc2); } ans+=query(1,id[v],id[u]+1); if (rcol==lastc1) ans--; if (lcol==lastc2) ans--; return ans; } int main() { memset(head,-1,sizeof(head)); n=read();m=read(); for (int i=1;i&lt;=n;i++) w[i]=read(); for (int i=1;i&lt;n;i++) { a=read();b=read(); add(a,b); add(b,a); } dfs1(1,0,1); dfs2(1,1); build(1,1,n+1); for (int i=1;i&lt;=m;i++) { char x; cin&gt;&gt;x; if (x==&#39;C&#39;) { a=read();b=read();c=read(); uprange(a,b,c); } else { a=read();b=read(); printf(&quot;%d\\n&quot;,qrange(a,b)); } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[{"name":"算法-树链剖分","slug":"算法-树链剖分","permalink":"https://llf0703.com/tags/算法-树链剖分/"},{"name":"数据结构-线段树","slug":"数据结构-线段树","permalink":"https://llf0703.com/tags/数据结构-线段树/"},{"name":"省选-山东","slug":"省选-山东","permalink":"https://llf0703.com/tags/省选-山东/"},{"name":"OJ-洛谷","slug":"OJ-洛谷","permalink":"https://llf0703.com/tags/OJ-洛谷/"},{"name":"OJ-BZOJ","slug":"OJ-BZOJ","permalink":"https://llf0703.com/tags/OJ-BZOJ/"}]},{"title":"树链剖分总结","slug":"shu-lian-pou-fen","date":"2018-04-16T12:41:00.000Z","updated":"2018-11-19T05:46:59.847Z","comments":true,"path":"p/shu-lian-pou-fen.html","link":"","permalink":"https://llf0703.com/p/shu-lian-pou-fen.html","excerpt":"","text":"作为一个上个月刚学完线段树的蒟蒻，看Splay又看不懂，便直接跳着来学树剖了。又在一个博客上看到说学树剖之前最好还要把LCA给学了，便去花了一天学了一个Tarjan求LCA（然而后来发现并不怎么需要），然后是几乎照着别人的代码把树剖抄懂的。在这里我就讲一下我理解的树剖。 准备工作 链表/链式前向星 线段树/树状数组/Splay等可以维护一段数据的数据结构 LCA （其实只涉及到一些思想，而且几乎用不到，可以先不学） 树剖原理我很早之前就听说过树剖，当时觉得实在是太高大上了，但现在发现只是名字比较高端，整个原理还是很简单的，只是码量比较大。 作为蒟蒻，我在图论题中几乎都只会搜索，也靠着搜索在SCOI上拿了仅有的几十分。不过我好歹还是学过前缀和差分的，如果一个图中所有的点连成一条线，那么来找两个点之间路径长只需要维护前缀和就行了。如果一棵树中的结点都连成一条线，我们就把它称作链。如果把树上的结点分为若干条链，那么很多问题就可以变得简单多了。 所谓树链剖分就是将一棵树给剖分成若干条链，再分别处理。 当然，一个节点也是可以算一条链的，不过如果这样分还不如不分。树剖这个算法的目的，便是将一棵树中每一个非叶节点分到链中，并且每一个节点都只属于一条链，这样查询起来又可以快很多。 在这里给出一棵树（图源百度百科）： 在这张图中，粗线即为分成的链。要让每一个非叶节点在链上，我们就需要让一条链尽可能覆盖更多节点。所以在每一个节点的子节点中，我们选以它为根的子树节点个数最多的子节点来连成链。 比如在4号节点的子节点{8,9,10}中，以8和以10为根的子树的节点总个数为1，而以9为根的子树节点个数为3，所以我们就将9作为链上的一个节点继续向下连接。9就被称为是4号节点的重节点，其他的两个节点就被称作轻节点 继续扩展，父节点和重节点间的连线被称作重边，就是粗线；父节点和轻结点的连线被称作轻边，就是图中的细线；多条重边连接起来的路径叫重链，如路径1-&gt;4-&gt;9-&gt;13-&gt;14；多条轻边连接起来的路径叫轻链，如路径1-&gt;2-&gt;5。 通过一个表格将这些定义总结一下 定义 含义 重节点 以它为根的子树节点个数最多的节点 轻节点 所有子节点中不是重节点的节点 重边 父节点和重节点间的连线 轻边 父节点和轻结点的连线 重链 多条重边连接起来的路径 轻链 多条轻边连接起来的路径 实现我们使用两次dfs就能实现剖分，但是只剖分的话是并没有什么卵用的，一般题目中还会涉及到两节点间的权值和，权值最大值等问题。这里以 洛谷P3384【模板】树链剖分 为例。 剖分首先先解释下我使用的变量 变量名 意义 fa[x] x号节点的父亲 son[x] x号节点的重儿子（节点） size[x] 以x号节点为根的子树中节点个数 deep[x] x号节点的深度 top[x] x号节点所在的链顶的节点编号 w[x] x号节点的原权值 wnew[x] dfs序中第x号节点的权值 id[x] x号节点的dfs序 edge[]和head[] 链式前向星数组 tree[] 线段树 先进行第一次dfs，需要完成的任务是 确定这个点的深度 确定父亲节点 确定以这个节点为根的子树中节点个数 确定这个点的重儿子 具体实现方式见代码 void dfs1(int x,int f,int depth) { deep[x]=depth;//深度 fa[x]=f;//父亲节点 size[x]=1;//子树节点个数至少有一个 int mx=-1; for (int i=head[x];i!=-1;i=edge[i].next) { int v=edge[i].to; if (v==f) continue;//不搜索父节点 dfs1(v,x,depth+1); size[x]+=size[v];//节点个数加上子节点的 if (size[v]&gt;mx) //更新重儿子 { mx=size[v]; son[x]=v; } } } 然后是第二次dfs。需要完成的任务是 确定新编号（dfs序） 赋权值到新编号上 确定这个点所在的链的顶端 处理每一条链 还是看代码吧 void dfs2(int x,int topf) { id[x]=++dfsord;//标记每一个节点的dfs序 wnew[dfsord]=w[x];//得到新编号（dfs序） top[x]=topf;//得到这条链的顶端 if (!son[x]) return;//无儿子返回 dfs2(son[x],topf);//先处理重儿子 for (int i=head[x];i!=-1;i=edge[i].next) { int v=edge[i].to; if (v==fa[x] || v==son[x]) continue; dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端 } } 先处理重儿子是为了保证每一条链都是被连续处理的 好了，剖分就结束了，是不是很简单啊 处理问题操作1，2操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z 操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和 在处理u和v号节点之间路径上所有节点时，我们一般先让u和v属于同一条链，然后因为dfs序的特点就可以直接用线段树处理了。 让u和v顶端相同的方法是将u和v中较深的节点往上跳到这条链顶端的上方，跳完一个再交换跳下一个。每次更改或查询只要更改当前跳的节点到它所在链的顶端即可，最后到一条链上了以后直接处理两点之间就行了。 代码如下： 注：我的线段树是左闭右开区间，即表示[left,right)，所以处理时右边要+1 操作1 void uprange(int u,int v,int delta) { delta%=p;//按题意取% while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换为更深的点 change(1,id[top[u]],id[u]+1,delta); u=fa[top[u]];//向上跳 } if (deep[u]&gt;deep[v]) swap(u,v);//交换为更深的点保证u的dfs序在前 change(1,id[u],id[v]+1,delta); } 操作2 int qrange(int u,int v)//求u到v节点的路径中节点之和 { int ans=0; while (top[u]!=top[v])//不停将u向上跳，直到在一条链上 { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点 ans+=query(1,id[top[u]],id[u]+1); ans%=p; u=fa[top[u]];//向上跳 } //已经在一条链上 if (deep[u]&gt;deep[v]) swap(u,v); ans+=query(1,id[u],id[v]+1); ans%=p; return ans; } 操作3，4可以根据dfs序的性质直到，子树区间右端点为id[x]+siz[x]-1，直接处理即可。 代码： 操作3 inline void upson(int u,int delta) { change(1,id[u],id[u]+size[u],delta); } 操作4 inline int qson(int u) { return query(1,id[u],id[u]+size[u]); } 其它细节 在一些没有指定根的问题中其实以任意节点为根都是可以的 根节点开始dfs时可以以0作为它的根，顶端就是它本身 一定要记得先dfs在建树，因为线段树是处理dfs序的 dfs1(root,0,1); dfs2(root,root); build(1,1,n+1); 完整代码#include&lt;bits/stdc++.h&gt; using namespace std; struct Edge{ int next,to; } edge[200005]; int fa[200005],size[200005],deep[200005],w[200005],wnew[200005],head[200005],son[200005],id[200005],top[200005]; struct Tree{ int left,right,sum,delta; } tree[800005]; int cnt=1,ans,n,m,a,b,c,d,p,dfsord,root; inline void add(int u,int v) { edge[cnt].to=v; edge[cnt].next=head[u]; head[u]=cnt++; } void build(int x,int l,int r) { tree[x].left=l; tree[x].right=r; if (r-l==1) tree[x].sum=wnew[l]; else { build(x*2,l,(l+r)/2); build(x*2+1,(l+r)/2,r); tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p; } } inline void update(int x) { tree[x*2].sum+=tree[x].delta*(tree[x*2].right-tree[x*2].left); tree[x*2+1].sum+=tree[x].delta*(tree[x*2+1].right-tree[x*2+1].left); tree[x*2].sum%=p; tree[x*2+1].sum%=p; tree[x*2].delta+=tree[x].delta; tree[x*2+1].delta+=tree[x].delta; tree[x].delta=0; } void change(int x,int l,int r,int delta) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) { tree[x].delta+=delta; tree[x].sum+=delta*(tree[x].right-tree[x].left); tree[x].sum%=p; } else { if (tree[x].delta!=0) update(x); if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta); if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta); tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p; } } int query(int x,int l,int r) { if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].sum%p; else { if (tree[x].delta!=0) update(x); int ans=0; if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r); if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r); return ans%p; } } /* dfs1 标记每个点的深度dep[] 标记每个点的父亲fa[] 标记每个非叶子节点的子树大小(含它自己) 标记每个非叶子节点的重儿子编号son[] */ void dfs1(int x,int f,int depth) { deep[x]=depth; fa[x]=f; size[x]=1; int mx=-1; for (int i=head[x];i!=-1;i=edge[i].next) { int v=edge[i].to; if (v==f) continue;//不搜索父节点 dfs1(v,x,depth+1); size[x]+=size[v]; if (size[v]&gt;mx) //更新重儿子 { mx=size[v]; son[x]=v; } } } /* dfs2 标记每个点的新编号 赋值每个点的初始值到新编号上 处理每个点所在链的顶端 处理每条链 */ void dfs2(int x,int topf) { id[x]=++dfsord;//标记每一个节点的dfs序 wnew[dfsord]=w[x];//得到新编号（dfs序） top[x]=topf;//得到这条链的顶端 if (!son[x]) return;//无儿子返回 dfs2(son[x],topf);//先处理重儿子 for (int i=head[x];i!=-1;i=edge[i].next) { int v=edge[i].to; if (v==fa[x] || v==son[x]) continue; dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端 } } int qrange(int u,int v)//求u到v节点的路径中节点之和 { int ans=0; while (top[u]!=top[v])//不停将u向上跳，直到在一条链上 { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点 ans+=query(1,id[top[u]],id[u]+1); ans%=p; u=fa[top[u]];//向上跳 } //已经在一条链上 if (deep[u]&gt;deep[v]) swap(u,v); ans+=query(1,id[u],id[v]+1); ans%=p; return ans; } void uprange(int u,int v,int delta) { delta%=p; while (top[u]!=top[v]) { if (deep[top[u]]&lt;deep[top[v]]) swap(u,v); change(1,id[top[u]],id[u]+1,delta); u=fa[top[u]]; } if (deep[u]&gt;deep[v]) swap(u,v); change(1,id[u],id[v]+1,delta); } inline int qson(int u) { return query(1,id[u],id[u]+size[u]);//子树区间右端点为id[x]+siz[x]-1 } inline void upson(int u,int delta) { change(1,id[u],id[u]+size[u],delta); } int main() { memset(head,-1,sizeof(head)); scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;root,&amp;p); for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]); for (int i=1;i&lt;n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b); add(b,a); } dfs1(root,0,1); dfs2(root,root); build(1,1,n+1); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;a); if (a==1) { scanf(&quot;%d%d%d&quot;,&amp;b,&amp;c,&amp;d); uprange(b,c,d); } if (a==2) { scanf(&quot;%d%d&quot;,&amp;b,&amp;c); //cout&lt;&lt;wnew[id[b]]&lt;&lt;&quot; &quot;&lt;&lt;wnew[id[c]]&lt;&lt;endl; printf(&quot;%d\\n&quot;,qrange(b,c)); } if (a==3) { scanf(&quot;%d%d&quot;,&amp;b,&amp;c); upson(b,c); } if (a==4) { scanf(&quot;%d&quot;,&amp;b); printf(&quot;%d\\n&quot;,qson(b)); } } return 0; } 相关例题待更新……","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-树链剖分","slug":"算法-树链剖分","permalink":"https://llf0703.com/tags/算法-树链剖分/"}]},{"title":"LCA问题总结","slug":"lca","date":"2018-04-10T13:07:00.000Z","updated":"2018-11-19T05:47:00.057Z","comments":true,"path":"p/lca.html","link":"","permalink":"https://llf0703.com/p/lca.html","excerpt":"","text":"概述最近公共祖先（LCA）问题指的是在一棵树中，求出任意两个点的最近的公共祖先。如在下图中： 2号节点和1号节点的LCA是4,3号和2号的LCA也是4. 求LCA的方法主要有：暴力，倍增，RMQ和Tarjan。 这篇文章以洛谷P3379 【模板】最近公共祖先（LCA）为例。 Tarjan算法Tarjan算法能够通过dfs将树上节点信息和查询的信息一次性解决，但是无法应对存在修改的情况，所以是一种离线算法。 方法 从根节点开始，遍历每一个它的子节点； 一直递归到叶节点，再从叶节点开始将它和它的父节点运用并查集合并； 又从当前遍历到的节点u开始，遍历每一个和它有询问关系的节点。如果另一个节点v被访问过，那么u和v的LCA就是v的先前通过并查集找到的祖先。 细节与实现 注意记录这个节点是否被访问过，防止重复访问。 输入没有指明哪个是父节点哪个是子节点，所以需要进行双向储存，空间也要随之开两倍。 由于需要遍历子节点，我采用链式前向星的方法进行储存；同样，还需要遍历有查询关系的点，查询关系也需要用一个链式前向星。 这道题中，有多组询问，还要求按照询问的顺序输出，所以解决每个答案的顺序是至关重要的。我起先想了很久怎么解决这个问题，后来才想起链式前向星也是有顺序的。但是由于每一次询问都存了两次，所以更新LCA答案时要将相邻的一对询问都更新，输出时也只能输出一次。 要处理相邻两个询问的LCA，将本次查询到的节点i和i^1节点更新即可。因为[i,i^1]∈[k*2,k*2+1],k∈Z，i^1即为i在同组中另一项，反之也成立。举个例子： 0^1=1,1^1=0 [0,1] 2^1=3,3^1=2 [2,3] 代码及注解#include&lt;bits/stdc++.h&gt; using namespace std; struct Edge{ int to,next; } edge[1000005]; struct Edge2{ int to,next,lca; } ask[1000005];//链式前向星储存 bool vis[500005]; int f[500005]; int head[1000005],hask[1000005]; int n,m,a,b,c,cnte,cnta,root; inline void addedge(int u,int v) { edge[cnte].to=v; edge[cnte].next=head[u]; head[u]=cnte++; } inline void addask(int u,int v) { ask[cnta].to=v; ask[cnta].next=hask[u]; hask[u]=cnta++; } int find(int x) { if (f[x]==x) return f[x]; f[x]=find(f[x]); return f[x]; } void merge(int x,int y) { if (find(x)!=find(y)) f[find(x)]=find(y); } void tarjan(int u) { vis[u]=true;//记录已经访问 for (int i=head[u];i!=-1;i=edge[i].next) if (!vis[edge[i].to]) { tarjan(edge[i].to);//继续向下遍历 merge(edge[i].to,u);//合并 } for (int i=hask[u];i!=-1;i=ask[i].next) if (vis[ask[i].to]) ask[i].lca=ask[i^1].lca=find(ask[i].to);//i^1的含义是(0,1),(1,2)这些组的另一项 } int main() { memset(vis,false,sizeof(vis)); memset(head,-1,sizeof(head)); memset(hask,-1,sizeof(hask)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;root); for (int i=1;i&lt;=n;i++) f[i]=i; for (int i=1;i&lt;n;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addedge(a,b); addedge(b,a); } for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); addask(a,b); addask(b,a); } tarjan(root); for (int i=0;i&lt;m*2;i+=2) printf(&quot;%d\\n&quot;,ask[i].lca);//因为加入两次，而相邻两次的lca又相同 return 0; } 未完待续","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"问题-LCA","slug":"问题-LCA","permalink":"https://llf0703.com/tags/问题-LCA/"},{"name":"算法-Tarjan","slug":"算法-Tarjan","permalink":"https://llf0703.com/tags/算法-Tarjan/"}]},{"title":"RMQ问题_ST表总结","slug":"rmq-st","date":"2018-04-09T13:23:00.000Z","updated":"2018-06-11T13:31:02.900Z","comments":true,"path":"p/rmq-st.html","link":"","permalink":"https://llf0703.com/p/rmq-st.html","excerpt":"","text":"RMQ问题RMQ问题是指多次询问一个区间中最小或最大值的问题。但是因为不包括修改，只涉及离线操作，所以线段树或者树状数组显得有一些多余了。而且数列中的元素个数可能非常大，像线段树开四倍空间肯定是要MLE的。这里介绍一种高效的ST表来解决这种问题。 ST表我的理解：ST表运用动态规划和二分的思想来完成。 ST表查询问题包含初始化和查询操作，其中初始化的时间复杂度为O(n*logn)，查询的时间复杂度仅为O(1)。 初始化初始化主要运用动态规划来完成。 我们将原来的数列用a[]储存，同时定义一个二维的f[][]数组，f[i][j]表示从第i个数起连续2^j个数中的最值，即储存[i,i+2^j-1]中的最值。然后我们就可以使用f数组进行动态规划。 起始状态我们知道2^0=1，所以当j=0时，f[i][j]其实储存的就是第i项的值，这就成了我们初始化的依据。初始化可以这么写： for (int i=1;i&lt;=n;i++) f[i][0]=a[i]; 状态转移前面已经说过，这个状态转移的实质就是二分。在这里，我们将[i,i+2^j-1]二分为[i,i+2^(j-1)-1]和[i+2^(j-1),i+2^j-1]。因为每个区间中的项数在j!=0时一定是偶数，所以这样一定能分为两段项数相同的区间。于是我们得到了状态转移方程f[i, j]=max(f[i,j-1], f[i+2^(j-1),j-1])。状态转移可以这么写： for (int j=1;(1 &lt;&lt; j)&lt;=n;j++) for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]); 其中1&lt;&lt;j就是2^j 但是为什么j要写在外层循环呢？ 因为这个状态转移的实质是：先更新所有长度为f[i][0]即1个元素，然后通过2个1个元素的最值，获得所有长度为f[i][1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为f[i][2]即4个元素的最值，以此类推更新所有长度的最值。 而如果是i在外，j在内的话，我们更新的顺序就是f[1][0],f[1][1],f[1][2],f[1][3]表示更新从1开始1个元素，2个元素，4个元素，8个元素的最值，这里f[1][3]=min(min(a[0],a[1],a[2],a[3]),min(a[4],a[5],a[6],a[7]))的值，但是我们根本没有计算min(a[0],a[1],a[2],a[3])和min(a[4],a[5],a[6],a[7])，所以这样的方法肯定是错误的。 所以初始化就这么写： void st(int n) { for (int i=1;i&lt;=n;i++) f[i][0]=a[i]; for (int j=1;(1 &lt;&lt; j)&lt;=n;j++) for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]); } 查询对于查询[l,r]这个区间中的最值，我们也可以将其分为两部分，再分别取两部分的最值来得到整个区间的最值。 我们取一个值k=log2(r-l+1)，并将k作为二分的中点，将[l,r]这个区间分为[l,k]和[r-2^k+1,k]这两段。可以很显然的发现，这两段是有重复的，但是对结果没有任何影响。 查询可以这么写： inline int query(int l,int r) { int k=log2(r-l+1); return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]); } 模板题以洛谷P3865 【模板】ST表为例 #include&lt;bits/stdc++.h&gt; using namespace std; int a[100005]; int f[100005][20]; int n,m,b,c; void st(int n) { for (int i=1;i&lt;=n;i++) f[i][0]=a[i]; for (int j=1;(1 &lt;&lt; j)&lt;=n;j++) for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++) f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]); } inline int query(int l,int r) { int k=log2(r-l+1); return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; st(n); for (int i=1;i&lt;=m;i++) { scanf(&quot;%d%d&quot;,&amp;b,&amp;c); printf(&quot;%d\\n&quot;,query(b,c)); } return 0; } 相关例题待更新。。。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"问题-RMQ","slug":"问题-RMQ","permalink":"https://llf0703.com/tags/问题-RMQ/"},{"name":"数据结构-ST表","slug":"数据结构-ST表","permalink":"https://llf0703.com/tags/数据结构-ST表/"}]},{"title":"题解-洛谷P1309 瑞士轮","slug":"luogu-solution-p1309","date":"2018-02-08T11:19:00.000Z","updated":"2018-06-11T13:21:35.558Z","comments":true,"path":"p/luogu-solution-p1309.html","link":"","permalink":"https://llf0703.com/p/luogu-solution-p1309.html","excerpt":"","text":"原题链接 洛谷博客该题解链接 题目内容题目背景在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。 题目描述2*N 名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K – 1 名和第 2K名、…… 、第2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 输入输出格式输入格式输入文件名为swiss.in 。 输入的第一行是三个正整数N、R 、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。 第二行是2N 个非负整数s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为i 的选手的初始分数。 第三行是2N 个正整数w1 , w2 , …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。 输出格式输出文件名为swiss.out。 输出只有一行，包含一个整数，即R 轮比赛结束后，排名第 Q 的选手的编号。 输入输出样例输入样例2 4 2 7 6 6 7 10 5 20 15 输出样例1 说明样例解释 数据范围对于30% 的数据，1 ≤ N ≤ 100； 对于50% 的数据，1 ≤ N ≤ 10,000 ； 对于100%的数据，1 ≤ N ≤ 100,000，1 ≤ R ≤ 50，1 ≤ Q ≤ 2N，0 ≤ s1, s2, …, s2N≤10^8，1 ≤w1, w2 , …, w2N≤ 10^8。 来源Noip2011普及组第3题。 题解显然，每一轮过后次序都会被打乱，所以都需要重新排序。如果每次从头排序（用快排）则只能得60（同学亲测），所以快排不能解决这个问题。仔细观察发现，不论是得分还是没得分，胜者和败者组成的序列肯定是有序的，那么每次将两个有序的序列组成一个新序列就行了，这便是归并算法可以直接解决的问题了。先把第一次排序后的数据分为胜者败者两组，胜者分数++后合并，如此反复R次即可完成。需要注意的是不要偷懒用队列，否则跟快排暴力得分一样，还是老老实实自己用数组模拟吧。代码及注解如下： #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,a,b,c,d,e,r,q; struct ren{ int s,w,ord; }; ren win[200005],lose[200005]; ren info[200005]; bool com(ren a,ren b) { if (a.s==b.s) return a.ord&lt;b.ord; else return a.s&gt;b.s; } int main() { cin&gt;&gt;n&gt;&gt;r&gt;&gt;q; for (a=1;a&lt;=n*2;a++) cin&gt;&gt;info[a].s; for (a=1;a&lt;=n*2;a++) info[a].ord=a; for (a=1;a&lt;=n*2;a++) cin&gt;&gt;info[a].w; sort(info+1,info+n*2+1,com);//第一次排序可以用快排 for (a=1;a&lt;=r;a++) { for (b=1;b&lt;=n;b++) { if (info[b*2].w&gt;info[b*2-1].w) { info[b*2].s++; win[b]=info[b*2]; lose[b]=info[b*2-1]; } else { info[b*2-1].s++; win[b]=info[b*2-1]; lose[b]=info[b*2]; } }//分成win和lose两组 int e=0; int i=1; int j=1; while (i&lt;=n&amp;&amp;j&lt;=n) { if (win[i].s&gt;lose[j].s) { e++; info[e]=win[i]; i++; } else if (win[i].s&lt;lose[j].s) { e++; info[e]=lose[j]; j++; } else if (win[i].s==lose[j].s)//特别注意要考虑分数相等的情况，把编号小的排在前面 { e++; if (win[i].ord&lt;lose[j].ord) { info[e]=win[i]; i++; } else if (win[i].ord&gt;lose[j].ord) { info[e]=lose[j]; j++; } } } if (i&gt;n) while (j&lt;=n) { e++; info[e]=lose[j]; j++; } if (j&gt;n) while (i&lt;=n) { e++; info[e]=win[i]; i++; } }//将原数组覆盖成比赛后的新数组 cout&lt;&lt;info[q].ord; return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://llf0703.com/categories/题解/"}],"tags":[{"name":"算法-归并排序","slug":"算法-归并排序","permalink":"https://llf0703.com/tags/算法-归并排序/"}]},{"title":"几种排序方法总结","slug":"sort","date":"2018-02-07T14:04:00.000Z","updated":"2018-11-19T05:46:59.847Z","comments":true,"path":"p/sort.html","link":"","permalink":"https://llf0703.com/p/sort.html","excerpt":"","text":"冒泡排序方法第一次将每一个元素和它的后一个元素比较大小，如果不满足顺序则交换，这样即可确定最后一个数的位置。然后再从头开始，可以确定倒数第二个数的位置。循环n次后即可完成排序。因为每一轮排完序后都会确定一个，即“冒”出来一个，故被称作冒泡排序。时间效率：O($n^{2}$) 代码以 洛谷 P1116 车厢重组 为例 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,a,b,c,d,e,ans; int f[10005]; void change(int &amp;a,int &amp;b) { int c; c=a; a=b; b=c; } int main() { cin&gt;&gt;n; for (a=1;a&lt;=n;a++) cin&gt;&gt;f[a]; for (a=1;a&lt;=n;a++) for (b=1;b&lt;=n-a;b++)//因为每次多确定一位，固少循环一次 if (f[b]&gt;f[b+1]) { change(f[b],f[b+1]); ans++; } cout&lt;&lt;ans; return 0; } 桶排序桶排序的原理非常简单，即将需排序的元素作为数组下标，直接输出就行了。时间效率：O(n) 但是需要很多额外空间 归并排序方法运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。时间效率：最好：O(log n) 最坏：O(n*log n) 代码以 洛谷 P1177 【模板】快速排序 为例 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,p,i,j,k; queue &lt;int&gt; q; int f[100005]; void merge_sort(int a,int b)//a是起点，b是终点 { int s; if (a==b) return; s=(a+b)/2; merge_sort(a,s); merge_sort(s+1,b);//递归调用 i=a; j=s+1; while (i&lt;=s&amp;&amp;j&lt;=b) { if (f[i]&gt;f[j]) { q.push(f[j]); j++; } else { q.push(f[i]); i++; } } if (i&gt;s) for (int e=j;e&lt;=b;e++) q.push(f[e]); if (j&gt;b) for (int e=i;e&lt;=s;e++) q.push(f[e]); k=a-1; while (!q.empty()) { k++; f[k]=q.front(); q.pop(); }//归并算法 } int main() { cin&gt;&gt;n; for (int a=1;a&lt;=n;a++) cin&gt;&gt;f[a]; merge_sort(1,n); for (int a=1;a&lt;=n;a++) cout&lt;&lt;f[a]&lt;&lt;&quot; &quot;; return 0; } 快速排序方法 设置两个变量i、j，排序开始的时候：i=0，j=N-1； 以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 从j开始向前搜索，即由后开始向前搜索(j—)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 重复第3、4步，直到i=j，这样以后第i位上的数的前面比这个数小，后面比这个数大，即这个数位置已经确定； 将i前面和i后面的部分递归调用再次排序，直到排完。 代码sort(A,A+N,com)//_huaji","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-排序","slug":"算法-排序","permalink":"https://llf0703.com/tags/算法-排序/"}]},{"title":"拓扑排序","slug":"topological-sort","date":"2018-02-06T12:21:00.000Z","updated":"2018-11-19T05:46:59.901Z","comments":true,"path":"p/topological-sort.html","link":"","permalink":"https://llf0703.com/p/topological-sort.html","excerpt":"","text":"概念拓扑排序是一种可以将有先决条件（即必须将a、b排在前面后再排c，缺一不可）的数据变得有序的一种排序方法。拓扑排序仅可在有向无环图中使用，同时可以判断图中是否有环。因为顺序不同，拓扑排序得到的答案可能不同。 思路因为排序是有先决条件的，所以可以将要有先决条件的个数（在图中即为入度）记录下来，每满足一个就减一，直到个数为0便可以将其放入序列中。 手动实现如果我们有如下的一个有向无环图，我们需要对这个图的顶点进行拓扑排序，过程如下： 首先，我们发现V6和v1是没有前驱的，所以我们就随机选去一个输出，我们先输出V6，删除和V6有关的边，得到如下图结果： 然后，我们继续寻找没有前驱的顶点，发现V1没有前驱，所以输出V1，删除和V1有关的边，得到下图的结果： 然后，我们又发现V4和V3都是没有前驱的，那么我们就随机选取一个顶点输出（具体看你实现的算法和图存储结构），我们输出V4，得到如下图结果： 然后，我们输出没有前驱的顶点V3，得到如下结果： 然后，我们分别输出V5和V2，最后全部顶点输出完成，该图的一个拓扑序列为： v6–&gt;v1—&gt;v4—&gt;v3—&gt;v5—&gt;v2 方法1.用邻接表存储数据，同时对终点的结点的入度加一；2.将没有先决条件便可以排序的点（即初始入度为0的点）先加入队列并输出；3.从队首元素开始扩展，将与队首元素相连的结点的入度减一（等同于擦除这条边），如果该结点入度变为0，则将其入队，作为下一次查找的起点；4.将队首元素出队，当队首元素为空时停止排序。 代码及注解有n个点，m条边的有向无环图，输入n，m，然后每一行输入一条边的信息：起点x，终点y #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,a,b,c,d,e,re; struct map1{ int stat,end; }; map1 tu[100]; int rd[100],chong[100]; queue &lt;int&gt; q; int main() { cin&gt;&gt;n&gt;&gt;m;//n点m边 for (a=1;a&lt;=m;a++) { cin&gt;&gt;tu[a].stat&gt;&gt;tu[a].end; rd[tu[a].end]++; } for (int i=1;i&lt;=n;i++) if (rd[i]==0) q.push(i);//将初始入度为0的结点入队 while (!q.empty()) { cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;; for (int j=1;j&lt;=m;j++) { if (tu[j].stat==q.front())//找以队首元素为起点的边 { rd[tu[j].end]--; if (rd[tu[j].end]==0) { q.push(tu[j].end); } } } q.pop(); } return 0; }","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"算法-拓扑排序","slug":"算法-拓扑排序","permalink":"https://llf0703.com/tags/算法-拓扑排序/"}]},{"title":"最小生成树总结","slug":"minimum-spanning-tree","date":"2018-02-06T12:21:00.000Z","updated":"2018-10-23T13:51:31.228Z","comments":true,"path":"p/minimum-spanning-tree.html","link":"","permalink":"https://llf0703.com/p/minimum-spanning-tree.html","excerpt":"","text":"概念最小生成树即为无向图中结点构成的树中各边权值之和最小的树，可以有多种情况。一般用Kruskal（克鲁斯卡尔）算法或Prim（普里姆）算法求出。 Kruskal算法方法可以将Kruskal算法理解成对边的贪心算法。 1.将路径用邻接表存储，存储的值为起点、终点和权值；2.将邻接表按照权值为关键字排序；3.从最小权值的边开始循环，每连接起两个结点就把它们并到同一个集合（并查集实现），连接之前判断它们是否已经直接或间接相连（是否同一祖先），如没有相连则连上；4.判断能否构成树：如果所以结点的祖先相同则能，反之则不能构成树。 代码及注解示例题目：洛谷 P3366 【模板】最小生成树 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,x,y,z,a,b,c,k,ans; int f[5005]; struct lj{ int qi,zhong,zhi; };//邻接表存储 lj map1[200005]; bool com(lj a,lj b) { return a.zhi&gt;b.zhi; }//以权值为关键字排序 int zx(int a) { if(a==f[a]) return a; else { f[a]=zx(f[a]); return f[a]; } }//并查集查找祖先 int main() { cin&gt;&gt;n&gt;&gt;m; for (a=1;a&lt;=n;a++) f[a]=a; for (a=1;a&lt;=m;a++) { cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; map1[a].qi=x; map1[a].zhong=y; map1[a].zhi=z; } sort(map1,map1+m+1,com);//排序 while (m&gt;0) { x=map1[m].qi; y=map1[m].zhong; if (zx(x)!=zx(y)) //查找祖先以确定是否相连 { f[zx(y)]=zx(x);//连接，统一祖先 ans+=map1[m].zhi;//加上权值 } m--; } for (a=2;a&lt;=n;a++) if (zx(a)!=zx(1)) { cout&lt;&lt;&quot;orz&quot;; return 0; }//判断能否构成树，只有每一个结点祖先和第一个结点祖先相同，则所有结点祖先都相同 cout&lt;&lt;ans; return 0; } upd:2018.10.23 今天来把这个大半年的坑给填了。咕咕咕 Prim算法方法每次找到与当前点连接的点中权值最小且没被查找过的点进行拓展，记录一下当前点是否已经被查找过，如果全部查找完了就结束了。 过程和Dijkstra算法的堆优化写法很像，可以用一个优先队列来维护队列中权值最小的点，然后BFS即可。 代码#include&lt;bits/stdc++.h&gt; #define pr pair&lt;int,int&gt; #define mp make_pair using namespace std; inline int read() { char ch=getchar(); int f=1,x=0; while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;) { if (ch==&#39;-&#39;) f=-1; ch=getchar(); } while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { x=x*10+ch-&#39;0&#39;; ch=getchar(); } return f*x; } struct Edge{ int next,to,w; } edge[400005]; int n,m,a,b,c,cnt,ct,head[5005],ans,mn[5005]; bool vis[5005]; inline void add(int u,int v,int w) { edge[++cnt].to=v; edge[cnt].w=w; edge[cnt].next=head[u]; head[u]=cnt; } inline void prim() { priority_queue &lt;pr,vector&lt;pr&gt;,greater&lt;pr&gt; &gt; q; q.push(mp(0,1)); for (int i=1;i&lt;=n;i++) mn[i]=1e9; mn[1]=0; memset(vis,0,sizeof(vis)); while (!q.empty() &amp;&amp; ct&lt;n) { int x=q.top().second,qf=q.top().first; q.pop(); if (vis[x]) continue; ans+=qf; ct++; vis[x]=1; for (int i=head[x];i;i=edge[i].next) { int y=edge[i].to,w=edge[i].w; if (w&lt;mn[y]) { mn[y]=w; q.push(mp(mn[y],y)); } } } } int main() { n=read(); m=read(); for (int i=1;i&lt;=m;i++) { a=read(); b=read(); c=read(); add(a,b,c); add(b,a,c); } prim(); if (ct==n) printf(&quot;%d&quot;,ans); else printf(&quot;orz&quot;); return 0; } 感觉自己码风变化真大，寒假的时候还是太naive了。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://llf0703.com/categories/OI笔记/"}],"tags":[{"name":"问题-最小生成树","slug":"问题-最小生成树","permalink":"https://llf0703.com/tags/问题-最小生成树/"},{"name":"算法-Kruskal","slug":"算法-Kruskal","permalink":"https://llf0703.com/tags/算法-Kruskal/"},{"name":"算法-Prim","slug":"算法-Prim","permalink":"https://llf0703.com/tags/算法-Prim/"}]},{"title":"NOIp2017爆炸记","slug":"noip2017-summary","date":"2017-12-02T15:11:00.000Z","updated":"2018-10-23T10:43:00.489Z","comments":true,"path":"p/noip2017-summary.html","link":"","permalink":"https://llf0703.com/p/noip2017-summary.html","excerpt":"","text":"Day -N去年只参加PJ，凑巧拿了个一。今年第一次参加TG，还有在徐妈的逼迫下又参加了PJ，还想拿个高分（事实上死的很惨） Day 0就复习了点简单的东西（毕竟考前三天才学会c++的文件，P转C的痛苦），中午大半时间在颓2048，感觉什么都没干 Day 1上午TG。妈的我第一题找了大半个小时都没找出规律就打了个暴力了事；第二题纯种模拟，二十多个变量，样例都过了，当时感觉应该没有问题；第三题直接没时间了，tan90°。中午一对答案发现就是个扩展欧几里得，连高精度都不用，数学没学好很无奈啊。中午和WZX绕着电子渴基大学走了一大圈，回来考PJ。第一题真难没看懂；第二题15分钟不到水完，事实上后来发现endl都没有打，20分；第三题深搜，过了样例，感觉还行；第四题不会，打了个暴力走人，感觉50分的数据应该能过。估分350。 Day 2上午去晚了，连集合都没赶上就冲进了考场，整的还有人来问我“XX学校的Llf同学来了没有”，真的尴尬死了。先看了下题，选第三题分两种情况打了个暴力，期望40；然后第一题深搜（然而却并忘了剪枝而爆炸）；第二题乱搞的DP方程过了样例结果发现是错的。感觉就要炸。 Day N 爆炸实况第二周的星期天就拿到了我的代码。先对PJ，第一题第二题都没测，第三题测出来出了点问题只有20，第四题发现交错程序了（因为我先打了个骗分版本）珂谷数据10分。感觉只有230了。然后测TG Day1第一题测出来50，第二题20；Day2第一题40（然后绝望的发现我没有剪枝）；第二题爆0；第三题只有30。当时很绝望，但是这不是最惨的时候。到了学校测了PJ的一二题，惊讶的发现第二题只有20，然后绝望的发现并没有换行。我还能说些什么……后来出了官方数据，第三题测出来50还是给了我点安慰，170，绝望的分数。然后TG用官方数据更加炸。105……然后一直绝望了一周。平时感觉自己还行，TG不说有一等起码二等也应该有。后来仔细想了一下，对PJ的轻视，对TG的畏惧是主要原因。如果不这样，我也不至于PJ第二题根本不检查，TGD1T1连找规律都不敢。半期也炸掉了，历史最差名次，又被cm姐批了一顿。后悔吗？不！因为 自己选择的路，跪着也要走完","categories":[{"name":"游记","slug":"游记","permalink":"https://llf0703.com/categories/游记/"}],"tags":[{"name":"游记-NOIp","slug":"游记-NOIp","permalink":"https://llf0703.com/tags/游记-NOIp/"}]}]}