<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2018暑假清北学堂济南集训游记及总结</title>
      <link href="/p/qbxt-2018-summer-summary.html"/>
      <url>/p/qbxt-2018-summer-summary.html</url>
      <content type="html"><![CDATA[<p>本来报的成都的班，结果取消了（多半是人不够），cyc，wzx和我就决定去济南，顺便提前去玩几天。<del>颓废的气息</del></p><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><p>早上和cyc坐动车去了曲阜，悲催的wzx因为坐了晚一点的车被困在成都了。晚上和cyc在酒店里颓CSGO和吃鸡，<del>真是充实的一天。</del></p><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>上午去了曲阜的三孔景区。感觉挺壮观的，环境也非常好（到处都是几百年的古树）。话说孔林和孔庙孔府离的好远啊，只有坐车去。从孔府出来就有人说35一个人去孔林，还好没听叫了个uber10块钱就过去了。孔林就只去看了孔子墓，周围绿水青山的，<del>风水极好</del>，听说只有孔姓后人才能埋在孔林，真是有福气。</p><p>中午退房以后就去火车站玩手机玩到4点，然后坐车去济南。晚上10点又去西站接wzx。这里要吐槽下济南城市布局，怎么火车站都在西边而且还这么远？而且第一条地铁也要2019年1月1日开通，真麻烦。</p><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><p>我们三个上午骑车去了大明湖，然后坐在湖边打了一个多小时斗地主（<del>真有意境</del>）。后面大概逛了逛就回去了。</p><p>下午去看了山东<del>情妇院</del>博物馆（其实就是题词上面的“博物馆”看起来像情妇院，很久以前一个梗了）。本以为省博物馆位置肯定会好一些，结果所在的历下区<strong>又乱又差</strong>，到处都在施工，整的他们两个都在怀疑我是不是导航导错路了。而且全程上坡，累的一批，回来想着一直下坡很爽还tm车都找不到。（全济南共享单车都少，在成都我一直都是看到车后打开App扫，在济南我都是打开App找到车后扫，而且车都很旧，摩拜的新款车全都没有）。不过博物馆本身还是很有看头的，看完后对齐鲁大地的历史大概有了了解，<del>虽然我主要都去关注字画去了，里面有一幅隶书是真的好看啊</del>。 </p><h2 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h2><p>起床晚了，他们两个哪都不想去，就颓废了一上午。中午惊喜地发现上课的地方就在我们这，然后搬行李过去报道。三床房没了，cyc就只有和另一个人拼一个房间。下午我们分工写一个局域网联机的斗地主，也没什么结果。</p><h2 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-基础算法总结</a></p><p>上午主要讲的是一些基础算法，像什么搜索、二分、倍增、分治之类的。感觉还好。</p><p>下午考了套题，我才rk25，好菜啊。</p><h2 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-数论总结</a></p><p>上午还是讲的基础算法，无话。</p><p>下午讲数论，终于算是系统地学了一遍数论了，我发现我之前的总结写的好水啊，还有bug。</p><h2 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-数据结构总结</a></p><p>对于这一天的内容，我只想问：为什么课表上那么简单，讲的那么难？</p><h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-动态规划总结</a></p><p>数据结构和动规各讲一天半，下午开始讲动规。从头开始讲，所以还不算太难。</p><h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><p>又是一天dp，我感觉我dp怕是药丸。</p><h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-动态规划总结</a></p><p>图论大多我都学过，但还是想巩固一下，结果大佬们纷纷表示不想听，于是难度就增加了，又听不懂了。我好菜啊！</p><h2 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-字符串总结</a></p><p>字符串我大概都还会，所以基本上就水了一上午。</p><p>下午又是一套%你题。lmj太毒瘤了！第一题找规律，我离线处理得了60分，然后死磕第二题，最后TLE了，然后总分60rk竟然都是18。<del>lmj：这套题暴力都有240啊</del>。</p><h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><p>讲了点往年试题，大家似乎都在水。最后lmj还成功上演了“一步扫雷”。</p><p>下午又去机场打斗地主打到晚上，飞机还延误一个小时。23号0点过终于到了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一趟过去收获还是挺大的，也见识了比我强太多的大佬，感觉自已好菜啊！</p><p>总结还没写完，那些链接都只是在占坑，有时间慢慢补，就酱。</p><hr><p>更新于2018.7.23</p><hr>]]></content>
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>紫书第九章-动态规划初步 刷题总结</title>
      <link href="/p/aoapc-book-9.html"/>
      <url>/p/aoapc-book-9.html</url>
      <content type="html"><![CDATA[<p>很久没写过总结了。紫书做了那么多道题，但是我的动规并没有找到什么感觉，也就只有普及难度的可以不看题解写，剩下的都是看着题解写完的，我还是太弱了。这里还是来总结一下吧。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="9-1-UVa1025-A-Spy-in-the-Metro"><a href="#9-1-UVa1025-A-Spy-in-the-Metro" class="headerlink" title="9-1 UVa1025-A Spy in the Metro"></a>9-1 <a href="https://vjudge.net/problem/UVA-1025" target="_blank" rel="noopener">UVa1025-A Spy in the Metro</a></h3><p>$f[i][j]$表示在车站i，时刻是j，还剩多少时间（根紫书略有不同）</p><p>决策有三个，上左边的车，上右边的车，<del>如果都不开往幼儿园</del>就等一时刻的车。</p><p>注意还要判断某一时刻是否有车，$havel[i][t]$和$haver[i][t]$表示在i车站在t时刻是否有车。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,a,b,c,tright,tleft,Time,cnt;int T[55],tl,tr,f[55][255];//在车站i，时刻j，还剩多少时间bool havel[55][255],haver[55][255];//在车站i，在t时刻是否有车inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int main(){    while (1)    {        memset(havel,false,sizeof(havel));        memset(haver,false,sizeof(haver));        memset(f,0,sizeof(f));        memset(T,0,sizeof(T));        n=read(); if (n==0) break; t=read();        for (int i=1;i&lt;n;i++) T[i]=read();        tright=read();        for (int i=1;i&lt;=tright;i++)        {            tr=read();            Time=tr;            for (int j=1;j&lt;=n;j++) haver[j][Time]=true,Time+=T[j];        }        tleft=read();        for (int i=1;i&lt;=tleft;i++)        {            tl=read();            Time=tl;            for (int j=n;j&gt;=1;j--) havel[j][Time]=true,Time+=T[j-1];        }        for (int i=1;i&lt;=n-1;i++) f[i][t]=2e9;        f[n][t]=0;        for (int j=t-1;j&gt;=0;j--)            for (int i=1;i&lt;=n;i++)            {                f[i][j]=f[i][j+1]+1;                if (i&gt;1 &amp;&amp; havel[i][j] &amp;&amp; j+T[i-1]&lt;=t) f[i][j]=min(f[i][j],f[i-1][j+T[i-1]]);//左                if (i&lt;n &amp;&amp; haver[i][j] &amp;&amp; j+T[i]&lt;=t) f[i][j]=min(f[i][j],f[i+1][j+T[i]]);//右            }        printf(&quot;Case Number %d: &quot;,++cnt);        if (f[1][0]&gt;=2e9) printf(&quot;impossible\n&quot;);        else printf(&quot;%d\n&quot;,f[1][0]);    }    return 0;}</code></pre><h3 id="9-2-UVa437-The-Tower-of-Babylon"><a href="#9-2-UVa437-The-Tower-of-Babylon" class="headerlink" title="9-2 UVa437-The Tower of Babylon"></a>9-2 <a href="https://vjudge.net/problem/UVA-437" target="_blank" rel="noopener">UVa437-The Tower of Babylon</a></h3><p>长和宽都会严格减小，直接记忆化搜索即可。</p><p>用$f[id][h]$表示第id个立方体，第h个数据做高。需要将每个立方体的三维按从小到大排序。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define Ans f[id][h]using namespace std;int n,m,a,b,c,h[4],f[40][4],ans,cnt;bool vis[40][4];struct Edge{    int x,y,z;} edge[35];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int dp(int id,int h){    if (vis[id][h]) return Ans;    vis[id][h]=1;    int E[2],hnow;    if (h==1) E[0]=edge[id].y,E[1]=edge[id].z,hnow=edge[id].x;    if (h==2) E[0]=edge[id].x,E[1]=edge[id].z,hnow=edge[id].y;    if (h==3) E[0]=edge[id].x,E[1]=edge[id].y,hnow=edge[id].z;//判断当前哪两个数据做底面，哪一个是高    for (int i=1;i&lt;=n;i++)    {        if (edge[i].x&lt;E[0] &amp;&amp; edge[i].y&lt;E[1]) Ans=max(Ans,dp(i,3)+hnow);        if (edge[i].x&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,2)+hnow);        if (edge[i].y&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,1)+hnow);    }    return Ans;}int main(){    for (;;)    {        memset(f,0,sizeof(f));        memset(vis,0,sizeof(vis));        ans=0;        n=read();        if (n==0) break;        for (int i=1;i&lt;=n;i++)        {            for (int j=1;j&lt;=3;j++) h[j]=read();            sort(h+1,h+4);            edge[i].x=h[1]; edge[i].y=h[2]; edge[i].z=h[3];            for (int j=1;j&lt;=3;j++) f[i][j]=h[j];        }        for (int i=1;i&lt;=n;i++)            for (int j=1;j&lt;=3;j++) ans=max(ans,dp(i,j));        printf(&quot;Case %d: maximum height = %d\n&quot;,++cnt,ans);    }    return 0;}</code></pre><h3 id="9-3-UVa1347-Tour"><a href="#9-3-UVa1347-Tour" class="headerlink" title="9-3 UVa1347-Tour"></a>9-3 <a href="https://vjudge.net/problem/UVA-1347" target="_blank" rel="noopener">UVa1347-Tour</a></h3><p>将题目的走法改成两个人同时从左边出发，$f[i][j]$表示$1-max(i,j)$全部走过，且两人位置为i和j，还要走多少距离。可以定义i&gt;j，并且只允许走到i+1这个点。</p><p>决策就有两个：走到$f[i+1][j]$和$f[i+1][i]$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;double f[1005][1005];int n,m,a,b,c,x[1005],y[1005];inline double dis(int i,int j){    return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));}int main(){    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(f,0,sizeof(f));        for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);        for (int i=1;i&lt;n-1;i++) f[n-1][i]=dis(n-1,n)+dis(i,n);        for (int i=n-2;i&gt;=2;i--)            for (int j=1;j&lt;i;j++) f[i][j]=min(f[i+1][j]+dis(i,i+1),f[i+1][i]+dis(j,i+1));        cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;f[2][1]+dis(1,2)&lt;&lt;endl;    }    return 0;}</code></pre><p>以上更新于2018.5.26</p><hr><h3 id="9-4-UVa116-单向TSP"><a href="#9-4-UVa116-单向TSP" class="headerlink" title="9-4 UVa116-单向TSP"></a>9-4 <a href="https://vjudge.net/problem/UVA-116" target="_blank" rel="noopener">UVa116-单向TSP</a></h3><p>用$f[i][j]$来记录从起点到$(i,j)$的开销（和紫书上反过来了），注意边界判断就行了。唯一有点难度的就是输出路径，我感觉用的是有点像前向星的方法。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int f[105][105],t[105][105],rd[105][105],newf[105];int n,m;int main(){    while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))    {        for (int i=1;i&lt;=m;i++)            for (int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;t[i][j]);        int ans=1e9, last=0;        for (int i=1;i&lt;=m;i++) f[i][n]=t[i][n];        if (n==1)        {            for (int i=1;i&lt;=m;i++)                if (f[i][1]&lt;ans) ans=f[i][1],last=i;        }        else        {            for (int j=n-1;j&gt;=1;j--)                for (int i=1;i&lt;=m;i++)                {                    int dir[]={i,i+1,i-1};                    if (i==1) dir[2]=m;                    if (i==m) dir[1]=1;                    sort(dir,dir+3);                    f[i][j]=f[dir[0]][j+1]+t[i][j];                    rd[i][j]=dir[0];                    for (int k=1;k&lt;3;k++)                        if (f[dir[k]][j+1]+t[i][j]&lt;f[i][j]) f[i][j]=f[dir[k]][j+1]+t[i][j],rd[i][j]=dir[k];                    if (j==1 &amp;&amp; f[i][j]&lt;ans) ans=f[i][j],last=i;             }        }            printf(&quot;%d&quot;,last);            for (int i=rd[last][1],j=2;j&lt;=n;i=rd[i][j],j++) printf(&quot; %d&quot;,i);            printf(&quot;\n%d\n&quot;,ans);    }    return 0;}</code></pre><h3 id="9-5-UVa12563-劲歌金曲"><a href="#9-5-UVa12563-劲歌金曲" class="headerlink" title="9-5 UVa12563-劲歌金曲"></a>9-5 <a href="https://vjudge.net/problem/UVA-12563" target="_blank" rel="noopener">UVa12563-劲歌金曲</a></h3><p><del>数据范围真的假</del>，直接01背包即可</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,a,b,c,k,kase,sum,ans;int cnt[55][10005],f[55][10005],s[55];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int main(){    k=read();    while (k--)    {        n=read(); t=read();        for (int i=1;i&lt;=n;i++) s[i]=read();        for (int i=1;i&lt;=n;i++)             for (int j=0;j&lt;=t;j++)            {                cnt[i][j]=(i==1) ? 0 : cnt[i-1][j];                f[i][j]=(i==1) ? 0 : f[i-1][j];                if (j&gt;s[i])                {                    if (cnt[i][j]&lt;cnt[i-1][j-s[i]]+1)                     {                        cnt[i][j]=cnt[i-1][j-s[i]]+1;                        f[i][j]=f[i-1][j-s[i]]+s[i];                    }                    else if (cnt[i][j]==cnt[i-1][j-s[i]]+1) f[i][j]=max(f[i][j],f[i-1][j-s[i]]+s[i]);                }            }        printf(&quot;Case %d: %d %d\n&quot;,++kase,cnt[n][t]+1,f[n][t]+678);    }}</code></pre><p>未完待续</p><p>以上内容更新于2018.7.3</p><hr><h3 id="9-6-UVa11400-照明系统设计"><a href="#9-6-UVa11400-照明系统设计" class="headerlink" title="9-6 UVa11400-照明系统设计"></a>9-6 <a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">UVa11400-照明系统设计</a></h3><p>跟书上的思路一样。每种灯泡要么都取，要么都不取。然后用一个类似LIS的动规方法，用$f[i]$表示前i种灯泡的最小开销，$sum[i]$表示前i种灯泡的数量$f[i]=min(f[i],f[j]+(sum[i]-sum[j])*node[i].c+node[i].k)(j&lt;i)$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Node{    int v,k,c,l;} node[1005];int n,m,a,b,sum[1005],f[1005];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline bool cmp(Node a,Node b){    return a.v&lt;b.v;}int main(){    for (;;)    {        n=read();        if (n==0) break;        for (int i=1;i&lt;=n;i++) node[i].v=read(),node[i].k=read(),node[i].c=read(),node[i].l=read();        sort(node+1,node+n+1,cmp);        for (int i=1;i&lt;=n;i++) sum[i]=node[i].l+sum[i-1];        f[0]=0;        for (int i=1;i&lt;=n;i++)        {            int now=0x7fffffff;            for (int j=0;j&lt;i;j++) now=min(now,f[j]+(sum[i]-sum[j])*node[i].c+node[i].k);            f[i]=now;        }        printf(&quot;%d\n&quot;,f[n]);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础数论学习总结</title>
      <link href="/p/number-theory.html"/>
      <url>/p/number-theory.html</url>
      <content type="html"><![CDATA[<p>原本打算先学Splay的，但想到提高组一般不考，而且我其它东西还差的多，就先把基础数论的东西复习一下，并且加深一下难度，<del>还做了n多道水题，虽然主要是之前没过的</del>。</p><hr><h2 id="1-整除"><a href="#1-整除" class="headerlink" title="1.整除"></a>1.整除</h2><p>这里就把整除的性质列一下：</p><ol><li>如果$a \mid b$且$b \mid c$，那么$a \mid c$</li><li>$a \mid b$且$a \mid c$等价于$\forall x,y$，有$a \mid (b \times x + c \times y)$</li><li>设$m\neq 0$,那么$a \mid b $等价于$(m \times a) \mid (m \times b)$</li><li>设$x,y$满足$a \times x+b \times y=1$且$a \mid n,b \mid n$，那么$(a \times b) \mid n$</li><li>若$b=q \times d+c$,那么$d \mid b$的充要条件是$d \mid c$</li></ol><h2 id="2-同余"><a href="#2-同余" class="headerlink" title="2.同余"></a>2.同余</h2><p>同余性质：</p><ol><li>自反性 $a\equiv a(mod m) $</li><li>对称性 若$a\equiv b(mod m)$则$b\equiv a(mod m)$</li><li>传递性 若$a\equiv b(mod m),b\equiv c(mod m)$，则$a\equiv c(mod m)$</li><li>同加性 若$a\equiv b(modm)$，则$a+c\equiv b+c(modm)$</li><li>同乘性(1) 若$a\equiv b(modm)$，则$a\times c\equiv b\times c(modm)$ </li><li>同乘性(2) 若$a\equiv b(modm),c\equiv d(modm)$ ，则$a\times c\equiv b\times d(modm)$</li><li>同幂性 若$a\equiv b(modm)$，则$a^{n}\equiv b^{n} (modm)$</li></ol><h2 id="3-最大公约数-gcd"><a href="#3-最大公约数-gcd" class="headerlink" title="3.最大公约数(gcd)"></a>3.最大公约数(gcd)</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>基础方法，不再赘述</p><pre><code class="lang-cpp">int gcd(int a,int b){    if (b==0) return a;    return gcd(b,a%b);}</code></pre><h3 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h3><p>不断去除因数2来提高gcd的效率</p><pre><code class="lang-cpp">inline int gcd(int x,int y){    int i,j;    if (x==0) return y;    if (y==0) return x;    for (i=0;0==(x&amp;1);i++) x&gt;&gt;=1;//去掉2    for (j=0;0==(y&amp;1);j++) y&gt;&gt;=1;    if (i&gt;j) i=j;    for (;;)    {        if (x&lt;y) x^=y,y^=x,x^=y;        if (0==(x-=y)) return y&lt;&lt;i;//如果x==y gcd==x==y        while (0==(x&amp;1)) x&gt;&gt;=1;    }}</code></pre><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>扩展欧几里得算法用来在已知$(a,b)$，求$(x,y)$，使$a\times x+b\times y=gcd(a,b)$</p><pre><code class="lang-cpp">void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}</code></pre><p>例题：<a href="https://www.luogu.org/problemnew/show/P1516" target="_blank" rel="noopener">洛谷P1516 青蛙的约会</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,a,b,c,x,y,l,X,Y;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline LL exgcd(LL l,LL r,LL &amp;X,LL &amp;Y){    if (r==0)    {        X=1; Y=0;        return l;    }    LL a=exgcd(r,l%r,Y,X);    Y-=l/r*X;    return a;}int main(){    x=read(); y=read(); m=read(); n=read(); l=read();    LL deltav=(m&gt;=n) ? m-n : n-m;    LL deltas=(m&gt;=n) ? y-x : x-y;    LL k=exgcd(deltav,l,X,Y);    if (deltas%k!=0) printf(&quot;Impossible&quot;);    else printf(&quot;%lld&quot;,(X*(deltas/k)%(l/k)+(l/k))%(l/k));    return 0;}</code></pre><h2 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4.逆元"></a>4.逆元</h2><p>若$a\times x\equiv 1(modb)$，就称x是a的逆元。</p><p>可以将这个式子转化为$a\times x+b\times y=1$，然后用扩展欧几里得定理求解。</p><p>当然也有一种线性算法，在需要求连续逆元时是最优的算法。</p><blockquote><p>以下内容来自<a href="https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan" target="_blank" rel="noopener">https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan</a></p></blockquote><hr><p>首先我们有一个, $1^{-1}\equiv 1(\bmod p)$</p><p>然后设 $p=k∗i+r,r&lt;i,1&lt;i&lt;p$ ,再将这个式子放到 $\bmod {p}$ 意义下就会得到：</p><p>$k∗i+r≡0(modp)$</p><p>然后乘上 $i^{-1} , r^{-1}$ 就可以得到:</p><p>$k*r^{-1}+i^{-1}\equiv 0 (\bmod p)$</p><p>$i^{-1}\equiv -k*r^{-1} (\bmod p)$</p><p>$i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} (\bmod p)$</p><hr><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">洛谷P3811 【模板】乘法逆元</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,p,inv[3000005];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);    inv[1]=1;    printf(&quot;%d\n&quot;,inv[1]);    for (int i=2;i&lt;=n;i++)    {        inv[i]=-(p/i)*inv[p%i];        inv[i]=(inv[i]%p+p)%p;        printf(&quot;%d\n&quot;,inv[i]);    }    return 0;}</code></pre><h2 id="5-中国剩余定理"><a href="#5-中国剩余定理" class="headerlink" title="5.中国剩余定理"></a>5.中国剩余定理</h2><p>还是就放一个我看的吧</p><p><a href="https://blog.csdn.net/acdreamers/article/details/8050018" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/8050018</a></p><p>例题：<a href="https://www.luogu.org/problemnew/show/P3868" target="_blank" rel="noopener">洛谷P3868 [TJOI2009]猜数字</a></p><p>可以用裸的中国剩余定理来做，但是要注意必须用快速乘，不然$10^{18}\times 10^{18}$肯定会超范围。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,k;LL A[15],B[15];inline LL read(){    char ch=getchar();    LL f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}inline LL gcd(LL a,LL b){    if (b==0) return a;    return gcd(b,a%b);}inline LL qmul(LL a,LL b,LL mod){    LL ans=0,k=a,f=1;    if (k&lt;0) k=-k,f*=-1;    if (b&lt;0) b=-b,b*=-1;    while (b)    {        if (b&amp;1) ans=(ans+k)%mod;        k=(k+k)%mod;        b&gt;&gt;=1;    }    return ans*f;}inline LL crt(){    LL M=1,ans=0;    for (int i=1;i&lt;=k;i++) M*=B[i];    for (int i=1;i&lt;=k;i++)    {        LL x,y,Mi=M/B[i];        exgcd(Mi,B[i],x,y);        x=(x%B[i]+B[i])%B[i];        ans=(ans+qmul(qmul(Mi,x,M),A[i],M))%M;    }    return (ans&lt;0)?ans+M:ans;}int main(){    k=read();    for (int i=1;i&lt;=k;i++) A[i]=read();    for (int i=1;i&lt;=k;i++) B[i]=read();    for (int i=1;i&lt;=k;i++) A[i]=(A[i]%B[i]+B[i])%B[i];    printf(&quot;%lld&quot;,crt());    return 0;}</code></pre><h2 id="6-素数筛"><a href="#6-素数筛" class="headerlink" title="6.素数筛"></a>6.素数筛</h2><h3 id="普通筛法"><a href="#普通筛法" class="headerlink" title="普通筛法"></a>普通筛法</h3><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    int cnt=1;    ss[0]=ss[1]=false;    for (a=2;a&lt;=sqrt(n);a++)    {        if (ss[a]) zs[cnt++]=a;        for (b=2;b&lt;=n/a;b++) ss[a*b]=false;    }}</code></pre><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>可以很容易的想到，普通筛法中筛了很多重复的数。而线性筛法可以避免重复。主要思路是运用得到了的素数来标记后面的合数。</p><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    ss[0]=ss[1]=false;    for (int i=2;i&lt;=n;i++)    {        if (ss[i]) zs[cnt++]=i;        for (int j=1;j&lt;cnt &amp;&amp; zs[j]*i&lt;=n;j++)         {            ss[zs[j]*i]=false;            if (i%zs[j]==0) break;        }    }}</code></pre><p>以上内容更新于2018.5.9</p><p>线性筛法错误修正于2018.7.28</p><hr>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点分治总结</title>
      <link href="/p/dian-fen-zhi.html"/>
      <url>/p/dian-fen-zhi.html</url>
      <content type="html"><![CDATA[<p>markdown原文: <a href="https://md.llf0703.com/p/dian-fen-zhi.md" target="_blank" rel="noopener">https://md.llf0703.com/p/dian-fen-zhi.md</a></p><p>我自己感觉点分治是一种比较<del>玄学</del>神奇的算法，感觉自己也只是理解了一点皮毛而已。这里就谈谈点分治的实现方法和一些运用。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>点分治其实是将一棵树的点不断分为多棵子树，分别得到子树节点到子树根的距离来进行处理。</p><p>既然要有一个点为根节点，那么应该选取哪一个点呢？</p><p>既然要向下分治，如果把一个原来的叶节点作为分治的根节点，那么遍历每一个点的时间开销是非常大的。然而如果这个点的左右子树都达到最大，那么遍历的时间开销就要少很多。而<strong>子树的重心</strong>就能满足这个性质，所以我们选取<strong>子树的重心</strong>作为分治中心，即分治子树的根。</p><h3 id="1-求重心"><a href="#1-求重心" class="headerlink" title="1.求重心"></a>1.求重心</h3><p>首先我们需要了解重心是什么</p><blockquote><p>树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心，删去重心后，生成的多棵树尽可能平衡。— 百度百科</p></blockquote><p>提取关键词：</p><ol><li><strong>其所有的子树中最大的子树节点数最少</strong></li><li><strong>生成的多棵树尽可能平衡</strong></li></ol><p>第1点告诉我们怎么求重心，只需要记录每一个点的子树大小，然后按着定义做就行了。</p><p>第2点告诉我们选择重心作为分治点的原因，因为多棵树尽可能平衡，就可以使复杂度变得最优秀。</p><p>这个不是重点，直接上代码（感觉和树剖差不多）：</p><blockquote><p>这里可以先不管<code>vis[]</code>，后面会解释<br>sizenow是当前这个子树的大小，后面会讲到<br>mx是当前分治到的最大的子树节点最小值</p></blockquote><pre><code class="lang-cpp">void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)//遍历每一个子节点  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];//加上子节点的子树大小    son[x]=max(son[x],size[y]);//求最大的子树  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)//使最大的子树节点最少  {    mx=son[x];    root=x;//记录分治中心（根节点）  }}</code></pre><h3 id="2-进行分治"><a href="#2-进行分治" class="headerlink" title="2.进行分治"></a>2.进行分治</h3><p>分治其实就是一个递归，不断地将子树进行处理就行了，注意要用<code>vis[]</code>标记已经访问防止重复。先上代码：</p><blockquote><p>solve就是解决问题，每一道题有不同的作用，这里不用管。</p></blockquote><pre><code class="lang-cpp">void divide(int x){  vis[x]=true;//标记已访问  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];//得到当前树的大小，将mx和root初始化    getroot(y,0);//得到子树的分治中心    divide(root);//分治子树  }}</code></pre><p>至于为什么有两次solve，主要是为了去重。原因如下：</p><blockquote><p>以下内容来自<a href="https://blog.csdn.net/qq_39553725/article/details/77542223" target="_blank" rel="noopener">https://blog.csdn.net/qq_39553725/article/details/77542223</a></p></blockquote><hr><p>对于以下这棵树：<br><img src="https://cdn.uniqueue.cn/dian-fen-zhi.png" alt="点分治"><br>显然A点是它的重心。<br>我们假设现在分治到了A点（当前点为A）<br>我们一开始求解贡献时，会有以下路径被处理出来：<br>A—&gt;A<br>A—&gt;B<br>A—&gt;B—&gt;C<br>A—&gt;B—&gt;D<br>A—&gt;E<br>A—&gt;E—&gt;F (按照先序遍历顺序罗列)<br>那么我们在合并答案是会将上述6条路径两两进行合并。<br>这是注意到：<br>合并A—&gt;B—&gt;C 和 A—&gt;B—&gt;D 肯定是不合法的！！<br>因为这并不是一条树上(简单)路径，出现了重边，我们要想办法把这种情况处理掉。<br>处理方法很简单，减去每个子树的单独贡献。<br>例如对于以B为根的子树，就会减去：<br>B—&gt;B<br>B—&gt;C<br>B—&gt;D<br>这三条路径组合的贡献<br>读者可能会有疑问，这与上面的6条路径并不一样啊。<br>我们再回过头来看一看这两句代码：<br>ans = ans + solve(tr,0);<br>ans = ans - solve(v,t[i].len);<br>注意到了吧，solve函数的第二个初始值并不相同。<br>我们在处理子树时，将初始长度设为连接边长，这样做就相当于个子树的每个组合都加上了A—&gt;的路径，从而变得与上面一样。<br>个人认为这是点分治一个极其重要的地方，读者们一定要理解清楚。</p><hr><p>好了，分治就完了。不过和树剖一样，只是剖分完是并没有什么卵用的，还需要具体问题具体分析。</p><h2 id="具体例题"><a href="#具体例题" class="headerlink" title="具体例题"></a>具体例题</h2><h3 id="1-洛谷P3806-【模板】点分治1"><a href="#1-洛谷P3806-【模板】点分治1" class="headerlink" title="1.洛谷P3806 【模板】点分治1"></a>1.洛谷P3806 【模板】点分治1</h3><p>题目链接：<a href="https://www.luogu.org/problemnew/show/P3806" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3806</a></p><p>对于这道题询问的距离为k的点是否存在，我们可以用一种类似桶排序的笨方法，将距离作为数组下标，统计到这个距离就将数组++，最后不为0就存在，反之不存在。</p><p>要得到两点之间的距离，只需要记录两个点分别到根的距离，然后相加即可。</p><p>这里的query函数用作求当前分治到的树中点到根的距离，solve用于相加得到两点间距离并统计。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[20005];int size[20005],son[20005],dis[20005],head[20005];bool vis[20005];int sum[10000005];//存距离是否存在，注意大小和n不一样int n,m,k,a,b,c,ord,cnt=1,mx,root,sizenow;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  dis[++ord]=dist;//得到到根的距离  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w);//查询子节点  }}void solve(int x,int length,bool s) //s=false时要去重{  ord=0;  query(x,0,length);  for (int i=1;i&lt;=ord-1;i++)    for (int j=i+1;j&lt;=ord;j++)    {      if (s==true) sum[dis[i]+dis[j]]++;      else sum[dis[i]+dis[j]]--; //进行统计    }}void divide(int x){  vis[x]=true;  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];    getroot(y,0);    divide(root);  }}int main(){  memset(vis,false,sizeof(vis));  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  root=0;mx=2147483646;sizenow=n;  getroot(1,0);  divide(root);  for (int i=1;i&lt;=m;i++)  {    a=read();    if (sum[a]) printf(&quot;AYE\n&quot;);    else printf(&quot;NAY\n&quot;);  }  return 0;}</code></pre><h3 id="2-国家集训队-聪聪可可"><a href="#2-国家集训队-聪聪可可" class="headerlink" title="2.[国家集训队]聪聪可可"></a>2.[国家集训队]聪聪可可</h3><p>题目链接： </p><ul><li>洛谷 P2634： <a href="https://www.luogu.org/problemnew/show/P2634" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P2634</a> </li><li>BZOJ P2152： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2152" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2152</a></li></ul><p>这里使用一个<code>mod3[3]</code>数组来记录两点间距离%3后的值分别为0,1,2的个数。</p><p>对每个节点求出其子树内的dis，经过该点的路径数即为<code>mod3[1]*mod3[2]*2+mod3[0]^2</code>。</p><p>因为要求答案互质，所以还需要一个求最大公约数的操作。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[40005];int head[40005],size[40005],son[40005],mod3[3];bool vis[40005];int n,m,a,b,c,cnt=1,ord,root,mx,sizenow,ans;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=2147483647;root=0;sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  mod3[dist%3]++;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    query(y,x,dist+edge[i].w);  }}inline int solve(int x,int length){  memset(mod3,0,sizeof(mod3));  query(x,0,length);  return mod3[0]*mod3[0]+mod3[1]*mod3[2]*2;}void divide(int x){  vis[x]=true;  ans+=solve(x,0);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    ans-=solve(y,edge[i].w);    init(size[y]);    getroot(y,0);    divide(root);  }}int gcd(int x,int y)//求最大公约数{  if (y==0) return x;  return gcd(y,x%y);}int main(){  n=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  printf(&quot;%d%c%d&quot;,ans/gcd(ans,n*n),&#39;/&#39;,n*n/gcd(ans,n*n));  return 0;}</code></pre><h3 id="3-IOI2011-Race"><a href="#3-IOI2011-Race" class="headerlink" title="3.[IOI2011]Race"></a>3.[IOI2011]Race</h3><p>题目链接：</p><ul><li>洛谷 P4149：<a href="https://www.luogu.org/problemnew/show/P4149" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4149</a></li><li>BZOJ P2599: <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2599" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2599</a></li></ul><blockquote><p>BZOJ是权限题，若没交钱就用洛谷，或者用离线BZOJ题库（by ruanxingzhi）：<br><a href="https://bzoj.llf0703.com/p/2599.html" target="_blank" rel="noopener">https://bzoj.llf0703.com/p/2599.html</a></p></blockquote><p><del>洛谷上这道题是<a href="https://www.luogu.org/space/show?uid=20438" target="_blank" rel="noopener">@larryzhong</a>大佬提供的，比我小3岁却吊打我，在这里先%%%为敬</del></p><p>因为这道题需要得到边数最小，我们对于距离为i的点建立<code>tmp[i]</code>，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边</p><p>点分治，每次先对每棵子树遍历，求出每个点i到root的距离<code>dis[i]</code>，以及走过的边数<code>d[i]</code>，那么<code>ans=min(ans,tmp[k-dis[i]]+d[i])</code>.</p><p>遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵。最后所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define maxint 1e9using namespace std;struct Edge{  int next,to,w;} edge[400005];bool vis[200005];int size[200005],son[200005],dis[200005],head[400005],esum[200005];//tmp[i]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边//每个点i到root的距离dis[i]，以及走过的边数esum[i]int tmp[1000005];int n,m,k,a,b,c,cnt=1,sizenow,mx,ans,root;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return x*f;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=maxint;  root=0;  sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-son[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist,int edgesum){  dis[x]=dist;  esum[x]=edgesum;  if (dis[x]&lt;=k) ans=min(ans,tmp[k-dis[x]]+esum[x]);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w,edgesum+1);  }}//遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵void update(int x,int f,bool s){  if (dis[x]&lt;=k)    if (s) tmp[dis[x]]=min(tmp[dis[x]],esum[x]);    else tmp[dis[x]]=maxint;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    update(y,x,s);  }}void divide(int x){  vis[x]=true;  tmp[0]=0;//每次进入dfs_solve时tmp[0]=0，因为这个当前的根到自己距离为0，走过了0条边  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    query(y,0,edge[i].w,1);    update(y,0,true);  }  for (int i=head[x];i;i=edge[i].next)//所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）  {    int y=edge[i].to;    if (vis[y]) continue;    update(y,0,false);  }  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    init(size[y]);    getroot(y,0);    divide(root);  }}int main(){  n=read();k=read();  for (int i=1;i&lt;=k;i++) tmp[i]=maxint;  ans=maxint;  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    a++;b++;    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  if (ans==maxint) printf(&quot;-1&quot;);  else printf(&quot;%d&quot;,ans);  return 0;}</code></pre><h3 id="4-洛谷-P4178-Tree"><a href="#4-洛谷-P4178-Tree" class="headerlink" title="4.洛谷 P4178 Tree"></a>4.洛谷 P4178 Tree</h3><p>题目链接： <a href="https://www.luogu.org/problemnew/show/P4178" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4178</a></p><p><del>这道题好像比上面那道还简单一点，我也不知道我为什么先刷的上面那一道</del></p><p>注意的是可以在统计有多少个路径权值&lt;=k时可以进行一次排序，直接枚举两个端点就可以处理了，可以节省时间。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define inf 0xfffffffusing namespace std;struct Edge{    int next,to,w;} edge[80005];bool vis[40005];int dis[40005],size[40005],son[40005],head[40005];int root,mx,sizenow,cnt=1,n,m,a,b,c,ord,k,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void add(int u,int v,int w){    edge[cnt].to=v;    edge[cnt].w=w;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void init(int sizen){    mx=inf; sizenow=sizen; root=0;}void getroot(int x,int f){    size[x]=1;    son[x]=0;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        getroot(y,x);        size[x]+=size[y];        son[x]=max(son[x],size[y]);    }    son[x]=max(son[x],sizenow-size[x]);    if (mx&gt;son[x])    {        mx=son[x];        root=x;    }}void query(int x,int f,int dist){    dis[++ord]=dist;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        query(y,x,dist+edge[i].w);    }}inline int solve(int x,int length){    ord=0;    query(x,0,length);    sort(dis+1,dis+ord+1);    int ans=0,stat=1;    while (stat&lt;ord)    {        if (dis[stat]+dis[ord]&lt;=k)        {            ans+=ord-stat;            stat++;        }        else ord--;    }    return ans;}void divide(int x){    ans+=solve(x,0);    vis[x]=true;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (vis[y]) continue;        ans-=solve(y,edge[i].w);        init(size[y]);        getroot(y,0);        divide(root);    }}int main(){    n=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();c=read();        add(a,b,c);        add(b,a,c);    }    k=read();    init(n);    getroot(1,0);    divide(root);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>以上内容更新于2018.4.26</p><hr>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-点分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P4092 [HEOI2016/TJOI2016]树</title>
      <link href="/p/luogu-solution-p4092.html"/>
      <url>/p/luogu-solution-p4092.html</url>
      <content type="html"><![CDATA[<p><del>第一次写树剖没看题解A题</del>，发现题解洛谷题解区大佬里竟然没有一个做法一样的，实在是太激动了</p><hr><p>树剖学习：<a href="https://llf0703.com/p/shu-lian-pou-fen.html">https://llf0703.com/p/shu-lian-pou-fen.html</a></p><p>题目链接:</p><ol><li><a href="https://www.luogu.org/problemnew/show/P4092" target="_blank" rel="noopener">洛谷 P4092</a>  </li><li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4551" target="_blank" rel="noopener">BZOJ P4551</a></li></ol><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><del>裸树剖</del>，直接用线段树维护每一段区间中<strong>被标记的最深的节点</strong>就行了。先全部赋值为-1，然后向上传递时直接取两段中的最大值即可（因为越深的点dfs序越大）</p><p>还有需要注意的是查询中在链上往上跳时只要找到了有标记的节点就需要输出，否则不是最深的点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to;} edge[200005];struct Tree{  int left,right,deepest;} tree[800005];int head[200005],size[200005],fa[200005],son[200005],deep[200005],top[200005],id[200005],dfsid[200005];int cnt=1,n,m,a,b,c,dfsord;char x;inline int read()//快读{  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v)//加边{  edge[cnt].to=v;  edge[cnt].next=head[u];  head[u]=cnt++;}void build(int x,int l,int r)//建树{  tree[x].left=l;  tree[x].right=r;  tree[x].deepest=-1;//注意要赋值为-1  if (r-l&gt;1)  {    build(x*2,l,(l+r)/2);    build(x*2+1,(l+r)/2,r);  }}void change(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) tree[x].deepest=l;//只有一个元素时标记的最深的节点就是它自己  else  {    int mid=(tree[x].left+tree[x].right)/2;    if (l&lt;mid) change(x*2,l,r);    if (r&gt;mid) change(x*2+1,l,r);    tree[x].deepest=max(tree[x*2].deepest,tree[x*2+1].deepest);//取两段上最深的节点  }}int query(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].deepest;  else  {    int mid=(tree[x].left+tree[x].right)/2,ans=-1;//同样注意初值    if (l&lt;mid) ans=max(ans,query(x*2,l,r));    if (r&gt;mid) ans=max(ans,query(x*2+1,l,r));    return ans;  }}void dfs1(int x,int f,int dep){  deep[x]=dep;  fa[x]=f;  size[x]=1;  int mx=-1;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f) continue;    dfs1(y,x,dep+1);    size[x]+=size[y];    if (size[y]&gt;mx)    {      mx=size[y];      son[x]=y;    }  }}void dfs2(int x,int topf){  top[x]=topf;  id[x]=++dfsord;  dfsid[dfsord]=x;//因为是输出节点原序号，这里得到dfs序对应的节点序号  if (!son[x]) return;  dfs2(son[x],topf);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==fa[x] || y==son[x]) continue;    dfs2(y,y);  }}inline void uprange(int u){  change(1,id[u],id[u]+1);}inline int qrange(int u,int v){  int ans=-1;  while (top[u]!=top[v])  {    if (deep[id[u]]&lt;deep[id[v]]) swap(u,v);    ans=query(1,id[top[u]],id[u]+1);    if (ans!=-1) return dfsid[ans];//只要找到就返回    u=fa[top[u]];  }  if (deep[u]&gt;deep[v]) swap(u,v);  ans=query(1,id[u],id[v]+1);  return dfsid[ans];}int main(){  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();    add(a,b);    add(b,a);  }  dfs1(1,0,1);  dfs2(1,1);  build(1,1,n+1);  change(1,1,2);//注意先将根节点打上标记  for (int i=1;i&lt;=m;i++)  {    cin&gt;&gt;x;    a=read();    if (x==&#39;C&#39;) uprange(a);    else printf(&quot;%d\n&quot;,qrange(a,1));  }  return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
            <tag> 数据结构-线段树 </tag>
            
            <tag> 省选-河北 </tag>
            
            <tag> 省选-天津 </tag>
            
            <tag> OJ-洛谷 </tag>
            
            <tag> OJ-BZOJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分图匹配</title>
      <link href="/p/bipartite-matching.html"/>
      <url>/p/bipartite-matching.html</url>
      <content type="html"><![CDATA[<p>我是看这篇学懂的，真的写得很好，所以我就不在这里总结了，只发个模板</p><p><a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">https://blog.csdn.net/dark_scope/article/details/8880547</a></p><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3386" target="_blank" rel="noopener">洛谷 P3386【模板】二分图匹配</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;bool edge[1005][1005];bool used[1005];int mch[1005];int n,m,e,a,b,c,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)     {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}bool find(int x){    for (int i=1;i&lt;=m;i++)        if (!used[i] &amp;&amp; edge[x][i])        {            used[i]=true;            if (!mch[i] || find(mch[i]))            {                mch[i]=x;                return true;            }        }    return false;}int main(){    memset(edge,false,sizeof(edge));    n=read();m=read();e=read();    for (int i=1;i&lt;=e;i++)    {        int u=read(),v=read();        if (v&gt;m) continue;        edge[u][v]=true;    }    for (int i=1;i&lt;=n;i++)    {        memset(used,false,sizeof(used));        ans+=find(i);    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P2486 [SDOI2011]染色</title>
      <link href="/p/luogu-solution-p2486.html"/>
      <url>/p/luogu-solution-p2486.html</url>
      <content type="html"><![CDATA[<p>题目链接：</p><ul><li><a href="https://www.luogu.org/problemnew/show/P2486" target="_blank" rel="noopener">洛谷 P2486</a></li><li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2243" target="_blank" rel="noopener">BZOJ P2243</a></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>可以想到，颜色段的个数也是具有可加性的，但是如果两段连接处（即线段树中左子树的最右边的点和右子树的最左端的点）的颜色是相同的话，中间就只能算作一段，需要将颜色段个数-1。</p><p>所以我们在线段树里多加两个变量，分别为这一段最左端的点颜色和最右端的颜色，合并时和查询时判断一下即可。</p><p>注意的是查询链上时也需要判断。每次查询时记录一下左端点颜色，每一次判断一下当前剖到的右端点与上一次剖到的左端点是否相同即可。又由于有u和v两个节点要不停交换，所以用<code>lastc1</code>和<code>lastc2</code>两个变量来存上一次的左端点颜色，当u和v交换时，<code>lastc1</code>和<code>lastc2</code>也需要对应交换。当u和v在一条链上的时候，两边端点都需要比较。</p><p>查询链时代码</p><pre><code class="lang-cpp">int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);//同时交换        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;//将当前右端点同上一次左端点比较        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v]) //注意交换顺序，不要弄反    {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;//都要比较    return ans;}</code></pre><blockquote><p>其中lcol和rcol在query函数中就顺便获得了</p></blockquote><p>其它的就是标准的树链剖分了。传送门：<a href="https://llf0703.com/p/shu-lian-pou-fen.html">树链剖分总结 - Llf’s blog</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>同样，我的线段树是[left,right)形式，调用时要将右边端点+1</p></blockquote><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=200005;struct Edge{    int next,to;} edge[MAXN];struct Tree{    int left,right,leftc,rightc,sum,delta;//leftc和rightc分别是左右端点颜色} tree[MAXN*4];int deep[MAXN],top[MAXN],son[MAXN],fa[MAXN],size[MAXN],id[MAXN],w[MAXN],wnew[MAXN],head[MAXN];int n,m,a,b,c,cnt=1,dfsord,rcol,lcol,lastc1,lastc2;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void pushup(int x){    tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;    if (tree[x*2].rightc==tree[x*2+1].leftc) tree[x].sum--;    tree[x].leftc=tree[x*2].leftc;    tree[x].rightc=tree[x*2+1].rightc;}inline void update(int x){    tree[x*2].sum=tree[x*2+1].sum=1;    tree[x*2].leftc=tree[x*2].rightc=tree[x*2+1].leftc=tree[x*2+1].rightc=tree[x].delta;    tree[x*2].delta=tree[x*2+1].delta=tree[x].delta;    tree[x].delta=0;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    tree[x].delta=0;    if (r-l==1)     {        tree[x].leftc=tree[x].rightc=wnew[l];        tree[x].sum=1;    }    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        pushup(x);    }}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)    {        tree[x].sum=1;        tree[x].leftc=tree[x].rightc=delta;        tree[x].delta=delta;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        pushup(x);    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        if (l==tree[x].left) lcol=tree[x].leftc;        if (r==tree[x].right) rcol=tree[x].rightc;        return tree[x].sum;    }    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        if (tree[x*2].rightc==tree[x*2+1].leftc &amp;&amp; l&lt;(tree[x].left+tree[x].right)/2 &amp;&amp; r&gt;(tree[x].left+tree[x].right)/2) ans--;        return ans;    }}void dfs1(int x,int f,int dep){    deep[x]=dep;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==f) continue;        dfs1(y,x,dep+1);        size[x]+=size[y];        if (size[y]&gt;mx)         {            mx=size[y];            son[x]=y;        }    }}void dfs2(int x,int topf){    top[x]=topf;    id[x]=++dfsord;    wnew[dfsord]=w[x];    if (!son[x]) return;    dfs2(son[x],topf);    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==fa[x] || y==son[x]) continue;        dfs2(y,y);    }}void uprange(int u,int v,int delta){    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v])     {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;    return ans;}int main(){    memset(head,-1,sizeof(head));    n=read();m=read();    for (int i=1;i&lt;=n;i++) w[i]=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();        add(a,b);        add(b,a);    }    dfs1(1,0,1);    dfs2(1,1);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        char x;        cin&gt;&gt;x;        if (x==&#39;C&#39;)        {            a=read();b=read();c=read();            uprange(a,b,c);        }        else        {            a=read();b=read();            printf(&quot;%d\n&quot;,qrange(a,b));        }    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
            <tag> 数据结构-线段树 </tag>
            
            <tag> OJ-洛谷 </tag>
            
            <tag> OJ-BZOJ </tag>
            
            <tag> 省选-山东 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树链剖分总结</title>
      <link href="/p/shu-lian-pou-fen.html"/>
      <url>/p/shu-lian-pou-fen.html</url>
      <content type="html"><![CDATA[<p>作为一个上个月刚学完线段树的蒟蒻，看Splay又看不懂，便直接跳着来学树剖了。又在一个博客上看到说学树剖之前最好还要把LCA给学了，便去花了一天学了一个Tarjan求LCA（然而后来发现并不怎么需要），然后是几乎照着别人的代码把树剖抄懂的。在这里我就讲一下我理解的树剖。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>链表/链式前向星</li><li>线段树/树状数组/Splay等可以维护一段数据的数据结构</li><li><a href="https://llf0703.com/p/LCA.html">LCA</a> （其实只涉及到一些思想，而且几乎用不到，可以先不学）</li></ol><h2 id="树剖原理"><a href="#树剖原理" class="headerlink" title="树剖原理"></a>树剖原理</h2><p>我很早之前就听说过树剖，当时觉得实在是太高大上了，但现在发现只是名字比较高端，整个原理还是很简单的，只是码量比较大。</p><p>作为蒟蒻，我在图论题中几乎都只会搜索，也靠着搜索在SCOI上拿了仅有的几十分。不过我好歹还是学过前缀和差分的，如果一个图中所有的点连成一条线，那么来找两个点之间路径长只需要维护前缀和就行了。如果一棵树中的结点都连成一条线，我们就把它称作链。如果把树上的结点分为若干条链，那么很多问题就可以变得简单多了。</p><p>所谓树链剖分就是将一棵树给剖分成若干条链，再分别处理。</p><p>当然，一个节点也是可以算一条链的，不过如果这样分还不如不分。树剖这个算法的目的，便是将一棵树中每一个非叶节点分到链中，并且每一个节点都只属于一条链，这样查询起来又可以快很多。</p><p>在这里给出一棵树（图源百度百科）：</p><p><img src="https://cdn.uniqueue.cn/shupou.jpg" alt="树剖"></p><p>在这张图中，粗线即为分成的链。要让每一个非叶节点在链上，我们就需要让一条链尽可能覆盖更多节点。所以在每一个节点的子节点中，我们选<strong>以它为根的子树节点个数最多</strong>的子节点来连成链。</p><p>比如在4号节点的子节点{8,9,10}中，以8和以10为根的子树的节点总个数为1，而以9为根的子树节点个数为3，所以我们就将9作为链上的一个节点继续向下连接。9就被称为是4号节点的<strong>重节点</strong>，其他的两个节点就被称作<strong>轻节点</strong></p><p>继续扩展，父节点和重节点间的连线被称作<strong>重边</strong>，就是粗线；父节点和轻结点的连线被称作<strong>轻边</strong>，就是图中的细线；多条重边连接起来的路径叫<strong>重链</strong>，如路径1-&gt;4-&gt;9-&gt;13-&gt;14；多条轻边连接起来的路径叫<strong>轻链</strong>，如路径1-&gt;2-&gt;5。</p><p>通过一个表格将这些定义总结一下</p><div class="table-container"><table><thead><tr><th style="text-align:center">定义</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">重节点</td><td style="text-align:center">以它为根的子树节点个数最多的节点</td></tr><tr><td style="text-align:center">轻节点</td><td style="text-align:center">所有子节点中不是重节点的节点</td></tr><tr><td style="text-align:center">重边</td><td style="text-align:center">父节点和重节点间的连线</td></tr><tr><td style="text-align:center">轻边</td><td style="text-align:center">父节点和轻结点的连线</td></tr><tr><td style="text-align:center">重链</td><td style="text-align:center">多条重边连接起来的路径</td></tr><tr><td style="text-align:center">轻链</td><td style="text-align:center">多条轻边连接起来的路径</td></tr></tbody></table></div><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们使用两次dfs就能实现剖分，但是只剖分的话是并没有什么卵用的，一般题目中还会涉及到两节点间的权值和，权值最大值等问题。这里以 <a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">洛谷P3384【模板】树链剖分</a> 为例。</p><h3 id="剖分"><a href="#剖分" class="headerlink" title="剖分"></a>剖分</h3><p>首先先解释下我使用的变量</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">fa[x]</td><td style="text-align:center">x号节点的父亲</td></tr><tr><td style="text-align:center">son[x]</td><td style="text-align:center">x号节点的重儿子（节点）</td></tr><tr><td style="text-align:center">size[x]</td><td style="text-align:center">以x号节点为根的子树中节点个数</td></tr><tr><td style="text-align:center">deep[x]</td><td style="text-align:center">x号节点的深度</td></tr><tr><td style="text-align:center">top[x]</td><td style="text-align:center">x号节点所在的链顶的节点编号</td></tr><tr><td style="text-align:center">w[x]</td><td style="text-align:center">x号节点的原权值</td></tr><tr><td style="text-align:center">wnew[x]</td><td style="text-align:center">dfs序中第x号节点的权值</td></tr><tr><td style="text-align:center">id[x]</td><td style="text-align:center">x号节点的dfs序</td></tr><tr><td style="text-align:center">edge[]和head[]</td><td style="text-align:center">链式前向星数组</td></tr><tr><td style="text-align:center">tree[]</td><td style="text-align:center">线段树</td></tr></tbody></table></div><p>先进行第一次dfs，需要完成的任务是</p><ol><li>确定这个点的深度</li><li>确定父亲节点</li><li>确定以这个节点为根的子树中节点个数</li><li>确定这个点的重儿子</li></ol><p>具体实现方式见代码</p><pre><code class="lang-cpp">void dfs1(int x,int f,int depth){    deep[x]=depth;//深度    fa[x]=f;//父亲节点    size[x]=1;//子树节点个数至少有一个    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];//节点个数加上子节点的        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}</code></pre><p>然后是第二次dfs。需要完成的任务是</p><ol><li>确定新编号（dfs序）</li><li>赋权值到新编号上</li><li>确定这个点所在的链的顶端</li><li>处理每一条链</li></ol><p>还是看代码吧</p><pre><code class="lang-cpp">void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}</code></pre><blockquote><p>先处理重儿子是为了保证每一条链都是被连续处理的</p></blockquote><p>好了，剖分就结束了，<span style="text-decoration:line-through;">是不是很简单啊</span></p><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><h4 id="操作1，2"><a href="#操作1，2" class="headerlink" title="操作1，2"></a>操作1，2</h4><p>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</p><p>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</p><p>在处理u和v号节点之间路径上所有节点时，我们一般先让u和v属于同一条链，然后因为dfs序的特点就可以直接用线段树处理了。</p><p>让u和v顶端相同的方法是将u和v中较深的节点往上跳到这条链顶端的上方，跳完一个再交换跳下一个。每次更改或查询只要更改当前跳的节点到它所在链的顶端即可，最后到一条链上了以后直接处理两点之间就行了。</p><p>代码如下：</p><blockquote><p>注：我的线段树是左闭右开区间，即表示[left,right)，所以处理时右边要+1</p></blockquote><p>操作1</p><pre><code class="lang-cpp">void uprange(int u,int v,int delta){    delta%=p;//按题意取%    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换为更深的点        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];//向上跳    }    if (deep[u]&gt;deep[v]) swap(u,v);//交换为更深的点保证u的dfs序在前    change(1,id[u],id[v]+1,delta);}</code></pre><p>操作2</p><pre><code class="lang-cpp">int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}</code></pre><h4 id="操作3，4"><a href="#操作3，4" class="headerlink" title="操作3，4"></a>操作3，4</h4><p>可以根据dfs序的性质直到，子树区间右端点为id[x]+siz[x]-1，直接处理即可。</p><p>代码：</p><p>操作3</p><pre><code class="lang-cpp">inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}</code></pre><p>操作4</p><pre><code class="lang-cpp">inline int qson(int u){    return query(1,id[u],id[u]+size[u]);}</code></pre><h3 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h3><ol><li>在一些没有指定根的问题中其实以任意节点为根都是可以的</li><li>根节点开始dfs时可以以0作为它的根，顶端就是它本身</li><li>一定要记得<strong>先dfs在建树</strong>，因为线段树是处理dfs序的</li></ol><pre><code class="lang-cpp">dfs1(root,0,1);dfs2(root,root);build(1,1,n+1);</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int next,to;} edge[200005];int fa[200005],size[200005],deep[200005],w[200005],wnew[200005],head[200005],son[200005],id[200005],top[200005];struct Tree{    int left,right,sum,delta;} tree[800005];int cnt=1,ans,n,m,a,b,c,d,p,dfsord,root;inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    if (r-l==1) tree[x].sum=wnew[l];    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}inline void update(int x){    tree[x*2].sum+=tree[x].delta*(tree[x*2].right-tree[x*2].left);    tree[x*2+1].sum+=tree[x].delta*(tree[x*2+1].right-tree[x*2+1].left);    tree[x*2].sum%=p;    tree[x*2+1].sum%=p;    tree[x*2].delta+=tree[x].delta;    tree[x*2+1].delta+=tree[x].delta;    tree[x].delta=0;}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        tree[x].delta+=delta;        tree[x].sum+=delta*(tree[x].right-tree[x].left);        tree[x].sum%=p;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].sum%p;    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        return ans%p;    }}               /*  dfs1    标记每个点的深度dep[]       标记每个点的父亲fa[]    标记每个非叶子节点的子树大小(含它自己)        标记每个非叶子节点的重儿子编号son[]*/void dfs1(int x,int f,int depth){    deep[x]=depth;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}/*  dfs2    标记每个点的新编号    赋值每个点的初始值到新编号上    处理每个点所在链的顶端    处理每条链*/void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}void uprange(int u,int v,int delta){    delta%=p;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}inline int qson(int u){    return query(1,id[u],id[u]+size[u]);//子树区间右端点为id[x]+siz[x]-1 }inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}int main(){    memset(head,-1,sizeof(head));    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;root,&amp;p);    for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);        add(b,a);    }    dfs1(root,0,1);    dfs2(root,root);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d&quot;,&amp;a);        if (a==1)        {            scanf(&quot;%d%d%d&quot;,&amp;b,&amp;c,&amp;d);            uprange(b,c,d);        }        if (a==2)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            //cout&lt;&lt;wnew[id[b]]&lt;&lt;&quot; &quot;&lt;&lt;wnew[id[c]]&lt;&lt;endl;            printf(&quot;%d\n&quot;,qrange(b,c));        }        if (a==3)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            upson(b,c);        }        if (a==4)        {            scanf(&quot;%d&quot;,&amp;b);            printf(&quot;%d\n&quot;,qson(b));        }    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新……</p>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LCA问题总结</title>
      <link href="/p/lca.html"/>
      <url>/p/lca.html</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近公共祖先（LCA）问题指的是在一棵树中，求出任意两个点的最近的公共祖先。如在下图中：</p><p><img src="https://cdn.uniqueue.cn/lca.png" alt="LCA"></p><p>2号节点和1号节点的LCA是4,3号和2号的LCA也是4.</p><p>求LCA的方法主要有：暴力，倍增，RMQ和Tarjan。</p><p>这篇文章以<a href="https://www.luogu.org/problemnew/show/P3379" target="_blank" rel="noopener">洛谷P3379 【模板】最近公共祖先（LCA）</a>为例。</p><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><p>Tarjan算法能够通过dfs将树上节点信息和查询的信息一次性解决，但是无法应对存在修改的情况，所以是一种离线算法。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>从根节点开始，遍历每一个它的子节点；</li><li>一直递归到叶节点，再从叶节点开始将它和它的父节点运用并查集合并；</li><li>又从当前遍历到的节点u开始，遍历每一个和它有询问关系的节点。如果另一个节点v被访问过，那么u和v的LCA就是v的先前通过并查集找到的祖先。</li></ol><h3 id="细节与实现"><a href="#细节与实现" class="headerlink" title="细节与实现"></a>细节与实现</h3><ol><li>注意记录这个节点是否被访问过，防止重复访问。</li><li>输入没有指明哪个是父节点哪个是子节点，所以需要进行双向储存，空间也要随之开两倍。</li><li>由于需要遍历子节点，我采用链式前向星的方法进行储存；同样，还需要遍历有查询关系的点，查询关系也需要用一个链式前向星。</li><li>这道题中，有多组询问，还要求按照询问的顺序输出，所以解决每个答案的顺序是至关重要的。我起先想了很久怎么解决这个问题，后来才想起链式前向星也是有顺序的。但是由于每一次询问都存了两次，所以更新LCA答案时要将相邻的一对询问都更新，输出时也只能输出一次。</li><li>要处理相邻两个询问的LCA，将本次查询到的节点i和i^1节点更新即可。因为<code>[i,i^1]∈[k*2,k*2+1],k∈Z</code>，i^1即为i在同组中另一项，反之也成立。举个例子：</li></ol><pre><code>0^1=1,1^1=0 [0,1]2^1=3,3^1=2 [2,3]</code></pre><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int to,next;} edge[1000005];struct Edge2{    int to,next,lca;} ask[1000005];//链式前向星储存bool vis[500005];int f[500005];int head[1000005],hask[1000005];int n,m,a,b,c,cnte,cnta,root;inline void addedge(int u,int v){    edge[cnte].to=v;    edge[cnte].next=head[u];    head[u]=cnte++;}inline void addask(int u,int v){    ask[cnta].to=v;    ask[cnta].next=hask[u];    hask[u]=cnta++;}int find(int x){    if (f[x]==x) return f[x];    f[x]=find(f[x]);    return f[x];}void merge(int x,int y){    if (find(x)!=find(y)) f[find(x)]=find(y);}void tarjan(int u){    vis[u]=true;//记录已经访问    for (int i=head[u];i!=-1;i=edge[i].next)     if (!vis[edge[i].to])    {        tarjan(edge[i].to);//继续向下遍历        merge(edge[i].to,u);//合并    }    for (int i=hask[u];i!=-1;i=ask[i].next)    if (vis[ask[i].to]) ask[i].lca=ask[i^1].lca=find(ask[i].to);//i^1的含义是(0,1),(1,2)这些组的另一项}int main(){    memset(vis,false,sizeof(vis));    memset(head,-1,sizeof(head));    memset(hask,-1,sizeof(hask));    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;root);    for (int i=1;i&lt;=n;i++) f[i]=i;    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addedge(a,b);        addedge(b,a);    }    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addask(a,b);        addask(b,a);    }    tarjan(root);    for (int i=0;i&lt;m*2;i+=2) printf(&quot;%d\n&quot;,ask[i].lca);//因为加入两次，而相邻两次的lca又相同    return 0;}</code></pre><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-LCA </tag>
            
            <tag> 算法-Tarjan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RMQ问题_ST表总结</title>
      <link href="/p/rmq-st.html"/>
      <url>/p/rmq-st.html</url>
      <content type="html"><![CDATA[<h2 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h2><p>RMQ问题是指多次询问一个区间中最小或最大值的问题。但是因为不包括修改，只涉及离线操作，所以线段树或者树状数组显得有一些多余了。而且数列中的元素个数可能非常大，像线段树开四倍空间肯定是要MLE的。这里介绍一种高效的ST表来解决这种问题。</p><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>我的理解：ST表运用<strong>动态规划和二分</strong>的思想来完成。</p><p>ST表查询问题包含初始化和查询操作，其中初始化的时间复杂度为<code>O(n*logn)</code>，查询的时间复杂度仅为<code>O(1)</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要运用动态规划来完成。</p><p>我们将原来的数列用a[]储存，同时定义一个二维的<code>f[][]</code>数组，<code>f[i][j]</code>表示从第i个数起连续2^j个数中的最值，即储存<code>[i,i+2^j-1]</code>中的最值。然后我们就可以使用f数组进行动态规划。</p><h4 id="起始状态"><a href="#起始状态" class="headerlink" title="起始状态"></a>起始状态</h4><p>我们知道<code>2^0=1</code>，所以当j=0时，<code>f[i][j]</code>其实储存的就是第i项的值，这就成了我们初始化的依据。初始化可以这么写：</p><pre><code class="lang-cpp">for (int i=1;i&lt;=n;i++) f[i][0]=a[i];</code></pre><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>前面已经说过，这个状态转移的实质就是二分。在这里，我们将<code>[i,i+2^j-1]</code>二分为<code>[i,i+2^(j-1)-1]</code>和<code>[i+2^(j-1),i+2^j-1]</code>。因为每个区间中的项数在j!=0时一定是偶数，所以这样一定能分为两段项数相同的区间。于是我们得到了状态转移方程<code>f[i, j]=max(f[i,j-1], f[i+2^(j-1),j-1])</code>。状态转移可以这么写：</p><pre><code class="lang-cpp">for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);</code></pre><blockquote><p>其中1&lt;&lt;j就是2^j</p></blockquote><p>但是为什么j要写在外层循环呢？</p><p>因为这个状态转移的实质是：先更新所有长度为<code>f[i][0]</code>即1个元素，然后通过2个1个元素的最值，获得所有长度为<code>f[i][1]</code>即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为<code>f[i][2]</code>即4个元素的最值，以此类推更新所有长度的最值。</p><p>而如果是i在外，j在内的话，我们更新的顺序就是<code>f[1][0],f[1][1],f[1][2],f[1][3]</code>表示更新从1开始1个元素，2个元素，4个元素，8个元素的最值，这里<code>f[1][3]=min(min(a[0],a[1],a[2],a[3]),min(a[4],a[5],a[6],a[7]))</code>的值，但是我们根本没有计算<code>min(a[0],a[1],a[2],a[3])</code>和<code>min(a[4],a[5],a[6],a[7])</code>，所以这样的方法肯定是错误的。</p><p>所以初始化就这么写：</p><pre><code class="lang-cpp">void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于查询<code>[l,r]</code>这个区间中的最值，我们也可以将其分为两部分，再分别取两部分的最值来得到整个区间的最值。</p><p>我们取一个值<code>k=log2(r-l+1)</code>，并将k作为二分的中点，将<code>[l,r]</code>这个区间分为<code>[l,k]</code>和<code>[r-2^k+1,k]</code>这两段。可以很显然的发现，这两段是有重复的，但是对结果没有任何影响。</p><p>查询可以这么写：</p><pre><code class="lang-cpp">inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}</code></pre><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>以<a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865 【模板】ST表</a>为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int f[100005][20];int n,m,b,c;void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    st(n);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;b,&amp;c);        printf(&quot;%d\n&quot;,query(b,c));    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新。。。</p>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-RMQ </tag>
            
            <tag> 数据结构-ST表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P1309 瑞士轮</title>
      <link href="/p/luogu-solution-p1309.html"/>
      <url>/p/luogu-solution-p1309.html</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1309" target="_blank" rel="noopener">原题链接</a> <a href="https://www.luogu.org/blog/llf/solution-p1309" target="_blank" rel="noopener">洛谷博客该题解链接</a></p><hr><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。</p><p>本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>2*N 名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。</p><p>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K – 1 名和第 2K名、…… 、第2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。</p><p>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件名为swiss.in 。</p><p>输入的第一行是三个正整数N、R 、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。</p><p>第二行是2<em>N 个非负整数s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为i 的选手的初始分数。 第三行是2</em>N 个正整数w1 , w2 , …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件名为swiss.out。</p><p>输出只有一行，包含一个整数，即R 轮比赛结束后，排名第 Q 的选手的编号。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>2 4 2 7 6 6 7 10 5 20 15</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>1</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p><img src="https://cdn.luogu.org/upload/pic/98.png" alt="1309样例解释"></p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于30% 的数据，1 ≤ N ≤ 100；</p><p>对于50% 的数据，1 ≤ N ≤ 10,000 ；</p><p>对于100%的数据，1 ≤ N ≤ 100,000，1 ≤ R ≤ 50，1 ≤ Q ≤ 2N，0 ≤ s1, s2, …, s2N≤10^8，1 ≤w1, w2 , …, w2N≤ 10^8。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>Noip2011普及组第3题。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，每一轮过后次序都会被打乱，所以都需要重新排序。如果每次从头排序（用快排）则只能得60（同学亲测），所以快排不能解决这个问题。<br>仔细观察发现，不论是得分还是没得分，胜者和败者组成的序列肯定是有序的，那么每次将两个有序的序列组成一个新序列就行了，这便是归并算法可以直接解决的问题了。<br>先把第一次排序后的数据分为胜者败者两组，胜者分数++后合并，如此反复R次即可完成。<br>需要注意的是<strong>不要偷懒用队列</strong>，否则跟快排暴力得分一样，还是老老实实自己用数组模拟吧。<br>代码及注解如下：</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,r,q;struct ren{    int s,w,ord;};ren win[200005],lose[200005];ren info[200005];bool com(ren a,ren b){    if (a.s==b.s) return a.ord&lt;b.ord;    else return a.s&gt;b.s;}int main(){    cin&gt;&gt;n&gt;&gt;r&gt;&gt;q;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].s;    for (a=1;a&lt;=n*2;a++)    info[a].ord=a;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].w;    sort(info+1,info+n*2+1,com);//第一次排序可以用快排    for (a=1;a&lt;=r;a++)    {        for (b=1;b&lt;=n;b++)        {            if (info[b*2].w&gt;info[b*2-1].w)            {                info[b*2].s++;                win[b]=info[b*2];                lose[b]=info[b*2-1];            }            else            {                info[b*2-1].s++;                win[b]=info[b*2-1];                lose[b]=info[b*2];            }        }//分成win和lose两组        int e=0;        int i=1;        int j=1;        while (i&lt;=n&amp;&amp;j&lt;=n)        {            if (win[i].s&gt;lose[j].s)            {                e++;                info[e]=win[i];                i++;            }            else if (win[i].s&lt;lose[j].s)            {                e++;                info[e]=lose[j];                j++;            }            else if (win[i].s==lose[j].s)//特别注意要考虑分数相等的情况，把编号小的排在前面            {                e++;                if (win[i].ord&lt;lose[j].ord)                {                    info[e]=win[i];                    i++;                }                else if (win[i].ord&gt;lose[j].ord)                {                    info[e]=lose[j];                    j++;                }            }        }        if (i&gt;n)        while (j&lt;=n)        {            e++;            info[e]=lose[j];            j++;        }        if (j&gt;n)        while (i&lt;=n)        {            e++;            info[e]=win[i];            i++;        }    }//将原数组覆盖成比赛后的新数组    cout&lt;&lt;info[q].ord;    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-归并排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种排序方法总结</title>
      <link href="/p/sort.html"/>
      <url>/p/sort.html</url>
      <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>第一次将每一个元素和它的后一个元素比较大小，如果不满足顺序则交换，这样即可确定最后一个数的位置。然后再从头开始，可以确定倒数第二个数的位置。循环n次后即可完成排序。因为每一轮排完序后都会确定一个，即“冒”出来一个，故被称作冒泡排序。<br><img src="https://cdn.uniqueue.cn/paixu1.jpg" alt="paixu1"><br>时间效率：O($n^{2}$)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>以  <a href="https://www.luogu.org/problemnew/show/P1116" target="_blank" rel="noopener">洛谷 P1116 车厢重组</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,ans;int f[10005];void change(int &amp;a,int &amp;b){    int c;    c=a;    a=b;    b=c;}int main(){    cin&gt;&gt;n;    for (a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    for (a=1;a&lt;=n;a++)      for (b=1;b&lt;=n-a;b++)//因为每次多确定一位，固少循环一次      if (f[b]&gt;f[b+1])      {          change(f[b],f[b+1]);          ans++;      }    cout&lt;&lt;ans;    return 0;}</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的原理非常简单，即将需排序的元素作为数组下标，直接输出就行了。<br><img src="https://cdn.uniqueue.cn/paixu2.jpg/" alt="paixu2"><br>时间效率：<code>O(n)</code> 但是需要很多额外空间</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。<br><img src="https://cdn.uniqueue.cn/paixu3.jpg/" alt="paixu3"><br><img src="https://cdn.uniqueue.cn/paixu4.jpg/" alt="paixu4"><br><img src="https://cdn.uniqueue.cn/paixu5.jpg/" alt="paixu5"><br>时间效率：最好：<code>O(log n)</code> 最坏：<code>O(n*log n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>以 <a href="https://www.luogu.org/problemnew/show/P1177" target="_blank" rel="noopener">洛谷 P1177 【模板】快速排序</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,p,i,j,k;queue &lt;int&gt; q;int f[100005];void merge_sort(int a,int b)//a是起点，b是终点{    int s;    if (a==b) return;    s=(a+b)/2;    merge_sort(a,s);    merge_sort(s+1,b);//递归调用    i=a;    j=s+1;    while (i&lt;=s&amp;&amp;j&lt;=b)    {        if (f[i]&gt;f[j])         {            q.push(f[j]);            j++;        }        else        {            q.push(f[i]);            i++;        }    }    if (i&gt;s)     for (int e=j;e&lt;=b;e++) q.push(f[e]);    if (j&gt;b)    for (int e=i;e&lt;=s;e++) q.push(f[e]);    k=a-1;    while (!q.empty())    {        k++;        f[k]=q.front();        q.pop();    }//归并算法}int main(){    cin&gt;&gt;n;    for (int a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    merge_sort(1,n);    for (int a=1;a&lt;=n;a++)    cout&lt;&lt;f[a]&lt;&lt;&quot; &quot;;    return 0;}</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>以第一个数组元素作为关键数据，赋值给key，即<code>key=A[0]</code>；</li><li>从j开始向前搜索，即由后开始向前搜索(j—)，找到第一个小于key的值<code>A[j]</code>，将<code>A[j]</code>和<code>A[i]</code>互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的<code>A[i]</code>，将<code>A[i]</code>和<code>A[j]</code>互换；</li><li>重复第3、4步，直到i=j，这样以后第i位上的数的前面比这个数小，后面比这个数大，即这个数位置已经确定；</li><li>将i前面和i后面的部分递归调用再次排序，直到排完。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">sort(A,A+N,com)//_huaji</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑排序</title>
      <link href="/p/topological-sort.html"/>
      <url>/p/topological-sort.html</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>拓扑排序是一种可以将有先决条件（即必须将a、b排在前面后再排c，缺一不可）的数据变得有序的一种排序方法。拓扑排序仅可在有向无环图中使用，同时可以判断图中是否有环。因为顺序不同，拓扑排序得到的答案可能不同。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为排序是有先决条件的，所以可以将要有先决条件的个数（在图中即为入度）记录下来，每满足一个就减一，直到个数为0便可以将其放入序列中。</p><h2 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h2><p>如果我们有如下的一个有向无环图，我们需要对这个图的顶点进行拓扑排序，过程如下：</p><p><img src="https://cdn.uniqueue.cn/tuopu-1.png" alt="tuopu-1"></p><p>首先，我们发现V6和v1是没有前驱的，所以我们就随机选去一个输出，我们先输出V6，删除和V6有关的边，得到如下图结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-2.png" alt="tuopu-2"></p><p>然后，我们继续寻找没有前驱的顶点，发现V1没有前驱，所以输出V1，删除和V1有关的边，得到下图的结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-3.png" alt="tuopu-3"></p><p>然后，我们又发现V4和V3都是没有前驱的，那么我们就随机选取一个顶点输出（具体看你实现的算法和图存储结构），我们输出V4，得到如下图结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-4.png" alt="tuopu-4"></p><p>然后，我们输出没有前驱的顶点V3，得到如下结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-5.png" alt="tuopu-5"></p><p>然后，我们分别输出V5和V2，最后全部顶点输出完成，该图的一个拓扑序列为：</p><p>v6–&gt;v1—&gt;v4—&gt;v3—&gt;v5—&gt;v2</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.用邻接表存储数据，同时对终点的结点的入度加一；<br>2.将没有先决条件便可以排序的点（即初始入度为0的点）先加入队列并输出；<br>3.从队首元素开始扩展，将与队首元素相连的结点的入度减一（等同于擦除这条边），如果该结点入度变为0，则将其入队，作为下一次查找的起点；<br>4.将队首元素出队，当队首元素为空时停止排序。</p><h2 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h2><p>有n个点，m条边的有向无环图，输入n，m，然后每一行输入一条边的信息：起点x，终点y</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,re;struct map1{    int stat,end;};map1 tu[100];int rd[100],chong[100];queue &lt;int&gt; q;int main(){    cin&gt;&gt;n&gt;&gt;m;//n点m边    for (a=1;a&lt;=m;a++)    {        cin&gt;&gt;tu[a].stat&gt;&gt;tu[a].end;        rd[tu[a].end]++;    }    for (int i=1;i&lt;=n;i++)    if (rd[i]==0) q.push(i);//将初始入度为0的结点入队    while (!q.empty())    {            cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;            for (int j=1;j&lt;=m;j++)            {                if (tu[j].stat==q.front())//找以队首元素为起点的边                {                    rd[tu[j].end]--;                    if (rd[tu[j].end]==0)                     {                        q.push(tu[j].end);                    }                }            }        q.pop();    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/p/minimum-spanning-tree.html"/>
      <url>/p/minimum-spanning-tree.html</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>最小生成树即为无向图中结点构成的树中各边权值之和最小的树，可以有多种情况。一般用Kruskal（克鲁斯卡尔）算法或Prim（普里姆）算法求出。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>可以将Kruskal算法理解成对边的贪心算法。</p><p>1.将路径用邻接表存储，存储的值为起点、终点和权值；<br>2.将邻接表按照权值为关键字排序；<br>3.从最小权值的边开始循环，每连接起两个结点就把它们并到同一个集合（并查集实现），连接之前判断它们是否已经直接或间接相连（是否同一祖先），如没有相连则连上；<br>4.判断能否构成树：如果所以结点的祖先相同则能，反之则不能构成树。</p><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><p>示例题目：<a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="noopener">洛谷 P3366 【模板】最小生成树</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y,z,a,b,c,k,ans;int f[5005];struct lj{    int qi,zhong,zhi;};//邻接表存储lj map1[200005];bool com(lj a,lj b){    return a.zhi&gt;b.zhi;}//以权值为关键字排序int zx(int a){    if(a==f[a]) return a;    else     {        f[a]=zx(f[a]);        return f[a];    } }//并查集查找祖先int main(){    cin&gt;&gt;n&gt;&gt;m;    for (a=1;a&lt;=n;a++)    f[a]=a;    for (a=1;a&lt;=m;a++)    {        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;        map1[a].qi=x;        map1[a].zhong=y;        map1[a].zhi=z;    }    sort(map1,map1+m+1,com);//排序    while (m&gt;0)    {        x=map1[m].qi;        y=map1[m].zhong;        if (zx(x)!=zx(y)) //查找祖先以确定是否相连        {            f[zx(y)]=zx(x);//连接，统一祖先            ans+=map1[m].zhi;//加上权值        }        m--;    }    for (a=2;a&lt;=n;a++)    if (zx(a)!=zx(1))    {        cout&lt;&lt;&quot;orz&quot;;        return 0;    }//判断能否构成树，只有每一个结点祖先和第一个结点祖先相同，则所有结点祖先都相同    cout&lt;&lt;ans;    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-最小生成树 </tag>
            
            <tag> 算法-Kruskal </tag>
            
            <tag> 算法-Prim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOIP2017爆炸记</title>
      <link href="/p/noip2017-summary.html"/>
      <url>/p/noip2017-summary.html</url>
      <content type="html"><![CDATA[<h3 id="Day-N"><a href="#Day-N" class="headerlink" title="Day -N"></a>Day -N</h3><p>去年只参加PJ，凑巧拿了个一。今年第一次参加TG，还有在<del>徐妈的逼迫下</del>又参加了PJ，还想拿个高分（事实上死的很惨）</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>就复习了点简单的东西（毕竟考前三天才学会c++的文件，P转C的痛苦），中午大半时间在颓2048，感觉什么都没干</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>上午TG。妈的我第一题找了大半个小时都没找出规律就打了个暴力了事；第二题纯种模拟，二十多个变量，样例都过了，<strong>当时</strong>感觉应该没有问题；第三题直接没时间了，tan90°。中午一对答案发现就是个扩展欧几里得，连高精度都不用，数学没学好很无奈啊。<br>中午和WZX绕着电子渴基大学走了一大圈，回来考PJ。第一题<del>真难没看懂</del>；第二题15分钟不到水完，事实上后来发现endl都没有打，20分；第三题深搜，过了样例，感觉还行；第四题不会，打了个暴力走人，感觉50分的数据应该能过。估分350。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>上午去晚了，连集合都没赶上就冲进了考场，整的还有人来问我“XX学校的Llf同学来了没有”，真的尴尬死了。先看了下题，选第三题分两种情况打了个暴力，期望40；然后第一题深搜（然而却并忘了剪枝而爆炸）；第二题乱搞的DP方程过了样例结果发现是错的。感觉就要炸。</p><h3 id="Day-N-爆炸实况"><a href="#Day-N-爆炸实况" class="headerlink" title="Day N 爆炸实况"></a>Day N 爆炸实况</h3><p>第二周的星期天就拿到了我的代码。先对PJ，第一题第二题都没测，第三题测出来出了点问题只有20，第四题发现交错程序了（因为我先打了个骗分版本）珂谷数据10分。感觉只有230了。然后测TG Day1第一题测出来50，第二题20；Day2第一题40（然后绝望的发现我没有剪枝）；第二题爆0；第三题只有30。当时很绝望，但是这不是最惨的时候。<br>到了学校测了PJ的一二题，惊讶的发现第二题只有20，然后绝望的发现并没有换行。我还能说些什么……<br>后来出了官方数据，第三题测出来50还是给了我点安慰，170，绝望的分数。<br>然后TG用官方数据更加炸。105……<br>然后一直绝望了一周。平时感觉自己还行，TG不说有一等起码二等也应该有。后来仔细想了一下，<strong>对PJ的轻视，对TG的畏惧</strong>是主要原因。如果不这样，我也不至于PJ第二题根本不检查，TGD1T1连找规律都不敢。<br>半期也炸掉了，历史最差名次，又被cm姐批了一顿。<br>后悔吗？不！因为</p><blockquote><p>自己选择的路，跪着也要走完</p></blockquote>]]></content>
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记-NOIP </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>咕咕咕</title>
      <link href="/gugugu/index.html"/>
      <url>/gugugu/index.html</url>
      <content type="html"><![CDATA[<h1>    <center> 蒟蒻Llf0703鸽了这篇文章 </center></h1><p>这不是404，只是用作占坑文章的临时页面，请返回上一页。</p>]]></content>
    </entry>
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签云</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>我是Llf，最弱的蒟蒻，完了</p><p>本博客部分文章的markdown源文件均可通过将 <code>https://llf0703.com/p/*.html</code>改为 <code>https://md.llf0703.com/p/*.md</code> 查看</p><p>这个东西会不时更新，也许有的最新文章看不了</p><p><a href="https://bzoj.llf0703.com/" target="_blank" rel="noopener">BZOJ离线题库（By ruanxingzhi）</a></p><p>CSDN博客:  <a href="https://blog.csdn.net/Llf_0703" target="_blank" rel="noopener">Llf_0703</a></p><p>luogu:  <a href="https://www.luogu.org/space/show?uid=29696" target="_blank" rel="noopener">Llf0703</a></p><p>BZOJ:  <a href="https://www.lydsy.com/JudgeOnline/userinfo.php?user=Llf0703" target="_blank" rel="noopener">Llf0703</a></p><p>Bilibili： <a href="https://space.bilibili.com/268840304/" target="_blank" rel="noopener">Llf030703</a></p><p>逼乎:  <a href="https://www.zhihu.com/people/llf-93-87/" target="_blank" rel="noopener">Llf</a></p><p>Coding:  <a href="https://coding.net/u/Llf0703" target="_blank" rel="noopener">Llf0703</a></p><p>Gayhub:  <a href="https://github.com/Llf0703" target="_blank" rel="noopener">Llf0703</a></p>]]></content>
    </entry>
    
  
</search>
