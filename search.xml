<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ZJ第七套总结</title>
      <link href="/p/contest-summary-zj7.html"/>
      <url>/p/contest-summary-zj7.html</url>
      
        <content type="html"><![CDATA[<p>我决定，为了去除冗余的文章长度，所有代码删掉头文件和快读。</p><h2 id="塔-tower"><a href="#塔-tower" class="headerlink" title="塔(tower)"></a>塔(tower)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1651" target="_blank" rel="noopener">P1651 塔</a></p><p>我几乎毫不犹豫就先花5分钟打了一发暴搜，检查没有发现任何问题，最后交上去就有80分：</p><pre><code class="lang-cpp">int h[55],n,m,a,b,c,ans;bool vis[55];bool check(int cnt,int hmax,int sum,int last){    if (sum==hmax &amp;&amp; cnt==2) return 1;    if (sum==hmax &amp;&amp; cnt==1) return check(2,hmax,0,0);    if (sum&gt;hmax) return 0;    for (int i=last+1;i&lt;=n;i++)    {        if (vis[i]) continue;        vis[i]=1;        if (check(cnt,hmax,sum+h[i],i)) return 1;        vis[i]=0;    }    return 0;}inline bool cmp(int x,int y){    return x&gt;y;}int main(){    n=read();    int sum=0;    for (int i=1;i&lt;=n;i++) h[i]=read(),sum+=h[i];    sort(h+1,h+n+1,cmp);    ans=-1;    for (int i=sum&gt;&gt;1;i;i--)    {        if (check(1,i,0,0))        {            ans=i;            break;        }    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>可以说是十分划算了，<del>要什么正解系列</del>。</p><p>正解就是一个dp，用 $ f[i][j] $ 表示放到了第i个，两个塔的差值是j时高塔的最大高度。决策有三种：</p><ol><li>不要</li><li>放到高塔，差值变大</li><li>放到低塔，差值变小（或者反超）</li></ol><p>对应方程就是：</p><script type="math/tex; mode=display">f\left[ i\right] \left[ j\right] =\max \begin{equation}\begin{cases} f[i-1][j] \\ f[i-1][j+s[i]] \\ f[i-1][j-s[i]]+s[i] (j>s[i]) \\ f[i-1][s[i]-j]+j (j<=s[i]) \end{cases}\end{equation}</script><pre><code class="lang-cpp">int f[55][500005],n,m,a,b,c,s[55],sum;int main(){    n=read();    for (int i=1;i&lt;=n;i++) s[i]=read(),sum+=s[i];    memset(f,-0x3f,sizeof(f));    f[0][0]=0;    for (int i=1;i&lt;=n;i++)    {        for (int j=0;j&lt;=sum;j++)        {            f[i][j]=max(f[i-1][j],f[i-1][j+s[i]]);            if (j&gt;s[i]) f[i][j]=max(f[i][j],f[i-1][j-s[i]]+s[i]);            else f[i][j]=max(f[i][j],f[i-1][s[i]-j]+j);        }    }    if (!f[n][0]) printf(&quot;-1&quot;);    else printf(&quot;%d&quot;,f[n][0]);    return 0;}</code></pre><p>还有实名反对洛谷第一个题解，数组大小开的都是错的，真不知道怎么做出来的。</p><h2 id="圆-circle）"><a href="#圆-circle）" class="headerlink" title="圆(circle）"></a>圆(circle）</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1652" target="_blank" rel="noopener">P1652 圆</a></p><p>大水题。只是注意是曲线，不是直线，我写了半天才发现看错题了。这就意味着对于每个圆只需要判断两个点在圆内还是圆外，如果在异端就把答案++即可。</p><pre><code class="lang-cpp">int sx,sy,ex,ey,n,A,B,C,ans;struct cir{    int x,y,r;} c[55];inline double dis(int x1,int y1,int x2,int y2){    return sqrt((double)(x1-x2)*(x1-x2)+(double)(y1-y2)*(y1-y2));}int main(){    n=read();    for (int i=1;i&lt;=n;i++) c[i].x=read();    for (int i=1;i&lt;=n;i++) c[i].y=read();    for (int i=1;i&lt;=n;i++) c[i].r=read();    sx=read(); sy=read(); ex=read(); ey=read();    for (int i=1;i&lt;=n;i++)    {        double dis1=dis(sx,sy,c[i].x,c[i].y),dis2=dis(ex,ey,c[i].x,c[i].y);        if (dis1&lt;c[i].r &amp;&amp; dis2&gt;c[i].r) ans++;        else if (dis1&gt;c[i].r &amp;&amp; dis2&lt;c[i].r) ans++;    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h2 id="猴子-monkey"><a href="#猴子-monkey" class="headerlink" title="猴子(monkey)"></a>猴子(monkey)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1653" target="_blank" rel="noopener">P1653 猴子</a></p><p>我一开始以为真的是树，这样放开以后把他的子树中所有结点更新答案即可，跑一遍dfs记录dfs序和子树大小，然后用线段树维护即可。敲完了发现TM竟然还有互相拉这种操作，然后就GG了，水了个暴力的10分。</p><p>看了题解才发现可以把放手的操作建成图。</p><blockquote><p>事实上我们可以把猴子放手的时间当作这条边的边权，而不放手的边权为一个大数，我们需要求得其实就是一条单源路径，让这条路径最小边权最大，直接输出这个值即可，若这个值为那个大数，就输出-1。(<a href="https://www.luogu.org/blog/the-Despair/solution-p1653" target="_blank" rel="noopener">https://www.luogu.org/blog/the-Despair/solution-p1653</a>)</p></blockquote><p>不过我觉得把这个叫做spfa还是有些欠妥。其实就是一个BFS。</p><pre><code class="lang-cpp">int lson[200005],rson[200005],lfa[200005],rfa[200005],n,m,a,b,c,mn[200005],head[200005],cnt,ans[200005];struct Edge{    int next,to,w;} edge[800005];inline void add(int u,int v,int w){    edge[++cnt].to=v;    edge[cnt].w=w;    edge[cnt].next=head[u];    head[u]=cnt;}inline void bfs(){    queue &lt;int&gt; q;    ans[1]=m;    q.push(1);    while (!q.empty())    {        int x=q.front(); q.pop();        for (int i=head[x];i;i=edge[i].next)        {            int y=edge[i].to,w=min(edge[i].w,ans[x]);            if (w&gt;ans[y])            {                ans[y]=w;                q.push(y);            }        }    }}int main(){    n=read(); m=read();    for (int i=1;i&lt;=n;i++) lson[i]=read(),rson[i]=read(),lfa[i]=rfa[i]=m;    for (int i=0;i&lt;m;i++)    {        a=read(); b=read();        if (b==1) lfa[a]=min(lfa[a],i);        else rfa[a]=min(rfa[a],i);    }    for (int i=1;i&lt;=n;i++)    {        if (lson[i]!=-1) add(i,lson[i],lfa[i]),add(lson[i],i,lfa[i]);        if (rson[i]!=-1) add(i,rson[i],rfa[i]),add(rson[i],i,rfa[i]);    }    bfs();    for (int i=1;i&lt;=n;i++)    {        if (ans[i]==m) printf(&quot;-1\n&quot;);        else printf(&quot;%d\n&quot;,ans[i]);    }    return 0;}</code></pre><h2 id="山-mountain"><a href="#山-mountain" class="headerlink" title="山(mountain)"></a>山(mountain)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1663" target="_blank" rel="noopener">P1663 山</a></p><p>我一开始就被题目给吓住了，就没去做。后来发现这个着实是一个大水题。</p><p>题目的要求其实就是那个灯要在每一条线上或者上方，得出每条线的解析式后二分答案即可。</p><pre><code class="lang-cpp">struct point{    int x,y;} pt[5005];struct line{    double k,b;} l[5005];int n,m,a,b,c;inline bool check(double x){    double rr=1e9,ll=-1e9;    for (int i=1;i&lt;=n;i++)    {        if (l[i].k==0 &amp;&amp; l[i].b&gt;x) return 0;        if (l[i].k&lt;0) rr=min(rr,(l[i].b-x)/l[i].k);        if (l[i].k&gt;0) ll=max(ll,(l[i].b-x)/l[i].k);    }    return ll&lt;=rr;}int main(){    n=read();    for (int i=1;i&lt;=n;i++) pt[i].x=read(),pt[i].y=read();    for (int i=1;i&lt;n;i++)    {        l[i].k=(double)(pt[i+1].y-pt[i].y)/(double)(pt[i+1].x-pt[i].x);        l[i].b=(double)pt[i].y-l[i].k*pt[i].x;    }    double l=0,r=1000000;    while (r-l&gt;=1e-3)    {        double mid=(l+r)/2.0;        if (check(mid)) r=mid;        else l=mid;    }    printf(&quot;%.2f&quot;,l);    return 0;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我今天的得分是80+100+10+0=190.总的来说还是不错，但是我发现读错题这种失误越来越多了。以后还是应该把题认真读完，不要读到一半一激动就开始打，打完了才发现读错题了。这样还特别容易心态爆炸。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>让firefox拥有chrome外观-MaterialFox</title>
      <link href="/p/materialfox.html"/>
      <url>/p/materialfox.html</url>
      
        <content type="html"><![CDATA[<p>昨天Firefox发布了63.0正式版以及64.0beta版。我在看文章<a href="https://zhuanlan.zhihu.com/p/47515099" target="_blank" rel="noopener">Firefox 63.0 正式版用户特性介绍</a>时偶然发现一张图片中的Firefox看起来很像chrome。</p><p>然后在询问作者之后我发现了这个神奇的东西。我个人又挺喜欢圆角的Material Design，于是就配置了一下，效果还不错。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/muckSponge/MaterialFox" target="_blank" rel="noopener">muckSponge/MaterialFox</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>将项目clone到任意一个文件夹</li></ol><pre><code class="lang-git">git clone https://github.com/muckSponge/MaterialFox.git</code></pre><ol><li><p>进入<a href="about:support" target="_blank" rel="noopener">about:support</a>在“配置文件夹”中找到“打开文件”这个按钮，打开文件夹，并将刚刚clone内容中的<code>Material</code>文件夹复制到里面</p></li><li><p>进入<a href="about:config" target="_blank" rel="noopener">about:config</a>，搜索 <code>svg.context-properties.content.enabled</code> 双击将值改成 true。</p></li><li><p>重启Firefox即可</p></li></ol><h2 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h2><p>Firefox是不支持在设置里改变顶栏背景色、字体颜色之类的。这里我们就需要一个官方拓展：<a href="https://color.firefox.com" target="_blank" rel="noopener">Firefox Color</a>。在网站指引下安装拓展进行颜色修改即可。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://i.loli.net/2018/10/25/5bd1ba2d18ac1.png" alt="demo"></p>]]></content>
      
      
      <categories>
          
          <category> 安利 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器-Firefox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZJ第六套总结</title>
      <link href="/p/contest-summary-zj6.html"/>
      <url>/p/contest-summary-zj6.html</url>
      
        <content type="html"><![CDATA[<p>其实徐妈口中的所谓的ZJ十套就是《全国青少年信息学竞赛培训教材复赛》中的十套膜你题。今天先应徐妈之要求把今天的总结了，以后再补之前的。</p><h2 id="分组-group"><a href="#分组-group" class="headerlink" title="分组(group)"></a>分组(group)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1109" target="_blank" rel="noopener">P1109 学生分组</a></p><p>大水题，直接放代码。</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int n,l,r,a,sum,ans1,ans2,ans,s[55];int main(){    freopen(&quot;group.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;group.out&quot;,&quot;w&quot;,stdout);    n=read();    for (int i=1;i&lt;=n;i++) s[i]=read();    l=read(); r=read();    for (int i=1;i&lt;=n;i++)    {        sum+=s[i];        if (s[i]&gt;=l &amp;&amp; s[i]&lt;=r) continue;        if (s[i]&gt;r) ans1+=s[i]-r;        if (s[i]&lt;l) ans2+=l-s[i];    }    ans=max(ans1,ans2);    if (sum&gt;n*r || sum&lt;n*l) printf(&quot;-1&quot;);    else printf(&quot;%d&quot;,ans);    fclose(stdin);    fclose(stdout);    return 0;}</code></pre><h2 id="阶乘-num"><a href="#阶乘-num" class="headerlink" title="阶乘(num)"></a>阶乘(num)</h2><p>洛谷上并没有这道题。</p><p>找下规律，发现末尾都是偶数，而且如果没有5的话直接按照个位来乘就行了。但是遇到5、15之类的就非常恶心了，所以对于这些肯定要分类讨论。</p><p>可以知道，最后的0的来源肯定是2和5，显然，5的个数小于2的个数，所以我们考虑5。</p><p>首先假设没有5存在。即便这样 $ O(n) $ 的时间复杂度还是不现实的。由于只和最后一位有关，所以我们可以将其10个分为一组运算，这样最多算2009次就行了。</p><p>最后总的阶乘和 $ \div 10^{x} $ 就是答案，我们不考虑5的话只需要最后 $ \div 2^{x} $ 就行了（x是5的个数也是0的个数）。所以最后有多少个5我们 $ \div 2 $ 多少个2就行了。可以发现 $ \div 2 $ 后的对应关系</p><ul><li>2—&gt;6</li><li>4—&gt;2</li><li>6—&gt;8</li><li>8—&gt;4</li></ul><p>所以不断除5，并且把答案不断除2也就是变成对应关系就行了，其他的就按10分组直接算。显然要用高精。</p><p>然后我在考场上很开心的写完了<del>TLE</del>代码</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct bigint{    int s[5005],len;    bigint(){memset(s,0,sizeof(s));len=0;}} n;int t,a,b,c,ans;inline bigint division(bigint x,int y){    bigint z;    int sum=0,len=x.len;    for (int i=len;i;i--)    {        sum=sum*10+x.s[i];        z.s[i]=sum/y;        sum%=y;    }    while (!z.s[len]) len--;    z.len=len;    return z;}inline void clear(bigint &amp;x){    for (int i=1;i&lt;=x.len;i++)        x.s[i]=0;    x.len=0;}int main(){    freopen(&quot;num.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;num.out&quot;,&quot;w&quot;,stdout);    t=read();    while (t--)    {        clear(n); ans=1;        char ch[2018];        scanf(&quot;%s&quot;,ch);        for (int i=strlen(ch)-1;i&gt;=0;i--) n.s[++n.len]=ch[i]-&#39;0&#39;;        if (n.len==1 &amp;&amp; n.s[1]==1)        {            printf(&quot;1\n&quot;);            continue;        }        while (n.len&gt;=1)        {            for (int i=1;i&lt;=n.s[1];i++)            {                if (i==5) continue;                ans=(ans*i)%10;            }            n=division(n,5);            int sum=n.s[1]+n.s[2]*10;            if (sum%4==0) ans=(ans*6)%10;            else if (sum%4==1) ans=(ans*8)%10;            else if (sum%4==2) ans=(ans*4)%10;            else if (sum%4==3) ans=(ans*2)%10;        }        printf(&quot;%d\n&quot;,ans);    }    fclose(stdin);    fclose(stdout);    return 0;}</code></pre><p>然后很开心的得了50.</p><p>考后看书才发现那个每一位上都循环乘一遍太浪费时间了，树上直接预处理了一个数组：</p><pre><code class="lang-cpp">int val[10]={1,1,2,6,4,4,4,8,4,6};</code></pre><p>时间复杂度变成了原来的 $ \dfrac {1}{10} $ ，但还是50分。我想是不是高精度初始化和clear太浪费了，就把它删了，毕竟都是重新赋值。然后就有70分了。最后把函数直接写在了<code>main</code>函数里就A了。<del>这TM卡常是有多严重啊</del></p><p>附上AC代码</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct bigint{    int s[3005],len;} n;int t,a,b,c,ans,val[10]={1,1,2,6,4,4,4,8,4,6};int main(){    freopen(&quot;num.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;num.out&quot;,&quot;w&quot;,stdout);    t=read();    while (t--)    {        n.len=0;        ans=1;        char ch[2018];        scanf(&quot;%s&quot;,ch);        for (int i=strlen(ch)-1;i&gt;=0;i--) n.s[++n.len]=ch[i]-&#39;0&#39;;        if (n.len==1 &amp;&amp; n.s[1]==1)        {            printf(&quot;1\n&quot;);            continue;        }        while (n.len&gt;=1)        {            ans=(ans*val[n.s[1]])%10;            int sum=0,len=n.len;            for (int i=len;i;i--)            {                sum=sum*10+n.s[i];                n.s[i]=sum/5;                sum%=5;            }            while (!n.s[len]) len--;            n.len=len;            sum=n.s[1]+n.s[2]*10;            if (sum%4==0) ans=(ans*6)%10;            else if (sum%4==1) ans=(ans*8)%10;            else if (sum%4==2) ans=(ans*4)%10;            else if (sum%4==3) ans=(ans*2)%10;        }        printf(&quot;%d\n&quot;,ans);    }    fclose(stdin);    fclose(stdout);    return 0;}</code></pre><h2 id="拐弯-ddos"><a href="#拐弯-ddos" class="headerlink" title="拐弯(ddos)"></a>拐弯(ddos)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1649" target="_blank" rel="noopener">P1649 [USACO07OCT]障碍路线Obstacle Course</a></p><p>真·玄学题目</p><p>我在11:23的时候花5分钟写了个DFS，然后忘了回溯爆0了。。。加了一句话多了60分。代码长这样：</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int n,mp[105][105],st[2],ed[2],fx[4]={1,0,-1,0},fy[4]={0,1,0,-1},ans;bool vis[105][105];void dfs(int x,int y,int last,int now){    if (x==ed[0] &amp;&amp; y==ed[1])    {        vis[x][y]=1;        ans=min(ans,now);        return;    }    if (vis[x][y]) return;    vis[x][y]=1;    for (int i=0;i&lt;4;i++)    {        int tx=x+fx[i],ty=y+fy[i];        if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;n || mp[tx][ty]==0) continue;        int sum;        if (i==last || last==-1) sum=0;        else sum=1;        dfs(tx,ty,i,now+sum);    }    vis[x][y]=0;}int main(){    n=read();    for (int i=1;i&lt;=n;i++)    {        for (int j=1;j&lt;=n;j++)        {            char ch;            cin&gt;&gt;ch;            if (ch==&#39;.&#39;) mp[i][j]=1;            else if (ch==&#39;x&#39;) mp[i][j]=0;            else if (ch==&#39;A&#39;) st[0]=i,st[1]=j,mp[i][j]=1;            else ed[0]=i,ed[1]=j,mp[i][j]=1;        }    }    ans=1e9;    dfs(st[0],st[1],-1,0);    if (!vis[ed[0]][ed[1]]) printf(&quot;-1&quot;);    else printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>这真的是我5分钟打出来的！除了头文件和快读是粘贴的。看来我搜索没有那么蒻了。</p><p>然后改成BFS就能过。。。只需要注意为了保证拐弯次数递增，每次需要把当前方向走到底再换方向走</p><p>AC代码：</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define pr pair&lt;int,int&gt;#define mpr make_pairusing namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int n,mp[105][105],st[2],ed[2],fx[4]={1,0,-1,0},fy[4]={0,1,0,-1},ans[105][105];inline void bfs(){    queue &lt;pr&gt; q;    q.push(mpr(st[0],st[1]));    ans[st[0]][st[1]]=0;    while (!q.empty())    {        int x=q.front().first,y=q.front().second; q.pop();        if (x==ed[0] &amp;&amp; y==ed[1]) break;        for (int i=0;i&lt;4;i++)        {            int tx=x,ty=y;            for (;;)            {                tx+=fx[i]; ty+=fy[i];                if (tx&lt;1 || tx&gt;n || ty&lt;1 || ty&gt;n || !mp[tx][ty]) break;                if (ans[x][y]+1&lt;ans[tx][ty])                {                    ans[tx][ty]=ans[x][y]+1;                    q.push(mpr(tx,ty));                }            }        }    }    if (ans[ed[0]][ed[1]]==1e9) printf(&quot;-1&quot;);    else printf(&quot;%d&quot;,ans[ed[0]][ed[1]]-1);    return;}int main(){    n=read();    for (int i=1;i&lt;=n;i++)    {        for (int j=1;j&lt;=n;j++)        {            ans[i][j]=1e9;            char ch;            cin&gt;&gt;ch;            if (ch==&#39;.&#39;) mp[i][j]=1;            else if (ch==&#39;x&#39;) mp[i][j]=0;            else if (ch==&#39;A&#39;) st[0]=i,st[1]=j,mp[i][j]=1;            else ed[0]=i,ed[1]=j,mp[i][j]=1;        }    }    bfs();    return 0;}</code></pre><h2 id="赛马-horse"><a href="#赛马-horse" class="headerlink" title="赛马(horse)"></a>赛马(horse)</h2><p>洛谷题目：<a href="https://www.luogu.org/problemnew/show/P1650" target="_blank" rel="noopener">P1650 田忌赛马</a></p><p>贪心。</p><blockquote><p>以下内容转载自：<a href="https://www.luogu.org/blog/user55918/solution-p1650" target="_blank" rel="noopener">https://www.luogu.org/blog/user55918/solution-p1650</a></p></blockquote><ol><li>开始也是先排序，可以使用sort快排</li><li>然后将田忌最大的马与国王进行比较</li><li>如果田忌最大的马大于国王，那么就胜场++</li><li>如果田忌最大的马小于国王，那么就一定会输，所以用田忌最小的马输给国王最大的马</li><li>如果田忌最大的马等于国王，那么就比较最小的马<ol><li>如果田忌最小的马大于国王，那么胜场++</li><li>如果田忌最小的马小于国王，那么就输给国王</li><li>如果田忌最小的马等于国王，就用田忌最小的马对国王最大的马，如果国王最大的马大，那么财产要减200</li></ol></li></ol><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int n,x[2005],y[2005],ans;inline bool cmp(int x,int y){    return x&gt;y;}int main(){    n=read();    for (int i=1;i&lt;=n;i++) x[i]=read();    for (int i=1;i&lt;=n;i++) y[i]=read();    sort(x+1,x+n+1,cmp);    sort(y+1,y+n+1,cmp);    int i=1,j=n,k=1,l=n;    while (i&lt;=j)    {        if (x[i]&gt;y[k])        {            ans+=200;            i++; k++;        }        else if (x[i]&lt;y[k])        {            ans-=200;            j--; k++;        }        else if (x[j]&gt;y[l])        {            ans+=200;            j--; l--;        }        else        {            if (x[j]&lt;y[k]) ans-=200;            j--; k++;        }    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我今天的第一次提交分数是100+50+10+10=170，其中低级失误占的分数有50分，也就是那个忘了回溯。当然，这也反映出来我时间安排不当的问题。耗费大量时间在第二题，甚至连比较简单的贪心的第四题都没怎么写，而且第二题因为复杂度差了一点也只有50分。</p><p>总的来说现在低级失误还是越来越少了，但还是没有消失，所以还要多刷题啊！</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高精度算法模板</title>
      <link href="/p/bigint.html"/>
      <url>/p/bigint.html</url>
      
        <content type="html"><![CDATA[<p>只是发个板子。虽说似乎NOIp近几年一般都是取膜而不是高精了，但我还是担心会考，所以就复习了一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用struct储存整个数和位数。整个数全部倒序方便计算。</p><pre><code class="lang-cpp">struct bigint{    int s[5005],len;    bigint(){memset(s,0,sizeof(s));len=0;}};</code></pre><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><pre><code class="lang-cpp">inline bigint add(bigint x,bigint y){    bigint z;    int len=max(x.len,y.len),add=0;    for (int i=1;i&lt;=len;i++)    {        z.s[i]=x.s[i]+y.s[i]+add;        add=z.s[i]/10;        z.s[i]%=10;    }    if (add) z.s[++len]=add;    z.len=len;    return z;}</code></pre><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>和加法原理相同，不过这里保证x&gt;y。所以</p><pre><code class="lang-cpp">inline bigint sub(bigint x,bigint y) //x&gt;y{    bigint z;    int add=0,len=x.len;y    for (int i=1;i&lt;=len;i++)    {        z.s[i]=x.s[i]-y.s[i]-add;        add=0;        if (z.s[i]&lt;0) add=1,z.s[i]+=10;    }     z.len=len;    return z;}</code></pre><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="高精乘低精"><a href="#高精乘低精" class="headerlink" title="高精乘低精"></a>高精乘低精</h3><p>原理也差不多，只是注意最后要把进位全部加完。</p><pre><code class="lang-cpp">inline bigint times(bigint x,int y){    bigint z;    int len=x.len,add=0;    for (int i=1;i&lt;=len;i++)    {        z.s[i]=x.s[i]*y+add;        add=z.s[i]/10;        z.s[i]%=10;    }    while (add)     {        z.s[++len]=add%10;        add/=10;    }    z.len=len;    return z;}</code></pre><h3 id="高精乘高精"><a href="#高精乘高精" class="headerlink" title="高精乘高精"></a>高精乘高精</h3><p>写过了，但还没写成模板，暂时先咕咕咕了。</p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><h3 id="高精除低精"><a href="#高精除低精" class="headerlink" title="高精除低精"></a>高精除低精</h3><p>跟竖式一样，需要正着从高位往低位除。最后注意下把前导0去掉。</p><pre><code class="lang-cpp">inline bigint division(bigint x,int y){    bigint z;    int sum=0,len=x.len;    for (int i=len;i;i--)    {        sum=sum*10+x.s[i];        z.s[i]=sum/y;        sum%=y;    }    while (!z.s[len]) len--;    z.len=len;    return z;}</code></pre><h3 id="高精除高精"><a href="#高精除高精" class="headerlink" title="高精除高精"></a>高精除高精</h3><p>写不来，noip估计也不会考。我太菜了。</p><h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><p>返回1表示 $ x&gt;y $ ,-1表示 $ x&lt;y $ ,0表示 $ x=y $。按位比较即可。</p><pre><code class="lang-cpp">inline int cmp(bigint x,bigint y){    if (x.len&gt;y.len) return 1;    if (x.len&lt;y.len) return -1;    for (int i=x.len;i;i--)    {        if (x.s[i]&lt;y.s[i]) return -1;        if (x.s[i]&gt;y.s[i]) return 1;    }    return 0;}</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>逆序输出即可。</p><pre><code class="lang-cpp">inline void print(bigint x){    for (int i=x.len;i;i--)        printf(&quot;%d&quot;,x.s[i]);}</code></pre><h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><p>把数组和长度都赋为0。</p><pre><code class="lang-cpp">inline void clear(bigint &amp;x){    for (int i=1;i&lt;=x.len;i++)        x.s[i]=0;    x.len=0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.10.18日记</title>
      <link href="/p/diary-20181018.html"/>
      <url>/p/diary-20181018.html</url>
      
        <content type="html"><![CDATA[<p><del>那个啥，好吧我承认，这个东西是我10.19下午才赶出来的。</del></p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>无</p><h2 id="正事"><a href="#正事" class="headerlink" title="正事"></a>正事</h2><p>今天打了第三套，非常不爽。打了一个多小时的第三题告诉我题目有问题，少了个省略号。徐妈说的要加时，但我又因为要上数学课最后一节课走了，然后最后就只有第一题有60分。回来我才发现第四题其实是最简单的一道题，洛谷评分只有PJ-。。。</p><p>然后下午调第二题调了一下午，现在都还没调出来。晚上又做第三题，可算是把高精板子全部打了一遍了，然后struct里面忘了赋初值又调了半天。真是荒废的一天。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>比昨天还不爽</p><h2 id="明天计划"><a href="#明天计划" class="headerlink" title="明天计划"></a>明天计划</h2><p>没啥计划了，见机行事，免得又咕咕咕了。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.10.17日记</title>
      <link href="/p/diary-20181017.html"/>
      <url>/p/diary-20181017.html</url>
      
        <content type="html"><![CDATA[<p>今天好废啊。感觉也没怎么颓，上午一场比赛，下午搞完比赛，晚上打了个板子然后只debug了一道题就过去了。计划还真就一语成畿地咕咕咕了。</p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>下午在我们体育课考试的时候与大佬们去打乒乓，去球馆又被赶出来了，然后就作死去操场上的球台去打乒乓。然后到处都是同班同学在考试，尴尬死了。</p><h2 id="正事"><a href="#正事" class="headerlink" title="正事"></a>正事</h2><p>上午打了浙江十套的第一套，三道题都想出来了正解的思想，然鹅最后却只有80。。。第一题特判出了点锅，第二题算法稍微出了些问题，第三题连区间DP都写出来了，不过方程式有点锅。</p><p>下午就把这些题搞定了，然后去打乒乓。</p><p>晚上按计划做最短路相关。先打了一遍Dijkstra的模板，然后进试炼场做了<a href="https://www.luogu.org/problemnew/show/P1462" target="_blank" rel="noopener">洛谷P1462 通往奥格瑞玛的道路</a>,然后就debug了一个小时，最后发现是我把排序后的数组在后面直接取下标使用。然后时间就差不多了。总结之类的明天补。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>很不爽</p><h2 id="明天计划"><a href="#明天计划" class="headerlink" title="明天计划"></a>明天计划</h2><p>继续搞图论。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2018.10.16日记·洛谷TG试炼场DP-lv1总结</title>
      <link href="/p/diary-20181016.html"/>
      <url>/p/diary-20181016.html</url>
      
        <content type="html"><![CDATA[<h2 id="昨天计划完成情况"><a href="#昨天计划完成情况" class="headerlink" title="昨天计划完成情况"></a>昨天计划完成情况</h2><p>因为上午下午都被徐妈拉去打onecode的天梯水题，所以咕咕咕了。只做完了dp的lv1模块。明天上午又有一套浙江的摸你题，所以把剩下的挪到明天应该就差不多了<del>（大概吧）</del></p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>无</p><h2 id="正事"><a href="#正事" class="headerlink" title="正事"></a>正事</h2><p>今天完成了onecode天梯的3和14，都是水题，就不写了。被14D坑惨了，加上快读全部TLE，cyc大佬的快读也是，然后他的fread也多WA了几个点。这TM绝壁是数据的锅，辣鸡OJ。</p><p>然后晚上做了洛谷TG试炼场的DP lv1 模块，还是大致总结一下。</p><h3 id="洛谷P1005-矩阵取数游戏"><a href="#洛谷P1005-矩阵取数游戏" class="headerlink" title="洛谷P1005 矩阵取数游戏"></a><a href="https://www.luogu.org/problemnew/show/P1005" target="_blank" rel="noopener">洛谷P1005 矩阵取数游戏</a></h3><p>区间DP。对于每行，我们可以单独处理。用 $ f[l][r] $ 表示已经取了 $ l..r $ 这个区间后的得分最大值。然后记忆化搜索即可。</p><p>$ $ 肯定是爆<code>long long</code>了，按理来说应该要写高精的，但是我发现这玩意写高精如果没有运算符重载版的是真的恶心，然后<code>__int128</code>水过去了。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define ll __int128using namespace std;inline ll read(){    char ch=getchar();    ll f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}ll mp[85][85],n,m,f[85][85],ans,two[85];ll dfs(int i,int l,int r){    if (f[l][r]!=-1) return f[l][r];    if (l==r) return f[l][r]=mp[i][l]*two[m];    return f[l][r]=max(dfs(i,l+1,r)+mp[i][l]*two[m-r+l],dfs(i,l,r-1)+mp[i][r]*two[m-r+l]);}void print(ll x){    if (x==0) return;    print(x/10);    putchar(x%10+&#39;0&#39;);}int main(){    n=read(); m=read();    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=m;j++)            mp[i][j]=read();    two[0]=1;    for (int i=1;i&lt;=m;i++) two[i]=two[i-1]*2;    for (int i=1;i&lt;=n;i++)    {        memset(f,-1,sizeof(f));        ans+=dfs(i,1,m);    }    if (ans==0) printf(&quot;0&quot;);    else print(ans);    return 0;}</code></pre><h3 id="洛谷P1373-小a和uim之大逃离"><a href="#洛谷P1373-小a和uim之大逃离" class="headerlink" title="洛谷P1373 小a和uim之大逃离"></a><a href="https://www.luogu.org/problemnew/show/P1373" target="_blank" rel="noopener">洛谷P1373 小a和uim之大逃离</a></h3><p>首先容易想到把小a和uim两人的魔液量都记录下来，但这样空间就爆了。事实上，我们不关心他们具体的魔液量，只要他们两人魔液量的差是 $ (k+1) $ 的倍数就行了。所以记录两人魔液的差量就行了，如果超过 $ (k+1) $ 膜就行了。</p><p>用 $ f[i][j][l][t] $ 表示走到 $ (i,j) $ ，魔液差量为 $ l $ ，第 $ t $ 个人取 <del>(因为k被用了)</del>。方程式即为：</p><script type="math/tex; mode=display">f[i][j][l][0]=f[i-1][j][(l-mp[i][j]+k) mod k][1]+f[i][j-1][(l-mp[i][j]+k) mod k][1]</script><script type="math/tex; mode=display">f[i][j][l][t]=f[i-1][j][(l+mp[i][j]) mod k][0]+f[i][j-1][l+mp[i][j]) mod k][0]</script><p>自觉这道题码风极其<del>简洁</del>丑陋。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define ha 1000000007using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int f[805][805][16][2],mp[805][805];//到(i,j)，差值为k，l取int n,m,k,ans;int main(){    n=read(); m=read(); k=read();    k++;    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=m;j++)            mp[i][j]=read()%k,f[i][j][mp[i][j]][0]=1;    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=m;j++)            for (int l=0;l&lt;k;l++)                for (int t=0;t&lt;=1;t++)                    f[i][j][l][t]=(f[i][j][l][t] + f[i-1][j][t ? (l+mp[i][j])%k : (l-mp[i][j]+k)%k][!t]%ha + f[i][j-1][t ? (l+mp[i][j])%k : (l-mp[i][j]+k)%k][!t]%ha)%ha;    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=m;j++)            ans=(ans+f[i][j][0][1])%ha;    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h3 id="洛谷P2279-HNOI2003-消防局的设立"><a href="#洛谷P2279-HNOI2003-消防局的设立" class="headerlink" title="洛谷P2279 [HNOI2003]消防局的设立"></a><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener">洛谷P2279 [HNOI2003]消防局的设立</a></h3><p>虽说放在DP板块，但贪心就能水过。。。</p><p>我们肯定要保证覆盖到叶节点，而对于每一个结点，他能覆盖到的地方就是最远到它爷爷，它孙子和它兄♂弟。它的爷爷节点就可以把它和它兄弟都覆盖了。</p><p>也就是说对于每个 叶节点或子节点及以下都已经被覆盖了 的点，选取它的爷爷节点一定是最优的。所以用一个优先队列每次找到深度最深的没有被覆盖的点的爷爷节点放上消防站，然后更新周围即可。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define pr pair&lt;int,int&gt;#define mp make_pairusing namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct Edge{    int next,to;} edge[2005];int head[1005],deep[1005],cnt=1,n,m,a,b,c,fa[1005],ans;priority_queue &lt;pr&gt; q;bool vis[1005];inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}void dfs(int x,int f,int dep){    deep[x]=dep;    fa[x]=f;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f) continue;        dfs(y,x,dep+1);    }}void dfs2(int x,int f,int dep){    if (dep&gt;2) return;    vis[x]=1;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f) continue;        dfs2(y,x,dep+1);    }}inline void work(int x){    if (!x) x=1; //最高就是根节点    dfs2(x,0,0);}int main(){    n=read();    for (int i=2;i&lt;=n;i++)    {        a=read();        add(a,i);        add(i,a);    }    dfs(1,0,1);    for (int i=1;i&lt;=n;i++) q.push(mp(deep[i],i));    while (!q.empty())    {        int x=q.top().second;        q.pop();        if (vis[x]) continue;        work(fa[fa[x]]);        ans++;    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h3 id="洛谷P1220-关路灯"><a href="#洛谷P1220-关路灯" class="headerlink" title="洛谷P1220 关路灯"></a><a href="https://www.luogu.org/problemnew/show/P1220" target="_blank" rel="noopener">洛谷P1220 关路灯</a></h3><p>也是区间DP。因为关灯不需要时间，所以路过后肯定把路上的灯都关上比较划算，这就意味着关了的等都是连续的并且可以看作一段区间。</p><p>用 $ f[l][r][0/1] $ 表示老张关了 $ l..r $ 区间的灯，然后站在左边/右边。转移的时候就加上所需的时间 $ \times $ 两头没关的灯的功率和即可。算功率和预处理一个前缀和数组<code>sum</code>即可。转移方程式如下：</p><pre><code class="lang-cpp">f[l][r][1]=min(f[l][r-1][1]+(pos[r]-pos[r-1])*(sum[n]-sum[r-1]+sum[l-1]),f[l][r-1][0]+(pos[r]-pos[l])*(sum[n]-sum[r-1]+sum[l-1]));f[l][r][0]=min(f[l+1][r][0]+(pos[l+1]-pos[l])*(sum[n]-sum[r]+sum[l]),f[l+1][r][1]+(pos[r]-pos[l])*(sum[n]-sum[r]+sum[l]));</code></pre><p>因为太菜了写不来递推式，我就用的记忆化搜索。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int f[55][55][2],n,c,pos[55],v,sum[55];int dfs(int l,int r,bool s) //0左1右{    if (l&gt;r) return 1e9;    int &amp;ans=f[l][r][s];    if (ans!=-1) return ans;    if (s) ans=min(dfs(l,r-1,s)+(pos[r]-pos[r-1])*(sum[n]-sum[r-1]+sum[l-1]),dfs(l,r-1,!s)+(pos[r]-pos[l])*(sum[n]-sum[r-1]+sum[l-1]));    else ans=min(dfs(l+1,r,s)+(pos[l+1]-pos[l])*(sum[n]-sum[r]+sum[l]),dfs(l+1,r,!s)+(pos[r]-pos[l])*(sum[n]-sum[r]+sum[l]));    return ans;}int main(){    n=read(); c=read();    for (int i=1;i&lt;=n;i++) pos[i]=read(),v=read(),sum[i]=sum[i-1]+v;    memset(f,-1,sizeof(f));    f[c][c][0]=f[c][c][1]=0;    printf(&quot;%d&quot;,min(dfs(1,n,0),dfs(1,n,1)));    return 0;}</code></pre><p>奶牛那个题看了下题解，似乎是变形的背包，不想做了。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>今天一共完成了11道题，因为DP难度较大所以和昨天其实也差不多。感觉还是计划赶不上变化，只有尽量完成计划。</p><h2 id="明天的咕咕咕计划"><a href="#明天的咕咕咕计划" class="headerlink" title="明天的咕咕咕计划"></a>明天的<del>咕咕咕</del>计划</h2><p>上午浙江第1套，下午及晚上 重做所有图论模板题并完成最短路问题板块。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.15日记</title>
      <link href="/p/diary-20181015.html"/>
      <url>/p/diary-20181015.html</url>
      
        <content type="html"><![CDATA[<p>今天是停课第一天，总的来说效率还是挺高的。不知道后面还能不能保持。</p><h2 id="杂事"><a href="#杂事" class="headerlink" title="杂事"></a>杂事</h2><p>今天最尴尬的事莫过于我被xtq大佬坑了，少上了节数学课（我只上数学）。不过好像都是做题，没讲新知识点，所以还好。</p><p>下午又被一个浙江来的老师虐的体无完肤，感觉自己学OI真的没前途了。</p><blockquote><p>你洛谷才300多道题啊，我们那(ZJ)小学6年级学生题量都有这么多。</p><p>绿题及以下都是水题，蓝题和紫题算是中等题，你做的大多都是水题。</p><p>我当时考试的时候30分钟就把前两道题的正解打完了，然后睡了会儿，起来很快把第三题70分暴力打了。</p><p>我们当时打题都是劈里啪啦一顿打，如果你10分钟都还打不完暴力那NOIp差不多就完了。</p><p>你就搜个算法，然后把洛谷这一面所有题全部打完。想不到就去看题解，不一定要完全理解。</p></blockquote><p>感觉自己遭受<code>0x7fffffff</code>点暴击，都不敢打水题了QAQ。</p><p>总的来说我的感受是：<strong>我好菜啊，我校好菜啊，我省好菜啊</strong>。</p><h2 id="正事"><a href="#正事" class="headerlink" title="正事"></a>正事</h2><p>上午把高精的板块刷完了，然后把之前因为高精搁置的题处理完了。然后徐妈又让我们打了onecode天梯的第二套，全是水题，最后92分，<del>如果我第三题开了<code>long long</code>就AK了</del>。</p><p>下午去小黑屋打了好多道贪心的水题，可是我就连橙题都不能一遍过，还是太菜了。</p><p>晚上做了两道蓝题的DP，感觉海星。</p><p>今天总共做了15道题，还是很不错的。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>虽然被虐的很惨，但是感觉他的话还是有很多道理的。尤其是要多做题，就算理解不了记下来方法就行了。不管是什么考试，其实题型都很难有变化，如果做过类似的题，至少思路这个最重要的部分就没问题了。而且像初二初三我理解了的算法还是忘了很多，还不如我背的数据结构熟练。</p><p>我个人感觉做水题还是很有帮助的，毕竟水题中经常会有些细节被我忽略，而这些细节难题中可能也会出现。毕竟“题多不压身”（我编的）。</p><h2 id="明天计划"><a href="#明天计划" class="headerlink" title="明天计划"></a>明天计划</h2><p>完成动态规划lv1，重做所有图论模板题并完成最短路问题板块。</p><p>剩下的时间视情况安排。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NOIp前复习杂记(置顶)</title>
      <link href="/p/review-before-noip.html"/>
      <url>/p/review-before-noip.html</url>
      
        <content type="html"><![CDATA[<h2 id="每天大致的总结"><a href="#每天大致的总结" class="headerlink" title="每天大致的总结"></a>每天大致的总结</h2><ul><li>10.23 完成ZJ第五套，打了些试炼场的图论题，学习Prim算法(我好菜啊，那么久都只会Kruskal)并填了半年前咕咕咕的坑: <a href="https://llf0703.com/p/minimum-spanning-tree.html">最小生成树总结</a></li><li>10.24 完成ZJ第六套，下午优化一道题和完成那套题搞了一下午，又在WZX的怂恿下挑战了不编译写线段树和树剖直接交，都是先CE了一遍然后加了两个变量直接过的。做了一道prim的题然后就差不多了。</li></ul><h2 id="需要加强板块"><a href="#需要加强板块" class="headerlink" title="需要加强板块"></a>需要加强板块</h2><ol><li>高精 （差个重定义运算符版）</li><li>贪心</li><li>搜索 √</li><li>二分、分治</li><li>二叉树，二叉排序树相关</li><li>图论相关模板<ol><li>LCA（倍增）</li><li>二分图匹配 √</li><li>强连通，割点等</li><li>最短路 √</li><li>生成树 √</li></ol></li><li>字符串相关<ol><li>KMP</li><li>Trie</li><li>hash</li></ol></li><li>数论相关</li><li>DP <del>Dark Fantasy</del></li><li>二进制相关知识</li></ol><h2 id="犯过的低级错误"><a href="#犯过的低级错误" class="headerlink" title="犯过的低级错误"></a>犯过的低级错误</h2><ol><li>数组排序后还是取下标直接使用：<a href="https://www.luogu.org/problemnew/show/P1462" target="_blank" rel="noopener">洛谷P1462 通往奥格瑞玛的道路</a></li><li>struct里面没赋初值：<a href="https://www.luogu.org/problemnew/show/P1625" target="_blank" rel="noopener">洛谷P1625 求和</a></li><li>差分约束最初没连负权边就写了Dijkstra后来发现不对又连了负权边却没改成SPFA：<a href="https://www.luogu.org/problemnew/show/P1645" target="_blank" rel="noopener">洛谷P1645 序列</a></li><li>在求两点的距离时没有注意double精度：<a href="https://www.luogu.org/problemnew/show/P1265" target="_blank" rel="noopener">洛谷P1265 公路修建</a></li></ol><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ul><li>10.15-10.29 做完洛谷试炼场提高</li><li>10.15 重点加强高精</li><li>10.16 完成动态规划lv1(完成)，<del>重做所有图论模板题并完成最短路问题板块</del>(未完成)</li><li>10.17 上午浙江第1套，下午及晚上 重做所有图论模板题并完成最短路问题板块</li><li>10.18 继续搞图论</li><li>10.19 打两套题，没啥计划了</li><li>我觉得计划赶不上变化，写日记又浪费时间，干脆不写了，只做些专题的复习。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>初赛知识点复习(乱序)</title>
      <link href="/p/noip-pretest-summary.html"/>
      <url>/p/noip-pretest-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote><p>作者： dreamcatcher-cx 出处： <a href="https://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/</a></p><p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在页面明显位置给出原文链接。</p></blockquote><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，<code>n/2,(n/2)/2,...,1</code>，称为增量序列。</p><p>希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p><img src="https://cdn.uniqueue.cn/xier-sort.png" alt="希尔排序"></p><p>例题：设一组初始记录关键字序列为(50，40，95，20，15，70，60，45)，则以增量d=4的一趟希尔排序结束后前4条记录关键字为（）。</p><ul><li>A、40，50，20，95         </li><li>B、15，40，60，20</li><li>C、15，20，40，45         </li><li>D、45，40，15，20</li></ul><p>答案：B</p><h3 id="std-sort"><a href="#std-sort" class="headerlink" title="std:sort"></a>std:sort</h3><blockquote><p><code>std::sort</code> 在数据量大时采用快排，分段递归排序；一旦分段后的数据小于某个值，就改用插入排序；如果递归层次过深，还会改用堆排序。</p></blockquote><p><code>std::sort</code>使用了快排，插入排序（希尔排序），堆排序。</p><p>例题：c++的std::sort实现中使用了以下哪些快速排序的算法（） </p><ul><li>A、快速排序   </li><li>B、堆排序  </li><li>C、基数排序   </li><li>D、插入排序(希尔排序)</li></ul><p>答案：ABD</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。</p><p>时间效率：最好：$ O(log n) $ 最坏：$ O(n \times log n) $</p><p>其中归并就是将两个数组一个个比较即可，最多比较 $ 2n-1 $ 次。</p><p>例(NOIp2017 T11)：设 A 和 B 是两个长为 n 的有序数组，现在需要将 A 和 B 合并成一个排好序的 数组，请问任何以元素比较作为基本运算的归并算法最坏情况下至少要做 （ ）次比较。</p><p>答案：$ 2n-1 $</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><ul><li>稳定排序：插入排序、桶排序、基数排序</li><li>不稳定排序：快速排序、堆排序、希尔排序、归并排序、选择排序、冒泡排序</li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>哈夫曼树是最优二叉树，即每个点的权值 $\times$ 它到根节点的路径和最小。</p><p>哈夫曼树的构建方法是先将每个点单独构建成一颗只有自己的树，然后每次选取路径和最小的两棵树合并到一起，所有树合并完即构建成功。</p><p><img src="https://cdn.uniqueue.cn/huffman.jpg" alt="哈夫曼"></p><p>例题：设某哈夫曼树中有199个结点，则该哈夫曼树中有（）个叶子结点。</p><ul><li>A、 99    </li><li>B、 100    </li><li>C、 101    </li><li>D、 102</li></ul><p>答案：B</p><p>解析：把 $ n $ 个节点构建成哈夫曼树，相当于把 $ n $ 个只有根节点的子树合并成一个树，其中将任意两个子树合并成一个棵树需要增加一个节点，则一共需要增加 $ n-1 $ 个节点，才能使其变成一棵哈夫曼树，即这棵哈夫曼树一种有 $ 2n-1 $ 个树。$ 2 \times n - 1 = 199 $ ，解得：$n = 100$</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>就是一般人用的表达式，初赛肯定不会考。</p><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><blockquote><p>以下内容转载至：<a href="https://www.cnblogs.com/chensongxian/p/7059802.html" target="_blank" rel="noopener">https://www.cnblogs.com/chensongxian/p/7059802.html</a></p></blockquote><p>就是把运算符放到数字的前面。</p><p>前缀转中缀：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><p>中缀转前缀：</p><ol><li>初始化两个栈:运算符栈s1，储存中间结果的栈s2</li><li>从右至左扫描中缀表达式</li><li>遇到操作数时，将其压入s2</li><li>遇到运算符时，比较其与s1栈顶运算符的优先级<ol><li>如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈</li><li>否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1</li><li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较</li></ol></li><li>遇到括号时<ol><li>如果是右括号“)”，则直接压入s1</li><li>如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃</li></ol></li><li>重复步骤2至5，直到表达式的最左边</li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式</li></ol><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>就是把运算符放到数字的左边。</p><p>前缀转中缀：从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><p>中缀转前缀：和中缀转后缀差不多，就是从左到右扫，最后逆序就行了。</p><p>例(NOIp2017 T7)：表达式 a <em> (b + c) </em> d 的后缀形式是（ ）。</p><ul><li>A. a b c d <em> + </em></li><li>B. a b c + <em> d </em></li><li>C. a <em> b c + </em> d</li><li>D. b + c <em> a </em> d </li></ul><p>答案：B</p><h3 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h3><p>中缀转前缀、后缀的方法其实根本用不上，只需要把选项转成中缀比对就行了。</p><p><del>当然，如果除了选择题的题考到了，那就另说吧。</del></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><p>完全图：每对顶点都有边相连的图。<br>完全无向图有 $ \dfrac {n\times \left( n-1\right) }{2} $ 条边，完全有向图有 $ n\times \left( n-1\right)  $条边。</p><p>连通图：每两个节点间都有路径相连的图。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例1：(NOIp2017 T8) 由四个不同的点构成的简单无向连通图的个数是（ ）。</p><p>答案：38</p><p>解析：按照分类标准连1条、连2条、连3条、连4条、连5条、连6条分类讨论。其中连1条、连2条由于无法构成无向连通图而舍掉。再对剩下的情况进行组合（因为无向），即在6条可能的边中连上3、4、5或6条，并将可以构成无向连通图的情况进行计数。不能构成的情况其实应该只有连3条边时才出现。比如ABCD 4个点三条边分别连接A-B、B-C、C-A就不行，一共四种不行的。算出来一共是42-4=38种。 </p><p>例2：(NOIp2016 T8) G 是一个非连通简单无向图，共有 28 条边，则该图至少有（ ）个顶点。</p><p>答案：9</p><p>解析：因为是非连通图，所以至少有一个点不能连通，那么建一个完全图再把顶点+1即可。</p><p>$ \dfrac {n\times \left( n-1\right) }{2} = 28 $ ，解得 $ n=8 $ ，答案为 $ n+1=9 $。</p><h2 id="递推时间复杂度的计算"><a href="#递推时间复杂度的计算" class="headerlink" title="递推时间复杂度的计算"></a>递推时间复杂度的计算</h2><h3 id="主定理-Master-Theorem"><a href="#主定理-Master-Theorem" class="headerlink" title="主定理(Master Theorem)"></a>主定理(Master Theorem)</h3><blockquote><p>以下内容来自<a href="https://oi-wiki.org/misc/complexity/#master-theorem" target="_blank" rel="noopener">OI Wiki</a>,全部内容在 CC BY-SA 4.0 和 SATA 协议之条款下提供，附加条款亦可能应用</p><p>根据SATA协议的相关要求，我已给了Star，并在此推荐此网站及感谢 <a href="https://github.com/Ir1d" target="_blank" rel="noopener">@lr1d</a> 和 <a href="https://github.com/yeguanghao" target="_blank" rel="noopener">@yeguanghao</a> 对此内容的贡献。</p></blockquote><p>我们可以使用 Master Theorem 来快速的求得关于递归算法的复杂度。 假设我们有递推关系式</p><script type="math/tex; mode=display">T(n) = AT\left(\frac{n}{b}\right)＋cn^k, \qquad \forall n > b</script><p>那么</p><script type="math/tex; mode=display">T(n) = \begin{equation}\begin{cases}\Theta(n^{\log_b a}) & a > b^k \\ \Theta(n^k) & a< b^k \\ \Theta(n^k\log n ) & a = b^k \end{cases}\end{equation}</script>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛-初赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>科普基地国庆集训测试题总结</title>
      <link href="/p/contest-summary-2.html"/>
      <url>/p/contest-summary-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><iframe src="https://cdn.uniqueue.cn/20181008.pdf" width="100%" height="800px" scroll="no"></iframe><h3 id="D1T1-剪刀石头布-stone"><a href="#D1T1-剪刀石头布-stone" class="headerlink" title="D1T1 剪刀石头布(stone)"></a>D1T1 剪刀石头布(stone)</h3><p>我一开始还真的以为模拟题的D1T1就是真的noipD1T1难度呢，现在想来还是太naive了。</p><p>最开始我没有注意到只能取最大或最小，以为都可以取，那么这道题就真的是D1T1难度了。当然，因为两位数要么最大，要么最小，所以这样我们也就解决了40%的点了。</p><p>对于每个一位数，直接取完就可以获胜，而只有10可以取到一位数，所以轮到10就输了，而如果要取到10只能选11~19。这样推下去，我们发现：</p><ol><li>当n%10!=0时，小明肯定会将它取到%10=0来让自己获胜</li><li>当n%10==0时，小明只能把它取到第一种情况，小头就可以照1中小明的做以获胜</li></ol><p>综上，我们得出结论：</p><blockquote><p>当n%10!=0，输出”NO”; 当n%10==0，输出”YES”</p></blockquote><p>然后我很开心地写完了， <del>很开心</del>的得了40分。</p><pre><code class="lang-cpp">while (t--){    n=read();    if (n%10==0) printf(&quot;NO\n&quot;);    else printf(&quot;YES\n&quot;);}</code></pre><p>后来讲评的时候发现似乎只有1人AC，还有1人做法和我一样，但他没有看错题，就是铁了心要得40分的。</p><p>然后告诉我们正解竟然是搜索？！做法就是直接dfs，因为只要存在一种让小明胜利的方法，小明就一定能胜利（先手真好），所以搜到以后直接退出就行了。WTF？</p><p>当然，对于搜到每一个数，结果一定是一样的，所以我们可以用个记忆化来优化。<del>不加记忆化40，加了就A了</del></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int n,t,f[1000005];bool dfs(int x){    if (f[x]!=-1) return f[x];    int y=x,mx=0,mn=1e9;    while (y)    {        int res=y%10;        mx=max(mx,res);        if (res) mn=min(mn,res);        y/=10;    }    if (dfs(x-mx) &amp;&amp; dfs(x-mn)) f[x]=0;    else f[x]=1;    return f[x];}int main(){    t=read();    memset(f,-1,sizeof(f));    f[0]=0;    while (t--)    {        n=read();        if (dfs(n)) printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    }    return 0;}</code></pre><h3 id="D1T2-n染色-color"><a href="#D1T2-n染色-color" class="headerlink" title="D1T2 n染色(color)"></a>D1T2 n染色(color)</h3><p>我在考场上推了整整两张草稿纸也没搞出个什么名堂，虽然似乎在数学上是个对的结论，但全部TLE。</p><p>正解就是个dp，$ f[i][j][k] $ 表示画到第i条边，用的是颜色j，上一条边的颜色是k。很显然，对于100%的数据肯定爆。</p><p>优化就是将后两维看成一个矩阵，因为不管是画到第几条边后两维的转移都是一样的，然后矩阵快速幂就行了。</p><p>代码先咕咕咕了，我真的会补上的。</p><p>先放个标程吧，我有时间再写。</p><pre><code class="lang-cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 55,Mo = int(1e9) + 7;typedef long long LL;typedef int Matrix[MAXN][MAXN];Matrix G,F,Tmp;LL N;int M;void Mul(Matrix &amp;a,Matrix &amp;b,Matrix &amp;c){    for(int i = 0;i &lt; M;i ++)        for(int j = 0;j &lt; M;j ++)            Tmp[i][j] = 0;    for(int i = 0;i &lt; M;i ++)        for(int k = 0;k &lt; M;k ++)        if (a[i][k])            for(int j = 0;j &lt; M;j ++)            if (b[k][j])                Tmp[i][j] = (Tmp[i][j] + a[i][k] * 1ll * b[k][j]) % Mo;    for(int i = 0;i &lt; M;i ++)        for(int j = 0;j &lt; M;j ++)            c[i][j] = Tmp[i][j];}int main(){    freopen(&quot;color.in&quot;,&quot;r&quot;,stdin);    scanf(&quot;%lld%d&quot;, &amp;N, &amp;M);    for(int i = 0;i &lt; M;i ++)        for(int j = 0;j &lt; M;j ++)            if (i != j)                G[i][j] = 1;    for(int i = 1;i &lt; M;i ++) F[0][i] = 1;    N -= 2;    for(;N;N &gt;&gt;= 1)    {        if (N &amp; 1) Mul(F,G,F);        Mul(G,G,G);    }    int ans = 0;    for(int i = 1;i &lt; M;i ++) ans = (ans + F[0][i]) % Mo;    printf(&quot;%d\n&quot;, ans * 1ll * M % Mo);    return 0;}</code></pre><h3 id="D1T3-Stree-stree"><a href="#D1T3-Stree-stree" class="headerlink" title="D1T3 Stree(stree)"></a>D1T3 Stree(stree)</h3><p>这道题是这套题唯一一道我有AC代码的题，不过我是在测完后20分钟后才A的。</p><p>对于30%的数据，很容易想到直接暴力。当然，我们也可以预处理一遍最小生成树，如果这条边在树里就直接输出，否则在跑一遍最小生成树。</p><p>其实这样我们就已经完成了正解的第一步了，也就是预处理最小生成树，而且在树里就直接输出。如果这条边不在最小生成树里，就意味着我们需要加上这条边，并且一定要删掉一条在树里的边。我们设加上的这条边的两端点为u和v，那么加上这条边后就一定会以这条边和u和v之前在树里的路径形成一个环，我们只需要在u和v原来的路径里找到一条边删掉就行了。</p><p>为了让权值和最小，我们肯定会选择删u和v路径中最大的边。这里可以用倍增LCA之类的方法解决，我用的是树剖。一般涉及到LCA的问题我都用树剖，主要是常数小。</p><blockquote><p>树剖详解传送门: <a href="https://llf0703.com/p/shu-lian-pou-fen.html">https://llf0703.com/p/shu-lian-pou-fen.html</a></p></blockquote><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define ll long longusing namespace std;inline ll read(){    char ch=getchar();    ll f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct Edge{    ll stat,end,w,id;} edge[200005];struct Edge2{    ll next,to,w,id;} e[400005];struct Tree{    ll left,right,mx;} tree[800005];ll fa[200005],n,m,cnt=1,dfsord,head[200005],deep[200005],w[200005],wnew[200005],id[200005],f[200005],son[200005],top[200005],siz[200005];bool intree[200005];inline bool cmp(Edge x,Edge y) //第一次按边权从大到小{    return x.w&lt;y.w;}inline bool cmp2(Edge x,Edge y) //第二次按原来顺序还原{    return x.id&lt;y.id;}ll getfa(ll x){    if (x==fa[x]) return fa[x];    fa[x]=getfa(fa[x]);    return fa[x];}inline void add(ll u,ll v,ll w){    e[cnt].to=v;    e[cnt].w=w;    e[cnt].next=head[u];    head[u]=cnt++;}inline void pushup(int x) //线段树{    tree[x].mx=max(tree[x*2].mx,tree[x*2+1].mx);}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    if (r-l==1) tree[x].mx=wnew[l];    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        pushup(x);    }}ll query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].mx;    else    {        ll ans=0,mid=(tree[x].left+tree[x].right)/2;        if (l&lt;mid) ans=max(ans,query(x*2,l,r));        if (r&gt;mid) ans=max(ans,query(x*2+1,l,r));        return ans;    }}void dfs1(int x,int fath,int dep){    f[x]=fath;    deep[x]=dep;    siz[x]=1;    int mx=-1;    for (int i=head[x];i;i=e[i].next)    {        int y=e[i].to;        if (y==fath) continue;        w[y]=e[i].w;        dfs1(y,x,dep+1);        siz[x]+=siz[y];        if (siz[y]&gt;mx)        {            mx=siz[y];            son[x]=y;        }    }}void dfs2(int x,int topf){    top[x]=topf;    id[x]=++dfsord;    wnew[dfsord]=w[x];    if (!son[x]) return;    dfs2(son[x],topf);    for (int i=head[x];i;i=e[i].next)    {        int y=e[i].to;        if (y==f[x] || y==son[x]) continue;        dfs2(y,y);    }}inline ll qRangeMax(int u,int v) //查找路径最大{    ll ans=0;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        ans=max(ans,query(1,id[top[u]],id[u]+1));        u=f[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    ans=max(ans,query(1,id[u]+1,id[v]+1));    return ans;}int main(){    freopen(&quot;stree.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;stree.out&quot;,&quot;w&quot;,stdout);    ll ans=0;    n=read(); m=read();    for (int i=1;i&lt;=m;i++)     {        edge[i].stat=read(); edge[i].end=read(); edge[i].w=read();        edge[i].id=i;    }    sort(edge+1,edge+m+1,cmp);    for (int i=1;i&lt;=n;i++) fa[i]=i;    for (int i=1;i&lt;=m;i++)    {        ll st=edge[i].stat,ed=edge[i].end,w=edge[i].w;        ll gfa=getfa(st),gfb=getfa(ed);        if (gfa==gfb) continue;        fa[gfa]=gfb; //最小生成树过程        ans+=w;        intree[edge[i].id]=1; //判断是否已在树里        add(st,ed,w);        add(ed,st,w);    }    dfs1(1,0,1);    dfs2(1,1);    build(1,1,n+1);    sort(edge+1,edge+m+1,cmp2);    for (int i=1;i&lt;=m;i++)    {        if (intree[i]) //在树里直接输出        {            printf(&quot;%lld\n&quot;,ans);            continue;        }        ll st=edge[i].stat,ed=edge[i].end,w=edge[i].w,mx;        mx=qRangeMax(st,ed);        printf(&quot;%lld\n&quot;,ans-mx+w);    }    fclose(stdin);    fclose(stdout);    return 0;}</code></pre><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>每天都有人催我写，我还是今天把它赶出来吧。咕咕咕？</p><h3 id="D2T1-景点中心-scene"><a href="#D2T1-景点中心-scene" class="headerlink" title="D2T1 景点中心(scene)"></a>D2T1 景点中心(scene)</h3><p>题目链接: <a href="https://vijos.org/p/1487" target="_blank" rel="noopener">https://vijos.org/p/1487</a></p><p>其实这道题很水，稍微推一下就可以出来，我在考场上不知道是脑子抽了还是怎么的竟然打了树剖。</p><p>我们一开始可以直接将1号点作为集合点，然后用一遍dfs将每个点到一号点的耗费算出来。我们在这里用<code>dis[]</code>表示。</p><p>很容易得到，对于每一个节点x的子节点y，所有点到它集合的耗费和<code>dis[y]</code>可以用如下的式子算出来：</p><blockquote><p><code>s[i]</code> 代表第i个点的人数</p></blockquote><pre><code class="lang-cpp">dis[y]=dis[x]+w*(s[1]-2*s[y]);</code></pre><p>然后再跑一遍dfs就行了。当然树上dp也可以做，但我dp太菜了就没写。</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;inline ll read(){    char ch=getchar();    ll f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct Edge{    ll next,to,w;} edge[200005];ll head[100005],dis[100005],n,m,a,b,c,cnt=1,s[100005];inline void add(int u,int v,int w){    edge[cnt].to=v;    edge[cnt].next=head[u];    edge[cnt].w=w;    head[u]=cnt++;}void dfs1(int x,int f){    for (int i=head[x];i;i=edge[i].next)    {        ll y=edge[i].to,w=edge[i].w;        if (y==f) continue;        dfs1(y,x);        s[x]+=s[y];        dis[x]+=dis[y]+s[y]*w;    }}void dfs2(int x,int f){    for (int i=head[x];i;i=edge[i].next)    {        ll y=edge[i].to,w=edge[i].w;        if (y==f) continue;        dis[y]=dis[x]+w*(s[1]-2*s[y]);        dfs2(y,x);    }}int main(){    n=read();    for (int i=1;i&lt;=n;i++) s[i]=read();    for (int i=1;i&lt;n;i++)    {        a=read(); b=read(); c=read();        add(a,b,c);        add(b,a,c);    }    dfs1(1,0);    dfs2(1,0);    ll mn,mnsum=1e18;    for (int i=1;i&lt;=n;i++)    {        if (dis[i]&lt;mnsum)        {            mnsum=dis[i];            mn=i;        }    }    printf(&quot;%lld\n%lld&quot;,mn,mnsum);    return 0;}</code></pre><h3 id="D2T2-方格游戏-fang"><a href="#D2T2-方格游戏-fang" class="headerlink" title="D2T2 方格游戏(fang)"></a>D2T2 方格游戏(fang)</h3><p>大水题，就是道入门难度的题强行套一个高精。</p><p>递推式如下:</p><pre><code class="lang-cpp">if (j==0) dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][2];else if (j==1) dp[i][j]=dp[i-1][0]+dp[i-1][1];else if (j==2) dp[i][j]=dp[i-1][0]+dp[i-1][2];</code></pre><p>其实这道题用<code>__uint128_t</code>就可以刚好水过。如果只知道<code>__int128</code>的话到100就会爆，但是大样例给了100，那么就可以特判水过了。</p><p>只是<code>__uint128_t</code>和<code>__int128</code>需要自己写个输出，不过写过快速io的话那就没什么问题。</p><pre><code class="lang-cpp">void print(__uint128_t x){    if (x==0) return;    print(x/10);    putchar(x%10+&#39;0&#39;);}</code></pre><p>这个东西只有64位系统下的gcc可以用，至于32位的ccf老爷机就别想了。<del>我怎么感觉扯了这么多废话。</del></p><p>这道题大家都AC了，就不放代码了。</p><h3 id="D2T3-运算符-calc"><a href="#D2T3-运算符-calc" class="headerlink" title="D2T3 运算符(calc)"></a>D2T3 运算符(calc)</h3><p>提交这道题请至: <a href="https://www.luogu.org/problemnew/show/U44496" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/U44496</a></p><blockquote><p>说明：版权不归我所有，此题上传仅为学习，若有侵权请联系我删除</p></blockquote><p>其实也很水，只需要掌握线性筛即可。就算不会线性筛小于1000的最多也就168个质数，打表即可。</p><p>我们用 $ f[i][j][k] $ 表示 $ i!j $ 中第k个质数的个数。递推式就是：</p><script type="math/tex; mode=display">f[i][j][k]=(f[i-1][j][k]+f[i][j-1][k])%ha</script><p>初始值就是分解一下每个i，然后将结果存入<code>*f[i][0]</code>中即可。</p><pre><code class="lang-cpp">inline void work(ll x){    ll y=x;    for (int i=1;i&lt;=cnt &amp;&amp; zs[i]&lt;=y;i++)    {        while (x%zs[i]==0)        {            f[y][0][i]++;            x/=zs[i];        }    }}for (int i=1;i&lt;=n;i++)    work(i);</code></pre><p>全部代码：</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define ll long long#define ha 1000000009using namespace std;inline ll read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}bool ss[1005];int zs[170],cnt,n,k,f[1005][105][170],mx;inline void getprime(){    memset(ss,1,sizeof(ss));    ss[0]=ss[1]=0;    for (int i=2;i&lt;=mx;i++)    {        if (ss[i]) zs[++cnt]=i;        for (int j=1;j&lt;=cnt &amp;&amp; zs[j]*i&lt;=mx;j++)        {            ss[zs[j]*i]=0;            if (i%zs[j]==0) break;        }    }}inline void work(ll x){    ll y=x;    for (int i=1;i&lt;=cnt &amp;&amp; zs[i]&lt;=y;i++)    {        while (x%zs[i]==0)        {            f[y][0][i]++;            x/=zs[i];        }    }}int main(){    n=read(); k=read();    mx=max(n,k);    getprime();    for (int i=1;i&lt;=n;i++)        work(i);    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=k;j++)            for (int k=1;k&lt;=cnt;k++)                f[i][j][k]=(f[i][j-1][k]+f[i-1][j][k])%ha;    ll ans=1;    for (int i=1;i&lt;=cnt;i++)         ans=(ans*(f[n][k][i]+1))%ha;    printf(&quot;%lld&quot;,ans);    return 0;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两天题都很水，除了D1T3需要点简单的数据结构以外都是<code>PJ</code>难度的水题。但是每道题思维难度都比较高，都很难想到，或者说想复杂了（像我）。</p><p>我感觉可能noip就像这样，看了题解都会打，但是真正考场上能想出来并且能够AC的人又有多少呢？一直都是只要把暴力打好，打稳，并不需要学多少的辣鸡数据结构就可以拿一等奖甚至是高分。</p><p>所以我不应该再去搞些神仙算法和数据结构了，而就是应该把基础练稳练熟练扎实，争取每一次把自己能力所能拿到的分都拿到，我相信这样的成绩也一定会令人满意了。<del>当然先过初赛最重要。</del></p><p>最后用一句lxl大佬的名言作结：</p><blockquote><p>不要沉迷数据结构，会退役的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛-模拟题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>近期做的几道搜索题的总结</title>
      <link href="/p/search-summary-201809.html"/>
      <url>/p/search-summary-201809.html</url>
      
        <content type="html"><![CDATA[<p>我前段时期刷紫书才发现我搜索实在是菜的一匹，近期就在做这方面的题。今天突然有觉得自己该发一篇文章了，于是就有了这个。</p><h2 id="洛谷P1379-八数码难题"><a href="#洛谷P1379-八数码难题" class="headerlink" title="洛谷P1379 八数码难题"></a><a href="https://www.luogu.org/problemnew/show/P1379" target="_blank" rel="noopener">洛谷P1379 八数码难题</a></h2><p>这道题其实并不是太难，<del>说到这我想起了一位已经AFO搞物竞的同学花了三个月改了九个版本真正纯种暴搜最后拿了15的故事</del>，主要难点集中在判重。这里我用的是康托展开。</p><p>康托展开是用来求在n个数的 所有排列组合中 某种排列组合的编号(就是从小到大的第几个)。</p><p>公式是</p><script type="math/tex; mode=display">X=a[n] \times (n-1)! + a[n-1] \times (n-2)! +...+ a[1] \times 0!</script><blockquote><p><code>a[i]</code>表示第i个元素在未出现的元素(即第i~n位的数字中)中排列第几(也就是求后面有几个数字比ai小)</p></blockquote><p>看公式其实原理就比较清楚了，下面就放个代码(求数列s的康托展开值)</p><pre><code class="lang-cpp">inline int get_hash(int *s){    int ans=0;    for (int i=1;i&lt;=9;i++)    {        int sm=0;        for (int j=i+1;j&lt;=9;j++)            if (s[j]&lt;s[i]) sm++;        ans+=fac[8-i+1]*sm;    }    return ans;}</code></pre><p>整道题的代码我自己觉得还是很清晰的，就直接放代码吧</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct MP{    int s[10],id,x0,y0;};int vis[370005]; //vis[]始终标记的是康托展开值int fac[]={1,1,2,6,24,120,720,5040,40320},fx[4]={0,1,0,-1},fy[4]={1,0,-1,0};int mp[4][4],ans[10]={0,1,2,3,8,0,4,7,6,5};inline int get_hash(int *s) //康托展开值{    int ans=0;    for (int i=1;i&lt;=9;i++)    {        int sm=0;        for (int j=i+1;j&lt;=9;j++)            if (s[j]&lt;s[i]) sm++;        ans+=fac[8-i+1]*sm;    }    return ans;}inline int to_line(int x,int y) //将二维坐标转换为一维{    return (x-1)*3+y;}inline void bfs(int stx,int sty){    queue &lt;MP&gt; q;    MP stat;    stat.x0=stx; stat.y0=sty;    for (int i=1;i&lt;=3;i++)        for (int j=1;j&lt;=3;j++)            stat.s[to_line(i,j)]=mp[i][j];    stat.id=get_hash(stat.s);    vis[stat.id]=1; //为了标记把初始值设为1，最后-1即可    q.push(stat);    while (!q.empty())    {        MP x=q.front(); q.pop();        int mapp[10];        for (int i=1;i&lt;=9;i++) mapp[i]=x.s[i]; //复制一份        for (int i=0;i&lt;4;i++)        {            int tx=x.x0+fx[i],ty=x.y0+fy[i];            if (tx&gt;3 || tx&lt;1 || ty&gt;3 || ty&lt;1) continue; //越界退出            int newpos=to_line(tx,ty),pos=to_line(x.x0,x.y0); //当前空格的位置和将要与之交换的位置            swap(mapp[pos],mapp[newpos]);            int new_hash=get_hash(mapp); //得到新的康托展开值            if (vis[new_hash])            {                swap(mapp[pos],mapp[newpos]); //不满足需要换回来                continue;            }            bool is_ans=1; //是否找到答案            MP y; //下面是完善拓展结点的信息            y.x0=tx; y.y0=ty;            y.id=new_hash;            for (int j=1;j&lt;=9;j++)             {                y.s[j]=mapp[j];                if (mapp[j]!=ans[j]) is_ans=0;            }            vis[y.id]=vis[x.id]+1; //vis[]顺便记录答案            if (is_ans) return;            q.push(y);            swap(mapp[pos],mapp[newpos]);        }    }}int main(){    char x[10];    int s[10];    scanf(&quot;%s&quot;,x);    int cnt=-1,stx,sty;    for (int i=1;i&lt;=3;i++)    {        for (int j=1;j&lt;=3;j++)        {            mp[i][j]=x[++cnt]-&#39;0&#39;;            if (mp[i][j]==0) stx=i,sty=j; //得到初始空格位置        }    }    bfs(stx,sty);    int anshash=get_hash(ans);    printf(&quot;%d&quot;,vis[anshash]-1); //最后-1，理由见上    return 0;}</code></pre><h2 id="洛谷P1074-靶形数独"><a href="#洛谷P1074-靶形数独" class="headerlink" title="洛谷P1074 靶形数独"></a><a href="https://www.luogu.org/problemnew/show/P1074" target="_blank" rel="noopener">洛谷P1074 靶形数独</a></h2><p>这题其实评分虚高，于是我又打了个入门难度平衡了一下。<del>说的好像我有不打入门难度的题一样</del></p><p>刚开始看这评分还以为要用特殊的搜索方法+各种剪枝，事实上纯暴搜就有70，稍微改变下搜索顺序就AC了。</p><p>就跟真正的数独一样，我们要从已经填了的数字最多的那一行开始填。所以我们事先排个序，搜索时按照从多到少的顺序搜索即可。</p><p>值得一提的是我刚开始统计填了多少个数字时根本没有判断是不是0(也就意味着每一行都一样)都得了70分，不过很玄学的是开了O2以后就爆0了。所以这道题真的很水，大概普及难度就差不多了。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int mp[10][10],ans;bool vis[3][10][10];//0横，1竖，2九宫格int score[10][10]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};struct line{    int num,id;} l[10];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline int nine(int x,int y) //得到所在的九宫格编号{    return (x-1)/3*3+(y-1)/3+1;}void dfs(int id,int y){    int x=l[id].id; //得到从大到小第id行的行数    if (id==10) //搜完了统计答案    {        int now=0;        for (int j=1;j&lt;=9;j++)            for (int k=1;k&lt;=9;k++)                now+=mp[j][k]*score[j][k];        ans=max(ans,now);        return;    }    if (y==10) //搜到最后一列后继续搜下一行    {        dfs(id+1,1);        return;    }    if (mp[x][y]) //已经填了，继续搜    {        dfs(id,y+1);        return;    }    for (int i=1;i&lt;=9;i++) //没填就填个数再搜    {        if (vis[0][x][i] || vis[1][y][i] || vis[2][nine(x,y)][i]) continue;        vis[0][x][i]=1;        vis[1][y][i]=1;        vis[2][nine(x,y)][i]=1;        mp[x][y]=i;        dfs(id,y+1);        vis[0][x][i]=0;        vis[1][y][i]=0;        vis[2][nine(x,y)][i]=0;        mp[x][y]=0;    }    return;}inline bool cmp(line x,line y){    return x.num&gt;y.num;}int main(){    for (int i=1;i&lt;=9;i++)    {        l[i].id=i;        for (int j=1;j&lt;=9;j++)         {            mp[i][j]=read();            if (mp[i][j]) l[i].num++; //统计已填个数            vis[0][i][mp[i][j]]=1;            vis[1][j][mp[i][j]]=1;            vis[2][nine(i,j)][mp[i][j]]=1;        }    }    sort(l+1,l+10,cmp); //从大到小排序    ans=-1; //如果搜不到即无解就输出-1    dfs(1,1);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h2 id="洛谷P1120-小木棍"><a href="#洛谷P1120-小木棍" class="headerlink" title="洛谷P1120 小木棍"></a><a href="https://www.luogu.org/problemnew/show/P1120" target="_blank" rel="noopener">洛谷P1120 小木棍</a></h2><p>练习这道题对剪枝技能的提升很大，值得一刷。</p><p>总的来说这道题就是暴搜+各种神奇的剪枝。</p><p>搜索的思路就是先得到所有木棍的总长度，然后枚举各个可能的长度即能被总长度整除的长度，并以之进行搜索。当然事先需要将所有木棍从大到小排序，这样能加快搜索速度。</p><p>于是得到纯暴搜代码：</p><blockquote><p><code>len</code>是当前枚举到的可能长度，<code>num</code>是有多少根，可以用总长度/可能长度得到，<code>id</code>是搜索到了第几根，<code>sum</code>是搜索到的当前的和</p></blockquote><pre><code class="lang-cpp">bool dfs(int len,int num,int id,int sum){    if (sum==len)     {        if (id==num) return 1;        else return dfs(len,num,id+1,0);    }    int i=1;    while (len-sum&lt;s[i]) i++; //跳过放不下的    bool can=0;    for (;i&lt;=n;i++)    {        if (vis[i]) continue;        vis[i]=1;        can=dfs(len,num,id,sum+s[i]);        if (can) return 1;        vis[i]=0;    }    return 0;}</code></pre><p>这个代码得了33分。于是考虑优化，我加了一句</p><pre><code class="lang-cpp">if (len-sum-s[i]&lt;mn &amp;&amp; len!=sum+s[i]) break;</code></pre><p>就是剩下的长度连最小的都放不下了就直接退出，相当于可以少搜索一层。现在39分了。但是后来发现这句话有些bug会导致WA于是就没用了。</p><p>我还是太菜了，只有去看题解。题解中写到当前搜索应该从上一次搜索用的下一根木棍开始搜。仔细一想，这样可以保证之前用的比后面用的木棍都大，可以去除很多重复。于是我就加了个last变量，下一次搜索从last+1开始。同时我自己还想到如果已经搜了<code>num-1</code>根了那么剩下的一定可以组成最后一根了，于是可以少搜一层，不过似乎并没有太大的作用。</p><p>现在搜索变成了这样：</p><pre><code class="lang-cpp">bool dfs(int len,int num,int id,int sum,int last){    if (sum==len)     {        if (id==num-1) return 1; //那个并没有什么卵用的优化        else return dfs(len,num,id+1,0,0);    }    bool can=0;    int i=last+1;    while (len-sum&lt;s[i]) i++; //从last+1开始    for (;i&lt;=n;i++)    {        if (vis[i]) continue;        if (len-sum-s[i]&lt;mn &amp;&amp; len!=sum+s[i]) break;        vis[i]=1;        can=dfs(len,num,id,sum+s[i],i);        if (can) return 1;        vis[i]=0;    }    return 0;}</code></pre><p>现在有了48分了。</p><p>我突然想到，<code>i</code>只是代表第几个，如果有重复的长度的话仅仅+1就会搜索很多次重复的情况。于是我事先预处理了一个<code>nxt[]</code>数组，表示排序后第一个与第<code>i</code>位不同的数在第几位：</p><pre><code class="lang-cpp">for (int i=n-1;i;i--){    if (s[i]==s[i+1]) nxt[i]=nxt[i+1];    else nxt[i]=i+1;}</code></pre><p>搜索中的枚举步骤变成了这样：</p><pre><code class="lang-cpp">while (i&lt;=n){    if (vis[i])     {        i++;        continue;    }    vis[i]=1;    can=dfs(len,num,id,sum+s[i],i);    if (can) return 1;    vis[i]=0;    i=nxt[i];}</code></pre><p>现在57分了。我是真的没办法了，又去看了题解。接下来可谓是最重要的优化了：</p><blockquote><p>对于每一次枚举，如果拼接失败，而且 <strong>当前已拼接的长度为0 或者 当前枚举的木棍长度=剩余未拼接长度</strong> ，则停止枚举，直接退出循环。</p></blockquote><p>感觉这个优化很难理解，更难想到，不过仔细想想还是比较容易理解的。</p><p>我们可以逆向来想一下。之所以退出循环，肯定是因为上一根拼的根本就不行。</p><p>如果当前已拼接的长度是0，那么当前枚举的木棍，肯定要在<strong>当前拼接的组</strong>用上。因为它必定会出现在剩下的任意一个组里，而如果当前拼接的是0，那么它出现在剩下的哪个组其实都一样。而如果拼接失败，则代表它拼在哪个组都不行，所以上一根就没对，直接退出。</p><p>如果当前枚举的木棍长度=剩余未拼接长度，那么把当前的这根拼上其实就转化为上面的情况了，所以同理。</p><p>总结一下所有优化：</p><ol><li>事先排序，搜索时从大到小搜</li><li>每次枚举从上一次搜索用的下一根木棍开始搜</li><li>预处理<code>nxt[]</code>数组，跳过重复</li><li>如果拼接失败，而且当前已拼接的长度为0 或者 当前枚举的木棍长度=剩余未拼接长度 ，则停止枚举，直接退出循环</li></ol><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int s[70],len[70],n,ans,mn,nxt[70];bool vis[70];inline bool cmp(int x,int y){    return x&gt;y;}bool dfs(int len,int num,int id,int sum,int last){    if (sum==len)     {        if (id==num-1) return 1;        else return dfs(len,num,id+1,0,0);    }    bool can=0;    int i=last+1; //优化2    while (len-sum&lt;s[i]) i=nxt[i];    while (i&lt;=n)    {        if (vis[i])         {            i++;            continue;        }        vis[i]=1;        can=dfs(len,num,id,sum+s[i],i);        if (can) return 1;        vis[i]=0;        if (sum==0 || sum+s[i]==len) break; //优化4        i=nxt[i];    }    return 0;}int main(){    n=read();    int cnt=0,sum=0,mx=0;    for (int i=1;i&lt;=n;i++)    {        int a=read();        if (a&gt;50) continue;         s[++cnt]=a;        sum+=a;    }    n=cnt;    sort(s+1,s+cnt+1,cmp); //优化1    mx=s[1]; mn=s[n];    int lcnt=0;    for (int i=mx;i*2&lt;=sum;i++)    {        if (sum%i) continue;        len[++lcnt]=i;    }    nxt[n]=n+1;    for (int i=n-1;i;i--) //优化3    {        if (s[i]==s[i+1]) nxt[i]=nxt[i+1];        else nxt[i]=i+1;    }    ans=sum;//全部拼成一根    for (int i=1;i&lt;=lcnt;i++)    {        if (dfs(len[i],sum/len[i],1,0,0))        {            ans=len[i];            break;        }    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h2 id="洛谷P1378-油滴扩展"><a href="#洛谷P1378-油滴扩展" class="headerlink" title="洛谷P1378 油滴扩展"></a><a href="https://www.luogu.org/problemnew/show/P1378" target="_blank" rel="noopener">洛谷P1378 油滴扩展</a></h2><p>裸的搜索。唯一需要注意的是如果两点距离&lt;0的话需要把最大半径取成0。还有最好全部用<code>double</code>，否则最大的那组数据可能有精度问题。</p><p>还有就是<code>double</code>输出应该用<code>%f</code>，cyc大佬某天WA掉就是因为用了<code>%lf</code>输出。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define pi acos(-1)using namespace std;double lx,rx,uy,dy;int cur[10],n;struct point{    double x,y,len;} pt[10];bool vis[10];inline double dis(int x1,int y1,int x2,int y2){    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}double dfs(int x){    if (x==n+1) return 0;    double mx=0;    for (int i=1;i&lt;=n;i++)    {        if (vis[i]) continue;        cur[x]=i;        vis[i]=1;        double lmax=min(min(pt[i].x-lx,rx-pt[i].x),min(pt[i].y-dy,uy-pt[i].y)); //距离四条边的最短距离        for (int j=1;j&lt;x;j++)        {            double d=dis(pt[i].x,pt[i].y,pt[cur[j]].x,pt[cur[j]].y);            lmax=min(lmax,max(d-pt[cur[j]].len,0.0)); //距离每个点的最小距离        }        pt[i].len=lmax;        double ans=pi*lmax*lmax+dfs(x+1);        vis[i]=0;        pt[i].len=0;        mx=max(mx,ans);    }    return mx;}int main(){    scanf(&quot;%d&quot;,&amp;n);    double x,y,xx,yy;    scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;xx,&amp;yy);    lx=min(x,xx); rx=max(x,xx); uy=max(y,yy); dy=min(y,yy);    for (int i=1;i&lt;=n;i++) scanf(&quot;%lf%lf&quot;,&amp;pt[i].x,&amp;pt[i].y);    double s=(rx-lx)*(uy-dy);    printf(&quot;%.0f&quot;,s-dfs(1)); // double输出用%f!    return 0;}</code></pre><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息学科普基地Noip2017%你题第二试总结</title>
      <link href="/p/contest-summary-1.html"/>
      <url>/p/contest-summary-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><iframe src="https://cdn.uniqueue.cn/contest1.pdf" width="100%" height="800px" scroll="no"></iframe><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1-爬山-mountain"><a href="#1-爬山-mountain" class="headerlink" title="1.爬山(mountain)"></a>1.爬山(mountain)</h3><p>水题，直接搜索即可。</p><p>需要注意的是要用一个<code>vis</code>数组记录是否走过，否则在相等的时候会在两者之间不停地走下去，最后爆炸。<del>我就是因为这个原因只有90分</del></p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int h[205][205],n,m,sx,sy,fx[4]={0,1,0,-1},fy[4]={1,0,-1,0},ans;bool vis[205][205];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}void dfs(int x,int y){    vis[x][y]=1;    bool hier=0;    for (int i=0;i&lt;4;i++)    {        int tx=x+fx[i],ty=y+fy[i];        if (!vis[tx][ty] &amp;&amp; h[tx][ty]&gt;=h[x][y])        {            hier=1;            dfs(tx,ty);        }    }    if (!hier) ans=max(ans,h[x][y]);    return;}int main(){    freopen(&quot;mountain.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;mountain.out&quot;,&quot;w&quot;,stdout);    n=read(); m=read(); sx=read(); sy=read();    memset(h,-1,sizeof(h));    for (int i=1;i&lt;=n;i++)        for (int j=1;j&lt;=m;j++)            h[i][j]=read();    dfs(sx,sy);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h3 id="2-字符串距离-string"><a href="#2-字符串距离-string" class="headerlink" title="2.字符串距离(string)"></a>2.字符串距离(string)</h3><p>这道题暴力就可以70 <del>要什么正解系列</del></p><p>这道题的正解其实是找规律。显而易见，对于 $ T $ 中每个元素，它都会与 $ S $ 中的部分元素进行比较，只要确定与哪些元素比较即可。</p><p>下面就来推一下：</p><pre><code>S: a a a b bT: b a ba[1]: {1}a[2]: {2}a[3]: {3}</code></pre><p>这是最开始的情况，其中<code>a[i]</code>代表 $ T $ 中第i个元素需要在 $ S $ 中比较哪几个元素。</p><pre><code>S: a a a b bT:   b a ba[1]: {1,2}a[2]: {2,3}a[3]: {3,4}</code></pre><p>往后推一步。</p><pre><code>S: a a a b bT:     b a ba[1]: {1,2,3}a[2]: {2,3,4}a[3]: {3,4,5}</code></pre><p>其实这个测试数据有点误导性，我一开始就搞错了。下面换一组数据再来推一下：</p><pre><code>S: a a a b b b bT: b a b b aa[1] {1,2,3}a[2] {2,3,4}a[3] {3,4,5}a[4] {4,5,6}a[5] {5,6,7}</code></pre><p>完了。规律应该是显而易见了吧，对于 $ S $ 中第 $ i $ 个元素，它要与 $ T $ 中第 $ i $ ~ $ i+S.length()-T.length() $ 这些元素进行比较。之所以说容易被误导就是搞错成 $ i $ ~ $ i+T.length()-1 $ 进行比较。</p><p>我们可以用一个变量<code>sum</code>来记录当前长度为 $ S.length()-T.length()+1 $ 的区间内 $ a $ 的个数。当我们把 $ T $ 中元素往后推时，将区间同时后移一位。而区间中 $ a $ 的个数的变化只会发生在第 $ i-1 $ 和 $ i+T.length() $ 这两个元素中发生，只需要对应加减即可。</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int main(){    freopen(&quot;string.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;string.out&quot;,&quot;w&quot;,stdout);    string s,t;    cin&gt;&gt;s&gt;&gt;t;    int ls=s.length(),lt=t.length();    int sum=0,ans=0,len=ls-lt+1;    for (int i=0;i&lt;len;i++)        if (s[i]==&#39;a&#39;) sum++;    int j=0;    if (t[j]==&#39;a&#39;) ans+=len-sum;    else ans+=sum;    for (int i=len;i&lt;ls;i++)    {        if (s[i]==&#39;a&#39;) sum++;        if (s[i-len]==&#39;a&#39;) sum--;        j++;        if (t[j]==&#39;a&#39;) ans+=len-sum;        else ans+=sum;    }    printf(&quot;%d&quot;,ans);    fclose(stdin);    fclose(stdout);    return 0;}</code></pre><h3 id="跳石头-stone"><a href="#跳石头-stone" class="headerlink" title="跳石头(stone)"></a>跳石头(stone)</h3><p>先 STO cyc大佬。</p><p>据大佬们说两次LIS+贪心就可以80分，但我却爆0了，果然还是太蒻了。</p><p>cyc大佬给我们讲了一个玄学的做法，至今也没有证明，不过就是能过这道题。而且仔细想想好像也挺有道理，也举不出反例来，所以就把它暂时当作正解吧。</p><p>解法就是维护两个数组<code>s1[]</code>和<code>s2[]</code>。对于每一个石头<code>s[i]</code>,如果它大于<code>s1[]</code>中的最后一个元素，则把他加在后面；否则就在<code>s1[]</code>中找到一个它能够替换的值，并把它放进去。</p><p>能被替换的元素就是刚好要比当前石头<code>s[i]</code>大一些，而且加进去以后不会影响<code>s1[]</code>中单调性的元素，即 被替换元素 的前一个元素要小于<code>s[i]</code>。因为可以保证的是<code>s1[]</code>一定单增，所以这个被替换元素可以通过二分来查找到。</p><p>然后，将当前石头放入<code>s1[]</code>，然后将被替换的元素当作当前的石头与<code>s2[]</code>进行操作，与<code>s1[]</code>的操作同理。</p><p>最后，<code>s1[]</code>和<code>s2[]</code>中元素个数之和即为答案。</p><hr><p>我刚写完cyc大佬就给我讲了证明方法，虽然不能严格证明，但是大致可以明白这个算法的道理。</p><p>大致这些操作可以分为两种情况：</p><blockquote><p>对于每一个石头<code>s[i]</code>,如果它大于<code>s1[]</code>中的最后一个元素，则把他加在后面</p></blockquote><p>这种情况下就可以将答案+1，没有任何问题</p><blockquote><p>否则就在<code>s1[]</code>中找到一个它能够替换的值，并把它放进去</p></blockquote><p>我最开始就产生了疑问：<code>s[i]</code>的位置是肯定在此前就加进去的元素的后面的，如果用它替换掉中间一个值怎么行呢？</p><p>其实，在这种情况下，答案是没有变化的。所以，我们其实<strong>并没有更新答案</strong>，这就是理解这种方法的精髓所在。</p><p>当我们将<code>s[i]</code>给替换到 $ left $ 这个位置时，可以保证 $ 1..left $ 这个区间内是真真正正确实可以跳到的石头。前面说过，我们并没有更新答案，所以后面那些元素根本不用管。</p><p>在最后一个元素被替换掉之前，后面即使再加入元素也只是之前情况下的答案+1，和当前情况没有任何关系，所以最后就可以取整个数组的元素个数作为答案；如果当前最后一个元素后来被替换掉了，则证明当前情况并不是最优解，而替换最后一个也不会产生顺序上的任何问题。</p><p>而第二个数组操作和第一个数组相同，证明也就同理了。</p><p>综上，这个算法是正确的，并不是玄学的。不得不感叹这个算法的巧妙性和cyc大佬的强大。</p><hr><p>先放我的长但是自认为好懂些的代码：</p><pre><code class="lang-cpp">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int s[1005],n,m,ans,s1[1005],s2[1005];int main(){    freopen(&quot;stone.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;stone.out&quot;,&quot;w&quot;,stdout);    n=read();    for (int i=1;i&lt;=n;i++) s[i]=read();    int cnt1=0,cnt2=0;    s1[++cnt1]=1;    ans=1;    for (int i=2;i&lt;=n;i++)    {        int x=s1[cnt1];        if (s[i]&gt;=s[x]) s1[++cnt1]=i,ans++; //直接放入，在这里就可以顺便统计ans        else        {            int left; //被替换的元素在s1中的便号，注意不是s中的            int l=1,r=cnt1;            while (l&lt;=r) //二分查找被替换元素            {                int mid=(l+r)/2;                if (s[s1[mid]]&gt;s[i]) left=mid,r=mid-1;                else l=mid+1;            }            int leftpos=s1[left]; //这是被替换元素在s中的编号，用来下面比较大小            s1[left]=i; //将当前石头替换进去            int y=s2[cnt2];            if (s[leftpos]&gt;=s[y]) s2[++cnt2]=leftpos,ans++; //直接放入，统计ans            else            {                int left2; //s2中被替换元素的编号                int l=1,r=cnt2;                while (l&lt;=r)                {                    int mid=(l+r)/2;                    if (s[s2[mid]]&gt;s[leftpos]) left2=mid,r=mid-1;                    else l=mid+1;                }                s2[left2]=leftpos; //替换。因为不需要统计更多的，所以到这就行了            }        }    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>下面放一个cyc大佬极简代码，据他说他还有更短的版本。 %cyc</p><pre><code class="lang-cpp">// By Dalao cyc,%cyc#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define N 5005int n, i, x, t[N]; int q[N][N];void up(int p, int x) {    if (x &gt;= q[p][t[p]]) { q[p][++t[p]] = x; return; }    int l = 1, r = t[p], mid, u;    while (l &lt;= r) {        if (q[p][mid = (l + r) &gt;&gt; 1] &gt; x) {            u = mid; r = mid - 1;        } else {            l = mid + 1;        }    }    up(p + 1, q[p][u]), q[p][u] = x;}int main() {    scanf(&quot;%d&quot;, &amp;n);    for (i = 1; i &lt;= n; ++ i) scanf(&quot;%d&quot;,&amp;x), up(1,x);    for (int i = 1; ; ++ i) {        t[i] += t[i - 1];        if (t[i] == n) break;    }    printf(&quot;%d&quot;, t[2]);    return 0;}</code></pre><p>显而易见，cyc大佬还要统计后续数组的值，时间效率上肯定会差点，空间也会开大点。但是代码又短又巧妙，实在是太强辣！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人的第一次提交只有160，得分为90+70+0，使用的算法的最高得分为100+70+80=250. </p><p>各题总结：</p><ol><li>第一题情况考虑不完整，想到了相等的请况却没想到后续的问题</li><li>第二题没有找出规律，最后暴力没有失分，没什么非知识性的问题</li><li>第三题想到80分做法但写错，应该是对LIS算法的掌握不够熟练</li></ol><p>总体失分原因:</p><ol><li>对细节的思考不够到位</li><li>错误地追求每题AC，导致第二题花了很长时间没想到正解就心态比较爆炸，可能也是第三题爆炸的原因</li><li>对于部分算法掌握还不够熟练，人笨就要多刷题</li></ol><p>总体来说这套题打的不理想，但是也发现了很多问题（我太菜了），所以还是很有价值的。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛-模拟题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>紫书第三章-数组与字符串 刷题总结</title>
      <link href="/p/aoapc-book-3.html"/>
      <url>/p/aoapc-book-3.html</url>
      
        <content type="html"><![CDATA[<p>我太菜了，已经沦落到天天刷水题的地步了。由于实在是太水了，我就只总结个别有价值的题。还有动规那一章迟早会总结完的（gugugu~）</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="3-6-UVa1584-Circular-Sequence"><a href="#3-6-UVa1584-Circular-Sequence" class="headerlink" title="3-6 UVa1584-Circular Sequence"></a>3-6 <a href="https://vjudge.net/problem/UVA-1584" target="_blank" rel="noopener">UVa1584-Circular Sequence</a></h3><p>我一开始以为就是找到最小的那个然后再决定一下左边走还是右边走，后面才发现竟然只有4个字母，肯定有很多重复，而且还只有顺时针，显然这样不行。</p><p>然后做法就跟书上一样了，枚举从每个字母开始的字典序，和当前最优值比较即可。</p><p><del>话说这种水题总结来有什么意义，不过要是不总结我例题就没啥总结的了</del></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;char cir[105];int n,m,a,b,c;int main(){    scanf(&quot;%d&quot;,&amp;n);    while (n--)    {        scanf(&quot;%s&quot;,cir);        int mnid=0,len=strlen(cir);        for (int i=0;i&lt;len;i++)        {            for (int j=0;j&lt;len;j++)            {                if (cir[(i+j)%len]&lt;cir[(mnid+j)%len])                {                    mnid=i;                    break;                }                else if (cir[(i+j)%len]&gt;cir[(mnid+j)%len]) break;            }        }        for (int i=0;i&lt;len;i++)            printf(&quot;%c&quot;,cir[(mnid+i)%len]);        printf(&quot;\n&quot;);    }    return 0;}</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="3-3-UVa1225-Digit-Counting"><a href="#3-3-UVa1225-Digit-Counting" class="headerlink" title="3-3 UVa1225-Digit Counting"></a>3-3 <a href="https://vjudge.net/problem/UVA-1225" target="_blank" rel="noopener">UVa1225-Digit Counting</a></h3><p>似乎网上很多人直接暴力就行，我还离线处理排了一遍序，优化了个log。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,q[25],cnt,ans[10][25],now[10];struct Query{    int q,id;} Q[25];inline void work(int x){    while (x)    {        now[x%10]++;        x/=10;    }}inline bool cmp(Query x,Query y){    return x.q&lt;y.q;}int main(){    cin&gt;&gt;m;    for (int i=1;i&lt;=m;i++)    {        cin&gt;&gt;n;        Q[i].q=n;        Q[i].id=i;    }    sort(Q+1,Q+m+1,cmp);    int j=1,last=-1;    for (int i=1;i&lt;=m;i++)    {        for (;j&lt;=Q[i].q;j++) work(j);        for (int k=0;k&lt;=9;k++) ans[k][Q[i].id]=now[k];    }    for (int i=1;i&lt;=m;i++)    {        for (int j=0;j&lt;=8;j++) cout&lt;&lt;ans[j][i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;ans[9][i]&lt;&lt;endl;    }    return 0;}</code></pre><h3 id="3-5-UVa227-Puzzle"><a href="#3-5-UVa227-Puzzle" class="headerlink" title="3-5 UVa227-Puzzle"></a>3-5 <a href="https://vjudge.net/problem/UVA-227" target="_blank" rel="noopener">UVa227-Puzzle</a></h3><p>我这道题做法大概是这样：</p><ol><li>得到空格最开始位置</li><li>按照题意模拟，如果不合法，则标记后直接continue（否则会有多余输入）</li><li>因为操作有多行，所以每行都需要getline，读到0以后退出即可</li></ol><p>坑点也挺多的，大概如下：</p><ol><li>如果用getline的话最后一个字符如果没有是不会看成空格的，我后来直接改成不是字母就为空格</li><li>操作有多行</li><li>我最开始遇到不合法就直接退出，导致有输入被输到下一次操作</li><li><strong>不合法操作除了越界还有操作不是ABLR！！！</strong></li><li>这道题格式要求很严，注意多余空格和换行都要过滤掉，如果不想PE的话还可以用<a href="https://www.udebug.com/UVa/227" target="_blank" rel="noopener">uDebug</a>测一下</li></ol><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,kase;int main(){    for (;;)    {        string s[5];        getline(cin,s[0]);        int x=0,y=0;        if (s[0][0]==&#39;Z&#39;) break;        if (kase) cout&lt;&lt;endl;        printf(&quot;Puzzle #%d:\n&quot;,++kase);        for (int i=1;i&lt;5;i++) getline(cin,s[i]);        for (int i=0;i&lt;5;i++)        {            for (int j=0;j&lt;5;j++)            {                if (s[i][j]&lt;&#39;A&#39; || s[i][j]&gt;&#39;Z&#39;)                {                    x=i;                    y=j;                    break;                }            }        }        bool done=0;        bool can=1;        for (;;)        {            string q;            getline(cin,q);            for (int i=0;i&lt;q.length();i++)            {                if (q[i]==&#39;0&#39;)                {                    done=1;                    break;                }                if (!can) continue;                else if (q[i]==&#39;A&#39;)                {                    if (x==0) can=0;                    else                    {                        s[x][y]=s[x-1][y];                        s[x-1][y]=&#39; &#39;;                        x--;                    }                }                else if (q[i]==&#39;B&#39;)                {                    if (x==4) can=0;                    else                    {                        s[x][y]=s[x+1][y];                        s[x+1][y]=&#39; &#39;;                        x++;                    }                }                else if (q[i]==&#39;L&#39;)                {                    if (y==0) can=0;                    else                    {                        s[x][y]=s[x][y-1];                        s[x][y-1]=&#39; &#39;;                        y--;                    }                }                else if (q[i]==&#39;R&#39;)                {                    if (y==4) can=0;                    else                    {                        s[x][y]=s[x][y+1];                        s[x][y+1]=&#39; &#39;;                        y++;                    }                }                else can=0;            }            if (done)            {                if (!can) printf(&quot;This puzzle has no final configuration.\n&quot;);                else                {                    for (int i=0;i&lt;5;i++)                    {                        for (int j=0;j&lt;4;j++) cout&lt;&lt;s[i][j]&lt;&lt;&quot; &quot;;                        cout&lt;&lt;s[i][4];                        cout&lt;&lt;&quot;\n&quot;;                    }                }                break;            }        }    }    return 0;}</code></pre><h3 id="3-8-UVa202-Repeating-Decimals"><a href="#3-8-UVa202-Repeating-Decimals" class="headerlink" title="3-8 UVa202-Repeating Decimals"></a>3-8 <a href="https://vjudge.net/problem/UVA-202" target="_blank" rel="noopener">UVa202-Repeating Decimals</a></h3><p>我最开始发现50位的话double肯定不够用啊，然后到网上一看才发现自己zz了。除的过程就跟竖式除法一样 $n \times 10 / m$ 就行了，其它的枚举循环节即可。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c;int s[100005],id[100005];int main(){    while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))    {        memset(s,0,sizeof(s));        memset(id,0,sizeof(id));        s[0]=n/m;        printf(&quot;%d/%d = %d.&quot;,n,m,s[0]);        n%=m;        int cnt=1;        while (n &amp;&amp; !id[n])        {            id[n]=cnt;            s[cnt]=n*10/m;            n=n*10%m;            cnt++;        }        if (!n)        {            for (int i=1;i&lt;cnt;i++) printf(&quot;%d&quot;,s[i]);            printf(&quot;(0)\n&quot;);        }        else        {            for (int i=1;i&lt;id[n];i++) printf(&quot;%d&quot;,s[i]);            printf(&quot;(&quot;);            for (int i=id[n];i&lt;=min(cnt-1,50);i++) printf(&quot;%d&quot;,s[i]);            if (cnt&gt;50) printf(&quot;...&quot;);            printf(&quot;)\n&quot;);        }        printf(&quot;   %d&quot;,!n ? 1 : cnt-id[n]);        printf(&quot; = number of digits in repeating cycle\n\n&quot;);    }    return 0;}</code></pre><p>完了，就酱。</p>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构-字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018暑假清北学堂济南集训游记</title>
      <link href="/p/qbxt-2018-summer-summary.html"/>
      <url>/p/qbxt-2018-summer-summary.html</url>
      
        <content type="html"><![CDATA[<p>本来报的成都的班，结果取消了（多半是人不够），cyc，wzx和我就决定去济南，顺便提前去玩几天。<del>颓废的气息</del></p><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><p>早上和cyc坐动车去了曲阜，悲催的wzx因为坐了晚一点的车被困在成都了。晚上和cyc在酒店里颓CSGO和吃鸡，<del>真是充实的一天。</del></p><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>上午去了曲阜的三孔景区。感觉挺壮观的，环境也非常好（到处都是几百年的古树）。话说孔林和孔庙孔府离的好远啊，只有坐车去。从孔府出来就有人说35一个人去孔林，还好没听叫了个uber10块钱就过去了。孔林就只去看了孔子墓，周围绿水青山的，<del>风水极好</del>，听说只有孔姓后人才能埋在孔林，真是有福气。</p><p>中午退房以后就去火车站玩手机玩到4点，然后坐车去济南。晚上10点又去西站接wzx。这里要吐槽下济南城市布局，怎么火车站都在西边而且还这么远？而且第一条地铁也要2019年1月1日开通，真麻烦。</p><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><p>我们三个上午骑车去了大明湖，然后坐在湖边打了一个多小时斗地主（<del>真有意境</del>）。后面大概逛了逛就回去了。</p><p>下午去看了山东<del>情妇院</del>博物馆（其实就是题词上面的“博物馆”看起来像情妇院，很久以前一个梗了）。本以为省博物馆位置肯定会好一些，结果所在的历下区<strong>又乱又差</strong>，到处都在施工，整的他们两个都在怀疑我是不是导航导错路了。而且全程上坡，累的一批，回来想着一直下坡很爽还tm车都找不到。（全济南共享单车都少，在成都我一直都是看到车后打开App扫，在济南我都是打开App找到车后扫，而且车都很旧，摩拜的新款车全都没有）。不过博物馆本身还是很有看头的，看完后对齐鲁大地的历史大概有了了解，<del>虽然我主要都去关注字画去了，里面有一幅隶书是真的好看啊</del>。 </p><h2 id="7-14"><a href="#7-14" class="headerlink" title="7.14"></a>7.14</h2><p>起床晚了，他们两个哪都不想去，就颓废了一上午。中午惊喜地发现上课的地方就在我们这，然后搬行李过去报道。三床房没了，cyc就只有和另一个人拼一个房间。下午我们分工写一个局域网联机的斗地主，也没什么结果。</p><h2 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-基础算法总结</a></p><p>上午主要讲的是一些基础算法，像什么搜索、二分、倍增、分治之类的。感觉还好。</p><p>下午考了套题，我才rk25，好菜啊。</p><h2 id="7-16"><a href="#7-16" class="headerlink" title="7.16"></a>7.16</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-数论总结</a></p><p>上午还是讲的基础算法，无话。</p><p>下午讲数论，终于算是系统地学了一遍数论了，我发现我之前的总结写的好水啊，还有bug。</p><h2 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-数据结构总结</a></p><p>对于这一天的内容，我只想问：为什么课表上那么简单，讲的那么难？</p><h2 id="7-18"><a href="#7-18" class="headerlink" title="7.18"></a>7.18</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-动态规划总结</a></p><p>数据结构和动规各讲一天半，下午开始讲动规。从头开始讲，所以还不算太难。</p><h2 id="7-19"><a href="#7-19" class="headerlink" title="7.19"></a>7.19</h2><p>又是一天dp，我感觉我dp怕是药丸。</p><h2 id="7-20"><a href="#7-20" class="headerlink" title="7.20"></a>7.20</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-动态规划总结</a></p><p>图论大多我都学过，但还是想巩固一下，结果大佬们纷纷表示不想听，于是难度就增加了，又听不懂了。我好菜啊！</p><h2 id="7-21"><a href="#7-21" class="headerlink" title="7.21"></a>7.21</h2><p><a href="https://llf0703.com/gugugu/">QBXT集训-字符串总结</a></p><p>字符串我大概都还会，所以基本上就水了一上午。</p><p>下午又是一套%你题。lmj太毒瘤了！第一题找规律，我离线处理得了60分，然后死磕第二题，最后TLE了，然后总分60rk竟然都是18。<del>lmj：这套题暴力都有240啊</del>。</p><h2 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h2><p>讲了点往年试题，大家似乎都在水。最后lmj还成功上演了“一步扫雷”。</p><p>下午又去机场打斗地主打到晚上，飞机还延误一个小时。23号0点过终于到了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一趟过去收获还是挺大的，也见识了比我强太多的大佬，感觉自已好菜啊！</p><p>总结还没写完，那些链接都只是在占坑，有时间慢慢补，就酱。</p><hr><p>更新于2018.7.23</p><hr>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>紫书第九章-动态规划初步 刷题总结</title>
      <link href="/p/aoapc-book-9.html"/>
      <url>/p/aoapc-book-9.html</url>
      
        <content type="html"><![CDATA[<p>很久没写过总结了。紫书做了那么多道题，但是我的动规并没有找到什么感觉，也就只有普及难度的可以不看题解写，剩下的都是看着题解写完的，我还是太弱了。这里还是来总结一下吧。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="9-1-UVa1025-A-Spy-in-the-Metro"><a href="#9-1-UVa1025-A-Spy-in-the-Metro" class="headerlink" title="9-1 UVa1025-A Spy in the Metro"></a>9-1 <a href="https://vjudge.net/problem/UVA-1025" target="_blank" rel="noopener">UVa1025-A Spy in the Metro</a></h3><p>$f[i][j]$表示在车站i，时刻是j，还剩多少时间（根紫书略有不同）</p><p>决策有三个，上左边的车，上右边的车，<del>如果都不开往幼儿园</del>就等一时刻的车。</p><p>注意还要判断某一时刻是否有车，$havel[i][t]$和$haver[i][t]$表示在i车站在t时刻是否有车。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,a,b,c,tright,tleft,Time,cnt;int T[55],tl,tr,f[55][255];//在车站i，时刻j，还剩多少时间bool havel[55][255],haver[55][255];//在车站i，在t时刻是否有车inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int main(){    while (1)    {        memset(havel,false,sizeof(havel));        memset(haver,false,sizeof(haver));        memset(f,0,sizeof(f));        memset(T,0,sizeof(T));        n=read(); if (n==0) break; t=read();        for (int i=1;i&lt;n;i++) T[i]=read();        tright=read();        for (int i=1;i&lt;=tright;i++)        {            tr=read();            Time=tr;            for (int j=1;j&lt;=n;j++) haver[j][Time]=true,Time+=T[j];        }        tleft=read();        for (int i=1;i&lt;=tleft;i++)        {            tl=read();            Time=tl;            for (int j=n;j&gt;=1;j--) havel[j][Time]=true,Time+=T[j-1];        }        for (int i=1;i&lt;=n-1;i++) f[i][t]=2e9;        f[n][t]=0;        for (int j=t-1;j&gt;=0;j--)            for (int i=1;i&lt;=n;i++)            {                f[i][j]=f[i][j+1]+1;                if (i&gt;1 &amp;&amp; havel[i][j] &amp;&amp; j+T[i-1]&lt;=t) f[i][j]=min(f[i][j],f[i-1][j+T[i-1]]);//左                if (i&lt;n &amp;&amp; haver[i][j] &amp;&amp; j+T[i]&lt;=t) f[i][j]=min(f[i][j],f[i+1][j+T[i]]);//右            }        printf(&quot;Case Number %d: &quot;,++cnt);        if (f[1][0]&gt;=2e9) printf(&quot;impossible\n&quot;);        else printf(&quot;%d\n&quot;,f[1][0]);    }    return 0;}</code></pre><h3 id="9-2-UVa437-The-Tower-of-Babylon"><a href="#9-2-UVa437-The-Tower-of-Babylon" class="headerlink" title="9-2 UVa437-The Tower of Babylon"></a>9-2 <a href="https://vjudge.net/problem/UVA-437" target="_blank" rel="noopener">UVa437-The Tower of Babylon</a></h3><p>长和宽都会严格减小，直接记忆化搜索即可。</p><p>用$f[id][h]$表示第id个立方体，第h个数据做高。需要将每个立方体的三维按从小到大排序。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define Ans f[id][h]using namespace std;int n,m,a,b,c,h[4],f[40][4],ans,cnt;bool vis[40][4];struct Edge{    int x,y,z;} edge[35];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int dp(int id,int h){    if (vis[id][h]) return Ans;    vis[id][h]=1;    int E[2],hnow;    if (h==1) E[0]=edge[id].y,E[1]=edge[id].z,hnow=edge[id].x;    if (h==2) E[0]=edge[id].x,E[1]=edge[id].z,hnow=edge[id].y;    if (h==3) E[0]=edge[id].x,E[1]=edge[id].y,hnow=edge[id].z;//判断当前哪两个数据做底面，哪一个是高    for (int i=1;i&lt;=n;i++)    {        if (edge[i].x&lt;E[0] &amp;&amp; edge[i].y&lt;E[1]) Ans=max(Ans,dp(i,3)+hnow);        if (edge[i].x&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,2)+hnow);        if (edge[i].y&lt;E[0] &amp;&amp; edge[i].z&lt;E[1]) Ans=max(Ans,dp(i,1)+hnow);    }    return Ans;}int main(){    for (;;)    {        memset(f,0,sizeof(f));        memset(vis,0,sizeof(vis));        ans=0;        n=read();        if (n==0) break;        for (int i=1;i&lt;=n;i++)        {            for (int j=1;j&lt;=3;j++) h[j]=read();            sort(h+1,h+4);            edge[i].x=h[1]; edge[i].y=h[2]; edge[i].z=h[3];            for (int j=1;j&lt;=3;j++) f[i][j]=h[j];        }        for (int i=1;i&lt;=n;i++)            for (int j=1;j&lt;=3;j++) ans=max(ans,dp(i,j));        printf(&quot;Case %d: maximum height = %d\n&quot;,++cnt,ans);    }    return 0;}</code></pre><h3 id="9-3-UVa1347-Tour"><a href="#9-3-UVa1347-Tour" class="headerlink" title="9-3 UVa1347-Tour"></a>9-3 <a href="https://vjudge.net/problem/UVA-1347" target="_blank" rel="noopener">UVa1347-Tour</a></h3><p>将题目的走法改成两个人同时从左边出发，$f[i][j]$表示$1-max(i,j)$全部走过，且两人位置为i和j，还要走多少距离。可以定义i&gt;j，并且只允许走到i+1这个点。</p><p>决策就有两个：走到$f[i+1][j]$和$f[i+1][i]$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;double f[1005][1005];int n,m,a,b,c,x[1005],y[1005];inline double dis(int i,int j){    return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));}int main(){    while (scanf(&quot;%d&quot;,&amp;n)!=EOF)    {        memset(f,0,sizeof(f));        for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);        for (int i=1;i&lt;n-1;i++) f[n-1][i]=dis(n-1,n)+dis(i,n);        for (int i=n-2;i&gt;=2;i--)            for (int j=1;j&lt;i;j++) f[i][j]=min(f[i+1][j]+dis(i,i+1),f[i+1][i]+dis(j,i+1));        cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;f[2][1]+dis(1,2)&lt;&lt;endl;    }    return 0;}</code></pre><p>以上更新于2018.5.26</p><hr><h3 id="9-4-UVa116-单向TSP"><a href="#9-4-UVa116-单向TSP" class="headerlink" title="9-4 UVa116-单向TSP"></a>9-4 <a href="https://vjudge.net/problem/UVA-116" target="_blank" rel="noopener">UVa116-单向TSP</a></h3><p>用$f[i][j]$来记录从起点到$(i,j)$的开销（和紫书上反过来了），注意边界判断就行了。唯一有点难度的就是输出路径，我感觉用的是有点像前向星的方法。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int f[105][105],t[105][105],rd[105][105],newf[105];int n,m;int main(){    while (~scanf(&quot;%d%d&quot;,&amp;m,&amp;n))    {        for (int i=1;i&lt;=m;i++)            for (int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;t[i][j]);        int ans=1e9, last=0;        for (int i=1;i&lt;=m;i++) f[i][n]=t[i][n];        if (n==1)        {            for (int i=1;i&lt;=m;i++)                if (f[i][1]&lt;ans) ans=f[i][1],last=i;        }        else        {            for (int j=n-1;j&gt;=1;j--)                for (int i=1;i&lt;=m;i++)                {                    int dir[]={i,i+1,i-1};                    if (i==1) dir[2]=m;                    if (i==m) dir[1]=1;                    sort(dir,dir+3);                    f[i][j]=f[dir[0]][j+1]+t[i][j];                    rd[i][j]=dir[0];                    for (int k=1;k&lt;3;k++)                        if (f[dir[k]][j+1]+t[i][j]&lt;f[i][j]) f[i][j]=f[dir[k]][j+1]+t[i][j],rd[i][j]=dir[k];                    if (j==1 &amp;&amp; f[i][j]&lt;ans) ans=f[i][j],last=i;             }        }            printf(&quot;%d&quot;,last);            for (int i=rd[last][1],j=2;j&lt;=n;i=rd[i][j],j++) printf(&quot; %d&quot;,i);            printf(&quot;\n%d\n&quot;,ans);    }    return 0;}</code></pre><h3 id="9-5-UVa12563-劲歌金曲"><a href="#9-5-UVa12563-劲歌金曲" class="headerlink" title="9-5 UVa12563-劲歌金曲"></a>9-5 <a href="https://vjudge.net/problem/UVA-12563" target="_blank" rel="noopener">UVa12563-劲歌金曲</a></h3><p><del>数据范围真的假</del>，直接01背包即可</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,a,b,c,k,kase,sum,ans;int cnt[55][10005],f[55][10005],s[55];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}int main(){    k=read();    while (k--)    {        n=read(); t=read();        for (int i=1;i&lt;=n;i++) s[i]=read();        for (int i=1;i&lt;=n;i++)             for (int j=0;j&lt;=t;j++)            {                cnt[i][j]=(i==1) ? 0 : cnt[i-1][j];                f[i][j]=(i==1) ? 0 : f[i-1][j];                if (j&gt;s[i])                {                    if (cnt[i][j]&lt;cnt[i-1][j-s[i]]+1)                     {                        cnt[i][j]=cnt[i-1][j-s[i]]+1;                        f[i][j]=f[i-1][j-s[i]]+s[i];                    }                    else if (cnt[i][j]==cnt[i-1][j-s[i]]+1) f[i][j]=max(f[i][j],f[i-1][j-s[i]]+s[i]);                }            }        printf(&quot;Case %d: %d %d\n&quot;,++kase,cnt[n][t]+1,f[n][t]+678);    }}</code></pre><p>未完待续</p><p>以上内容更新于2018.7.3</p><hr><h3 id="9-6-UVa11400-照明系统设计"><a href="#9-6-UVa11400-照明系统设计" class="headerlink" title="9-6 UVa11400-照明系统设计"></a>9-6 <a href="https://vjudge.net/problem/UVA-11400" target="_blank" rel="noopener">UVa11400-照明系统设计</a></h3><p>跟书上的思路一样。每种灯泡要么都取，要么都不取。然后用一个类似LIS的动规方法，用$f[i]$表示前i种灯泡的最小开销，$sum[i]$表示前i种灯泡的数量$f[i]=min(f[i],f[j]+(sum[i]-sum[j])*node[i].c+node[i].k)(j&lt;i)$</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Node{    int v,k,c,l;} node[1005];int n,m,a,b,sum[1005],f[1005];inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline bool cmp(Node a,Node b){    return a.v&lt;b.v;}int main(){    for (;;)    {        n=read();        if (n==0) break;        for (int i=1;i&lt;=n;i++) node[i].v=read(),node[i].k=read(),node[i].c=read(),node[i].l=read();        sort(node+1,node+n+1,cmp);        for (int i=1;i&lt;=n;i++) sum[i]=node[i].l+sum[i-1];        f[0]=0;        for (int i=1;i&lt;=n;i++)        {            int now=0x7fffffff;            for (int j=0;j&lt;i;j++) now=min(now,f[j]+(sum[i]-sum[j])*node[i].c+node[i].k);            f[i]=now;        }        printf(&quot;%d\n&quot;,f[n]);    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基础数论学习总结</title>
      <link href="/p/number-theory.html"/>
      <url>/p/number-theory.html</url>
      
        <content type="html"><![CDATA[<p>原本打算先学Splay的，但想到提高组一般不考，而且我其它东西还差的多，就先把基础数论的东西复习一下，并且加深一下难度，<del>还做了n多道水题，虽然主要是之前没过的</del>。</p><hr><h2 id="1-整除"><a href="#1-整除" class="headerlink" title="1.整除"></a>1.整除</h2><p>这里就把整除的性质列一下：</p><ol><li>如果$a \mid b$且$b \mid c$，那么$a \mid c$</li><li>$a \mid b$且$a \mid c$等价于$\forall x,y$，有$a \mid (b \times x + c \times y)$</li><li>设$m\neq 0$,那么$a \mid b $等价于$(m \times a) \mid (m \times b)$</li><li>设$x,y$满足$a \times x+b \times y=1$且$a \mid n,b \mid n$，那么$(a \times b) \mid n$</li><li>若$b=q \times d+c$,那么$d \mid b$的充要条件是$d \mid c$</li></ol><h2 id="2-同余"><a href="#2-同余" class="headerlink" title="2.同余"></a>2.同余</h2><p>同余性质：</p><ol><li>自反性 $a\equiv a(mod m) $</li><li>对称性 若$a\equiv b(mod m)$则$b\equiv a(mod m)$</li><li>传递性 若$a\equiv b(mod m),b\equiv c(mod m)$，则$a\equiv c(mod m)$</li><li>同加性 若$a\equiv b(modm)$，则$a+c\equiv b+c(modm)$</li><li>同乘性(1) 若$a\equiv b(modm)$，则$a\times c\equiv b\times c(modm)$ </li><li>同乘性(2) 若$a\equiv b(modm),c\equiv d(modm)$ ，则$a\times c\equiv b\times d(modm)$</li><li>同幂性 若$a\equiv b(modm)$，则$a^{n}\equiv b^{n} (modm)$</li></ol><h2 id="3-最大公约数-gcd"><a href="#3-最大公约数-gcd" class="headerlink" title="3.最大公约数(gcd)"></a>3.最大公约数(gcd)</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>基础方法，不再赘述</p><pre><code class="lang-cpp">int gcd(int a,int b){    if (b==0) return a;    return gcd(b,a%b);}</code></pre><h3 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h3><p>不断去除因数2来提高gcd的效率</p><pre><code class="lang-cpp">inline int gcd(int x,int y){    int i,j;    if (x==0) return y;    if (y==0) return x;    for (i=0;0==(x&amp;1);i++) x&gt;&gt;=1;//去掉2    for (j=0;0==(y&amp;1);j++) y&gt;&gt;=1;    if (i&gt;j) i=j;    for (;;)    {        if (x&lt;y) x^=y,y^=x,x^=y;        if (0==(x-=y)) return y&lt;&lt;i;//如果x==y gcd==x==y        while (0==(x&amp;1)) x&gt;&gt;=1;    }}</code></pre><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>扩展欧几里得算法用来在已知$(a,b)$，求$(x,y)$，使$a\times x+b\times y=gcd(a,b)$</p><pre><code class="lang-cpp">void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}</code></pre><p>例题：<a href="https://www.luogu.org/problemnew/show/P1516" target="_blank" rel="noopener">洛谷P1516 青蛙的约会</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,a,b,c,x,y,l,X,Y;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline LL exgcd(LL l,LL r,LL &amp;X,LL &amp;Y){    if (r==0)    {        X=1; Y=0;        return l;    }    LL a=exgcd(r,l%r,Y,X);    Y-=l/r*X;    return a;}int main(){    x=read(); y=read(); m=read(); n=read(); l=read();    LL deltav=(m&gt;=n) ? m-n : n-m;    LL deltas=(m&gt;=n) ? y-x : x-y;    LL k=exgcd(deltav,l,X,Y);    if (deltas%k!=0) printf(&quot;Impossible&quot;);    else printf(&quot;%lld&quot;,(X*(deltas/k)%(l/k)+(l/k))%(l/k));    return 0;}</code></pre><h2 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4.逆元"></a>4.逆元</h2><p>若$a\times x\equiv 1(modb)$，就称x是a的逆元。</p><p>可以将这个式子转化为$a\times x+b\times y=1$，然后用扩展欧几里得定理求解。</p><p>当然也有一种线性算法，在需要求连续逆元时是最优的算法。</p><blockquote><p>以下内容来自<a href="https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan" target="_blank" rel="noopener">https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan</a></p></blockquote><hr><p>首先我们有一个, $1^{-1}\equiv 1(\bmod p)$</p><p>然后设 $p=k∗i+r,r&lt;i,1&lt;i&lt;p$ ,再将这个式子放到 $\bmod {p}$ 意义下就会得到：</p><p>$k∗i+r≡0(modp)$</p><p>然后乘上 $i^{-1} , r^{-1}$ 就可以得到:</p><p>$k*r^{-1}+i^{-1}\equiv 0 (\bmod p)$</p><p>$i^{-1}\equiv -k*r^{-1} (\bmod p)$</p><p>$i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} (\bmod p)$</p><hr><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">洛谷P3811 【模板】乘法逆元</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,p,inv[3000005];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);    inv[1]=1;    printf(&quot;%d\n&quot;,inv[1]);    for (int i=2;i&lt;=n;i++)    {        inv[i]=-(p/i)*inv[p%i];        inv[i]=(inv[i]%p+p)%p;        printf(&quot;%d\n&quot;,inv[i]);    }    return 0;}</code></pre><h2 id="5-中国剩余定理"><a href="#5-中国剩余定理" class="headerlink" title="5.中国剩余定理"></a>5.中国剩余定理</h2><p>还是就放一个我看的吧</p><p><a href="https://blog.csdn.net/acdreamers/article/details/8050018" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/8050018</a></p><p>例题：<a href="https://www.luogu.org/problemnew/show/P3868" target="_blank" rel="noopener">洛谷P3868 [TJOI2009]猜数字</a></p><p>可以用裸的中国剩余定理来做，但是要注意必须用快速乘，不然$10^{18}\times 10^{18}$肯定会超范围。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,k;LL A[15],B[15];inline LL read(){    char ch=getchar();    LL f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}inline LL gcd(LL a,LL b){    if (b==0) return a;    return gcd(b,a%b);}inline LL qmul(LL a,LL b,LL mod){    LL ans=0,k=a,f=1;    if (k&lt;0) k=-k,f*=-1;    if (b&lt;0) b=-b,b*=-1;    while (b)    {        if (b&amp;1) ans=(ans+k)%mod;        k=(k+k)%mod;        b&gt;&gt;=1;    }    return ans*f;}inline LL crt(){    LL M=1,ans=0;    for (int i=1;i&lt;=k;i++) M*=B[i];    for (int i=1;i&lt;=k;i++)    {        LL x,y,Mi=M/B[i];        exgcd(Mi,B[i],x,y);        x=(x%B[i]+B[i])%B[i];        ans=(ans+qmul(qmul(Mi,x,M),A[i],M))%M;    }    return (ans&lt;0)?ans+M:ans;}int main(){    k=read();    for (int i=1;i&lt;=k;i++) A[i]=read();    for (int i=1;i&lt;=k;i++) B[i]=read();    for (int i=1;i&lt;=k;i++) A[i]=(A[i]%B[i]+B[i])%B[i];    printf(&quot;%lld&quot;,crt());    return 0;}</code></pre><h2 id="6-素数筛"><a href="#6-素数筛" class="headerlink" title="6.素数筛"></a>6.素数筛</h2><h3 id="普通筛法"><a href="#普通筛法" class="headerlink" title="普通筛法"></a>普通筛法</h3><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    int cnt=1;    ss[0]=ss[1]=false;    for (a=2;a&lt;=sqrt(n);a++)    {        if (ss[a]) zs[cnt++]=a;        for (b=2;b&lt;=n/a;b++) ss[a*b]=false;    }}</code></pre><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>可以很容易的想到，普通筛法中筛了很多重复的数。而线性筛法可以避免重复。主要思路是运用得到了的素数来标记后面的合数。</p><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    ss[0]=ss[1]=false;    for (int i=2;i&lt;=n;i++)    {        if (ss[i]) zs[cnt++]=i;        for (int j=1;j&lt;cnt &amp;&amp; zs[j]*i&lt;=n;j++)         {            ss[zs[j]*i]=false;            if (i%zs[j]==0) break;        }    }}</code></pre><p>以上内容更新于2018.5.9</p><p>线性筛法错误修正于2018.7.28</p><hr>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点分治总结</title>
      <link href="/p/dian-fen-zhi.html"/>
      <url>/p/dian-fen-zhi.html</url>
      
        <content type="html"><![CDATA[<p>markdown原文: <a href="https://md.llf0703.com/p/dian-fen-zhi.md" target="_blank" rel="noopener">https://md.llf0703.com/p/dian-fen-zhi.md</a></p><p>我自己感觉点分治是一种比较<del>玄学</del>神奇的算法，感觉自己也只是理解了一点皮毛而已。这里就谈谈点分治的实现方法和一些运用。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>点分治其实是将一棵树的点不断分为多棵子树，分别得到子树节点到子树根的距离来进行处理。</p><p>既然要有一个点为根节点，那么应该选取哪一个点呢？</p><p>既然要向下分治，如果把一个原来的叶节点作为分治的根节点，那么遍历每一个点的时间开销是非常大的。然而如果这个点的左右子树都达到最大，那么遍历的时间开销就要少很多。而<strong>子树的重心</strong>就能满足这个性质，所以我们选取<strong>子树的重心</strong>作为分治中心，即分治子树的根。</p><h3 id="1-求重心"><a href="#1-求重心" class="headerlink" title="1.求重心"></a>1.求重心</h3><p>首先我们需要了解重心是什么</p><blockquote><p>树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心，删去重心后，生成的多棵树尽可能平衡。— 百度百科</p></blockquote><p>提取关键词：</p><ol><li><strong>其所有的子树中最大的子树节点数最少</strong></li><li><strong>生成的多棵树尽可能平衡</strong></li></ol><p>第1点告诉我们怎么求重心，只需要记录每一个点的子树大小，然后按着定义做就行了。</p><p>第2点告诉我们选择重心作为分治点的原因，因为多棵树尽可能平衡，就可以使复杂度变得最优秀。</p><p>这个不是重点，直接上代码（感觉和树剖差不多）：</p><blockquote><p>这里可以先不管<code>vis[]</code>，后面会解释<br>sizenow是当前这个子树的大小，后面会讲到<br>mx是当前分治到的最大的子树节点最小值</p></blockquote><pre><code class="lang-cpp">void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)//遍历每一个子节点  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];//加上子节点的子树大小    son[x]=max(son[x],size[y]);//求最大的子树  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)//使最大的子树节点最少  {    mx=son[x];    root=x;//记录分治中心（根节点）  }}</code></pre><h3 id="2-进行分治"><a href="#2-进行分治" class="headerlink" title="2.进行分治"></a>2.进行分治</h3><p>分治其实就是一个递归，不断地将子树进行处理就行了，注意要用<code>vis[]</code>标记已经访问防止重复。先上代码：</p><blockquote><p>solve就是解决问题，每一道题有不同的作用，这里不用管。</p></blockquote><pre><code class="lang-cpp">void divide(int x){  vis[x]=true;//标记已访问  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];//得到当前树的大小，将mx和root初始化    getroot(y,0);//得到子树的分治中心    divide(root);//分治子树  }}</code></pre><p>至于为什么有两次solve，主要是为了去重。原因如下：</p><blockquote><p>以下内容来自<a href="https://blog.csdn.net/qq_39553725/article/details/77542223" target="_blank" rel="noopener">https://blog.csdn.net/qq_39553725/article/details/77542223</a></p></blockquote><hr><p>对于以下这棵树：<br><img src="https://cdn.uniqueue.cn/dian-fen-zhi.png" alt="点分治"><br>显然A点是它的重心。<br>我们假设现在分治到了A点（当前点为A）<br>我们一开始求解贡献时，会有以下路径被处理出来：<br>A—&gt;A<br>A—&gt;B<br>A—&gt;B—&gt;C<br>A—&gt;B—&gt;D<br>A—&gt;E<br>A—&gt;E—&gt;F (按照先序遍历顺序罗列)<br>那么我们在合并答案是会将上述6条路径两两进行合并。<br>这是注意到：<br>合并A—&gt;B—&gt;C 和 A—&gt;B—&gt;D 肯定是不合法的！！<br>因为这并不是一条树上(简单)路径，出现了重边，我们要想办法把这种情况处理掉。<br>处理方法很简单，减去每个子树的单独贡献。<br>例如对于以B为根的子树，就会减去：<br>B—&gt;B<br>B—&gt;C<br>B—&gt;D<br>这三条路径组合的贡献<br>读者可能会有疑问，这与上面的6条路径并不一样啊。<br>我们再回过头来看一看这两句代码：<br>ans = ans + solve(tr,0);<br>ans = ans - solve(v,t[i].len);<br>注意到了吧，solve函数的第二个初始值并不相同。<br>我们在处理子树时，将初始长度设为连接边长，这样做就相当于个子树的每个组合都加上了A—&gt;的路径，从而变得与上面一样。<br>个人认为这是点分治一个极其重要的地方，读者们一定要理解清楚。</p><hr><p>好了，分治就完了。不过和树剖一样，只是剖分完是并没有什么卵用的，还需要具体问题具体分析。</p><h2 id="具体例题"><a href="#具体例题" class="headerlink" title="具体例题"></a>具体例题</h2><h3 id="1-洛谷P3806-【模板】点分治1"><a href="#1-洛谷P3806-【模板】点分治1" class="headerlink" title="1.洛谷P3806 【模板】点分治1"></a>1.洛谷P3806 【模板】点分治1</h3><p>题目链接：<a href="https://www.luogu.org/problemnew/show/P3806" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3806</a></p><p>对于这道题询问的距离为k的点是否存在，我们可以用一种类似桶排序的笨方法，将距离作为数组下标，统计到这个距离就将数组++，最后不为0就存在，反之不存在。</p><p>要得到两点之间的距离，只需要记录两个点分别到根的距离，然后相加即可。</p><p>这里的query函数用作求当前分治到的树中点到根的距离，solve用于相加得到两点间距离并统计。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[20005];int size[20005],son[20005],dis[20005],head[20005];bool vis[20005];int sum[10000005];//存距离是否存在，注意大小和n不一样int n,m,k,a,b,c,ord,cnt=1,mx,root,sizenow;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  dis[++ord]=dist;//得到到根的距离  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w);//查询子节点  }}void solve(int x,int length,bool s) //s=false时要去重{  ord=0;  query(x,0,length);  for (int i=1;i&lt;=ord-1;i++)    for (int j=i+1;j&lt;=ord;j++)    {      if (s==true) sum[dis[i]+dis[j]]++;      else sum[dis[i]+dis[j]]--; //进行统计    }}void divide(int x){  vis[x]=true;  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];    getroot(y,0);    divide(root);  }}int main(){  memset(vis,false,sizeof(vis));  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  root=0;mx=2147483646;sizenow=n;  getroot(1,0);  divide(root);  for (int i=1;i&lt;=m;i++)  {    a=read();    if (sum[a]) printf(&quot;AYE\n&quot;);    else printf(&quot;NAY\n&quot;);  }  return 0;}</code></pre><h3 id="2-国家集训队-聪聪可可"><a href="#2-国家集训队-聪聪可可" class="headerlink" title="2.[国家集训队]聪聪可可"></a>2.[国家集训队]聪聪可可</h3><p>题目链接： </p><ul><li>洛谷 P2634： <a href="https://www.luogu.org/problemnew/show/P2634" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P2634</a> </li><li>BZOJ P2152： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2152" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2152</a></li></ul><p>这里使用一个<code>mod3[3]</code>数组来记录两点间距离%3后的值分别为0,1,2的个数。</p><p>对每个节点求出其子树内的dis，经过该点的路径数即为<code>mod3[1]*mod3[2]*2+mod3[0]^2</code>。</p><p>因为要求答案互质，所以还需要一个求最大公约数的操作。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[40005];int head[40005],size[40005],son[40005],mod3[3];bool vis[40005];int n,m,a,b,c,cnt=1,ord,root,mx,sizenow,ans;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=2147483647;root=0;sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  mod3[dist%3]++;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    query(y,x,dist+edge[i].w);  }}inline int solve(int x,int length){  memset(mod3,0,sizeof(mod3));  query(x,0,length);  return mod3[0]*mod3[0]+mod3[1]*mod3[2]*2;}void divide(int x){  vis[x]=true;  ans+=solve(x,0);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    ans-=solve(y,edge[i].w);    init(size[y]);    getroot(y,0);    divide(root);  }}int gcd(int x,int y)//求最大公约数{  if (y==0) return x;  return gcd(y,x%y);}int main(){  n=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  printf(&quot;%d%c%d&quot;,ans/gcd(ans,n*n),&#39;/&#39;,n*n/gcd(ans,n*n));  return 0;}</code></pre><h3 id="3-IOI2011-Race"><a href="#3-IOI2011-Race" class="headerlink" title="3.[IOI2011]Race"></a>3.[IOI2011]Race</h3><p>题目链接：</p><ul><li>洛谷 P4149：<a href="https://www.luogu.org/problemnew/show/P4149" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4149</a></li><li>BZOJ P2599: <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2599" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2599</a></li></ul><blockquote><p>BZOJ是权限题，若没交钱就用洛谷，或者用离线BZOJ题库（by ruanxingzhi）：<br><a href="https://bzoj.llf0703.com/p/2599.html" target="_blank" rel="noopener">https://bzoj.llf0703.com/p/2599.html</a></p></blockquote><p><del>洛谷上这道题是<a href="https://www.luogu.org/space/show?uid=20438" target="_blank" rel="noopener">@larryzhong</a>大佬提供的，比我小3岁却吊打我，在这里先%%%为敬</del></p><p>因为这道题需要得到边数最小，我们对于距离为i的点建立<code>tmp[i]</code>，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边</p><p>点分治，每次先对每棵子树遍历，求出每个点i到root的距离<code>dis[i]</code>，以及走过的边数<code>d[i]</code>，那么<code>ans=min(ans,tmp[k-dis[i]]+d[i])</code>.</p><p>遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵。最后所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define maxint 1e9using namespace std;struct Edge{  int next,to,w;} edge[400005];bool vis[200005];int size[200005],son[200005],dis[200005],head[400005],esum[200005];//tmp[i]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边//每个点i到root的距离dis[i]，以及走过的边数esum[i]int tmp[1000005];int n,m,k,a,b,c,cnt=1,sizenow,mx,ans,root;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return x*f;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=maxint;  root=0;  sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-son[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist,int edgesum){  dis[x]=dist;  esum[x]=edgesum;  if (dis[x]&lt;=k) ans=min(ans,tmp[k-dis[x]]+esum[x]);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w,edgesum+1);  }}//遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵void update(int x,int f,bool s){  if (dis[x]&lt;=k)    if (s) tmp[dis[x]]=min(tmp[dis[x]],esum[x]);    else tmp[dis[x]]=maxint;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    update(y,x,s);  }}void divide(int x){  vis[x]=true;  tmp[0]=0;//每次进入dfs_solve时tmp[0]=0，因为这个当前的根到自己距离为0，走过了0条边  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    query(y,0,edge[i].w,1);    update(y,0,true);  }  for (int i=head[x];i;i=edge[i].next)//所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）  {    int y=edge[i].to;    if (vis[y]) continue;    update(y,0,false);  }  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    init(size[y]);    getroot(y,0);    divide(root);  }}int main(){  n=read();k=read();  for (int i=1;i&lt;=k;i++) tmp[i]=maxint;  ans=maxint;  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    a++;b++;    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  if (ans==maxint) printf(&quot;-1&quot;);  else printf(&quot;%d&quot;,ans);  return 0;}</code></pre><h3 id="4-洛谷-P4178-Tree"><a href="#4-洛谷-P4178-Tree" class="headerlink" title="4.洛谷 P4178 Tree"></a>4.洛谷 P4178 Tree</h3><p>题目链接： <a href="https://www.luogu.org/problemnew/show/P4178" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4178</a></p><p><del>这道题好像比上面那道还简单一点，我也不知道我为什么先刷的上面那一道</del></p><p>注意的是可以在统计有多少个路径权值&lt;=k时可以进行一次排序，直接枚举两个端点就可以处理了，可以节省时间。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define inf 0xfffffffusing namespace std;struct Edge{    int next,to,w;} edge[80005];bool vis[40005];int dis[40005],size[40005],son[40005],head[40005];int root,mx,sizenow,cnt=1,n,m,a,b,c,ord,k,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void add(int u,int v,int w){    edge[cnt].to=v;    edge[cnt].w=w;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void init(int sizen){    mx=inf; sizenow=sizen; root=0;}void getroot(int x,int f){    size[x]=1;    son[x]=0;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        getroot(y,x);        size[x]+=size[y];        son[x]=max(son[x],size[y]);    }    son[x]=max(son[x],sizenow-size[x]);    if (mx&gt;son[x])    {        mx=son[x];        root=x;    }}void query(int x,int f,int dist){    dis[++ord]=dist;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        query(y,x,dist+edge[i].w);    }}inline int solve(int x,int length){    ord=0;    query(x,0,length);    sort(dis+1,dis+ord+1);    int ans=0,stat=1;    while (stat&lt;ord)    {        if (dis[stat]+dis[ord]&lt;=k)        {            ans+=ord-stat;            stat++;        }        else ord--;    }    return ans;}void divide(int x){    ans+=solve(x,0);    vis[x]=true;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (vis[y]) continue;        ans-=solve(y,edge[i].w);        init(size[y]);        getroot(y,0);        divide(root);    }}int main(){    n=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();c=read();        add(a,b,c);        add(b,a,c);    }    k=read();    init(n);    getroot(1,0);    divide(root);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>以上内容更新于2018.4.26</p><hr>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-点分治 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P4092 [HEOI2016/TJOI2016]树</title>
      <link href="/p/luogu-solution-p4092.html"/>
      <url>/p/luogu-solution-p4092.html</url>
      
        <content type="html"><![CDATA[<p><del>第一次写树剖没看题解A题</del>，发现题解洛谷题解区大佬里竟然没有一个做法一样的，实在是太激动了</p><hr><p>树剖学习：<a href="https://llf0703.com/p/shu-lian-pou-fen.html">https://llf0703.com/p/shu-lian-pou-fen.html</a></p><p>题目链接:</p><ol><li><a href="https://www.luogu.org/problemnew/show/P4092" target="_blank" rel="noopener">洛谷 P4092</a>  </li><li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4551" target="_blank" rel="noopener">BZOJ P4551</a></li></ol><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><del>裸树剖</del>，直接用线段树维护每一段区间中<strong>被标记的最深的节点</strong>就行了。先全部赋值为-1，然后向上传递时直接取两段中的最大值即可（因为越深的点dfs序越大）</p><p>还有需要注意的是查询中在链上往上跳时只要找到了有标记的节点就需要输出，否则不是最深的点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to;} edge[200005];struct Tree{  int left,right,deepest;} tree[800005];int head[200005],size[200005],fa[200005],son[200005],deep[200005],top[200005],id[200005],dfsid[200005];int cnt=1,n,m,a,b,c,dfsord;char x;inline int read()//快读{  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v)//加边{  edge[cnt].to=v;  edge[cnt].next=head[u];  head[u]=cnt++;}void build(int x,int l,int r)//建树{  tree[x].left=l;  tree[x].right=r;  tree[x].deepest=-1;//注意要赋值为-1  if (r-l&gt;1)  {    build(x*2,l,(l+r)/2);    build(x*2+1,(l+r)/2,r);  }}void change(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) tree[x].deepest=l;//只有一个元素时标记的最深的节点就是它自己  else  {    int mid=(tree[x].left+tree[x].right)/2;    if (l&lt;mid) change(x*2,l,r);    if (r&gt;mid) change(x*2+1,l,r);    tree[x].deepest=max(tree[x*2].deepest,tree[x*2+1].deepest);//取两段上最深的节点  }}int query(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].deepest;  else  {    int mid=(tree[x].left+tree[x].right)/2,ans=-1;//同样注意初值    if (l&lt;mid) ans=max(ans,query(x*2,l,r));    if (r&gt;mid) ans=max(ans,query(x*2+1,l,r));    return ans;  }}void dfs1(int x,int f,int dep){  deep[x]=dep;  fa[x]=f;  size[x]=1;  int mx=-1;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f) continue;    dfs1(y,x,dep+1);    size[x]+=size[y];    if (size[y]&gt;mx)    {      mx=size[y];      son[x]=y;    }  }}void dfs2(int x,int topf){  top[x]=topf;  id[x]=++dfsord;  dfsid[dfsord]=x;//因为是输出节点原序号，这里得到dfs序对应的节点序号  if (!son[x]) return;  dfs2(son[x],topf);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==fa[x] || y==son[x]) continue;    dfs2(y,y);  }}inline void uprange(int u){  change(1,id[u],id[u]+1);}inline int qrange(int u,int v){  int ans=-1;  while (top[u]!=top[v])  {    if (deep[id[u]]&lt;deep[id[v]]) swap(u,v);    ans=query(1,id[top[u]],id[u]+1);    if (ans!=-1) return dfsid[ans];//只要找到就返回    u=fa[top[u]];  }  if (deep[u]&gt;deep[v]) swap(u,v);  ans=query(1,id[u],id[v]+1);  return dfsid[ans];}int main(){  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();    add(a,b);    add(b,a);  }  dfs1(1,0,1);  dfs2(1,1);  build(1,1,n+1);  change(1,1,2);//注意先将根节点打上标记  for (int i=1;i&lt;=m;i++)  {    cin&gt;&gt;x;    a=read();    if (x==&#39;C&#39;) uprange(a);    else printf(&quot;%d\n&quot;,qrange(a,1));  }  return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
            <tag> 数据结构-线段树 </tag>
            
            <tag> OJ-洛谷 </tag>
            
            <tag> OJ-BZOJ </tag>
            
            <tag> 省选-河北 </tag>
            
            <tag> 省选-天津 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分图匹配</title>
      <link href="/p/bipartite-matching.html"/>
      <url>/p/bipartite-matching.html</url>
      
        <content type="html"><![CDATA[<p>我是看这篇学懂的，真的写得很好，所以我就不在这里总结了，只发个模板</p><p><a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">https://blog.csdn.net/dark_scope/article/details/8880547</a></p><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3386" target="_blank" rel="noopener">洛谷 P3386【模板】二分图匹配</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;bool edge[1005][1005];bool used[1005];int mch[1005];int n,m,e,a,b,c,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)     {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}bool find(int x){    for (int i=1;i&lt;=m;i++)        if (!used[i] &amp;&amp; edge[x][i])        {            used[i]=true;            if (!mch[i] || find(mch[i]))            {                mch[i]=x;                return true;            }        }    return false;}int main(){    memset(edge,false,sizeof(edge));    n=read();m=read();e=read();    for (int i=1;i&lt;=e;i++)    {        int u=read(),v=read();        if (v&gt;m) continue;        edge[u][v]=true;    }    for (int i=1;i&lt;=n;i++)    {        memset(used,false,sizeof(used));        ans+=find(i);    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P2486 [SDOI2011]染色</title>
      <link href="/p/luogu-solution-p2486.html"/>
      <url>/p/luogu-solution-p2486.html</url>
      
        <content type="html"><![CDATA[<p>题目链接：</p><ul><li><a href="https://www.luogu.org/problemnew/show/P2486" target="_blank" rel="noopener">洛谷 P2486</a></li><li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2243" target="_blank" rel="noopener">BZOJ P2243</a></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>可以想到，颜色段的个数也是具有可加性的，但是如果两段连接处（即线段树中左子树的最右边的点和右子树的最左端的点）的颜色是相同的话，中间就只能算作一段，需要将颜色段个数-1。</p><p>所以我们在线段树里多加两个变量，分别为这一段最左端的点颜色和最右端的颜色，合并时和查询时判断一下即可。</p><p>注意的是查询链上时也需要判断。每次查询时记录一下左端点颜色，每一次判断一下当前剖到的右端点与上一次剖到的左端点是否相同即可。又由于有u和v两个节点要不停交换，所以用<code>lastc1</code>和<code>lastc2</code>两个变量来存上一次的左端点颜色，当u和v交换时，<code>lastc1</code>和<code>lastc2</code>也需要对应交换。当u和v在一条链上的时候，两边端点都需要比较。</p><p>查询链时代码</p><pre><code class="lang-cpp">int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);//同时交换        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;//将当前右端点同上一次左端点比较        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v]) //注意交换顺序，不要弄反    {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;//都要比较    return ans;}</code></pre><blockquote><p>其中lcol和rcol在query函数中就顺便获得了</p></blockquote><p>其它的就是标准的树链剖分了。传送门：<a href="https://llf0703.com/p/shu-lian-pou-fen.html">树链剖分总结 - Llf’s blog</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>同样，我的线段树是[left,right)形式，调用时要将右边端点+1</p></blockquote><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=200005;struct Edge{    int next,to;} edge[MAXN];struct Tree{    int left,right,leftc,rightc,sum,delta;//leftc和rightc分别是左右端点颜色} tree[MAXN*4];int deep[MAXN],top[MAXN],son[MAXN],fa[MAXN],size[MAXN],id[MAXN],w[MAXN],wnew[MAXN],head[MAXN];int n,m,a,b,c,cnt=1,dfsord,rcol,lcol,lastc1,lastc2;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void pushup(int x){    tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;    if (tree[x*2].rightc==tree[x*2+1].leftc) tree[x].sum--;    tree[x].leftc=tree[x*2].leftc;    tree[x].rightc=tree[x*2+1].rightc;}inline void update(int x){    tree[x*2].sum=tree[x*2+1].sum=1;    tree[x*2].leftc=tree[x*2].rightc=tree[x*2+1].leftc=tree[x*2+1].rightc=tree[x].delta;    tree[x*2].delta=tree[x*2+1].delta=tree[x].delta;    tree[x].delta=0;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    tree[x].delta=0;    if (r-l==1)     {        tree[x].leftc=tree[x].rightc=wnew[l];        tree[x].sum=1;    }    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        pushup(x);    }}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)    {        tree[x].sum=1;        tree[x].leftc=tree[x].rightc=delta;        tree[x].delta=delta;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        pushup(x);    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        if (l==tree[x].left) lcol=tree[x].leftc;        if (r==tree[x].right) rcol=tree[x].rightc;        return tree[x].sum;    }    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        if (tree[x*2].rightc==tree[x*2+1].leftc &amp;&amp; l&lt;(tree[x].left+tree[x].right)/2 &amp;&amp; r&gt;(tree[x].left+tree[x].right)/2) ans--;        return ans;    }}void dfs1(int x,int f,int dep){    deep[x]=dep;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==f) continue;        dfs1(y,x,dep+1);        size[x]+=size[y];        if (size[y]&gt;mx)         {            mx=size[y];            son[x]=y;        }    }}void dfs2(int x,int topf){    top[x]=topf;    id[x]=++dfsord;    wnew[dfsord]=w[x];    if (!son[x]) return;    dfs2(son[x],topf);    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==fa[x] || y==son[x]) continue;        dfs2(y,y);    }}void uprange(int u,int v,int delta){    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v])     {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;    return ans;}int main(){    memset(head,-1,sizeof(head));    n=read();m=read();    for (int i=1;i&lt;=n;i++) w[i]=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();        add(a,b);        add(b,a);    }    dfs1(1,0,1);    dfs2(1,1);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        char x;        cin&gt;&gt;x;        if (x==&#39;C&#39;)        {            a=read();b=read();c=read();            uprange(a,b,c);        }        else        {            a=read();b=read();            printf(&quot;%d\n&quot;,qrange(a,b));        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
            <tag> 数据结构-线段树 </tag>
            
            <tag> 省选-山东 </tag>
            
            <tag> OJ-洛谷 </tag>
            
            <tag> OJ-BZOJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树链剖分总结</title>
      <link href="/p/shu-lian-pou-fen.html"/>
      <url>/p/shu-lian-pou-fen.html</url>
      
        <content type="html"><![CDATA[<p>作为一个上个月刚学完线段树的蒟蒻，看Splay又看不懂，便直接跳着来学树剖了。又在一个博客上看到说学树剖之前最好还要把LCA给学了，便去花了一天学了一个Tarjan求LCA（然而后来发现并不怎么需要），然后是几乎照着别人的代码把树剖抄懂的。在这里我就讲一下我理解的树剖。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>链表/链式前向星</li><li>线段树/树状数组/Splay等可以维护一段数据的数据结构</li><li><a href="https://llf0703.com/p/LCA.html">LCA</a> （其实只涉及到一些思想，而且几乎用不到，可以先不学）</li></ol><h2 id="树剖原理"><a href="#树剖原理" class="headerlink" title="树剖原理"></a>树剖原理</h2><p>我很早之前就听说过树剖，当时觉得实在是太高大上了，但现在发现只是名字比较高端，整个原理还是很简单的，只是码量比较大。</p><p>作为蒟蒻，我在图论题中几乎都只会搜索，也靠着搜索在SCOI上拿了仅有的几十分。不过我好歹还是学过前缀和差分的，如果一个图中所有的点连成一条线，那么来找两个点之间路径长只需要维护前缀和就行了。如果一棵树中的结点都连成一条线，我们就把它称作链。如果把树上的结点分为若干条链，那么很多问题就可以变得简单多了。</p><p>所谓树链剖分就是将一棵树给剖分成若干条链，再分别处理。</p><p>当然，一个节点也是可以算一条链的，不过如果这样分还不如不分。树剖这个算法的目的，便是将一棵树中每一个非叶节点分到链中，并且每一个节点都只属于一条链，这样查询起来又可以快很多。</p><p>在这里给出一棵树（图源百度百科）：</p><p><img src="https://cdn.uniqueue.cn/shupou.jpg" alt="树剖"></p><p>在这张图中，粗线即为分成的链。要让每一个非叶节点在链上，我们就需要让一条链尽可能覆盖更多节点。所以在每一个节点的子节点中，我们选<strong>以它为根的子树节点个数最多</strong>的子节点来连成链。</p><p>比如在4号节点的子节点{8,9,10}中，以8和以10为根的子树的节点总个数为1，而以9为根的子树节点个数为3，所以我们就将9作为链上的一个节点继续向下连接。9就被称为是4号节点的<strong>重节点</strong>，其他的两个节点就被称作<strong>轻节点</strong></p><p>继续扩展，父节点和重节点间的连线被称作<strong>重边</strong>，就是粗线；父节点和轻结点的连线被称作<strong>轻边</strong>，就是图中的细线；多条重边连接起来的路径叫<strong>重链</strong>，如路径1-&gt;4-&gt;9-&gt;13-&gt;14；多条轻边连接起来的路径叫<strong>轻链</strong>，如路径1-&gt;2-&gt;5。</p><p>通过一个表格将这些定义总结一下</p><div class="table-container"><table><thead><tr><th style="text-align:center">定义</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">重节点</td><td style="text-align:center">以它为根的子树节点个数最多的节点</td></tr><tr><td style="text-align:center">轻节点</td><td style="text-align:center">所有子节点中不是重节点的节点</td></tr><tr><td style="text-align:center">重边</td><td style="text-align:center">父节点和重节点间的连线</td></tr><tr><td style="text-align:center">轻边</td><td style="text-align:center">父节点和轻结点的连线</td></tr><tr><td style="text-align:center">重链</td><td style="text-align:center">多条重边连接起来的路径</td></tr><tr><td style="text-align:center">轻链</td><td style="text-align:center">多条轻边连接起来的路径</td></tr></tbody></table></div><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们使用两次dfs就能实现剖分，但是只剖分的话是并没有什么卵用的，一般题目中还会涉及到两节点间的权值和，权值最大值等问题。这里以 <a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">洛谷P3384【模板】树链剖分</a> 为例。</p><h3 id="剖分"><a href="#剖分" class="headerlink" title="剖分"></a>剖分</h3><p>首先先解释下我使用的变量</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">fa[x]</td><td style="text-align:center">x号节点的父亲</td></tr><tr><td style="text-align:center">son[x]</td><td style="text-align:center">x号节点的重儿子（节点）</td></tr><tr><td style="text-align:center">size[x]</td><td style="text-align:center">以x号节点为根的子树中节点个数</td></tr><tr><td style="text-align:center">deep[x]</td><td style="text-align:center">x号节点的深度</td></tr><tr><td style="text-align:center">top[x]</td><td style="text-align:center">x号节点所在的链顶的节点编号</td></tr><tr><td style="text-align:center">w[x]</td><td style="text-align:center">x号节点的原权值</td></tr><tr><td style="text-align:center">wnew[x]</td><td style="text-align:center">dfs序中第x号节点的权值</td></tr><tr><td style="text-align:center">id[x]</td><td style="text-align:center">x号节点的dfs序</td></tr><tr><td style="text-align:center">edge[]和head[]</td><td style="text-align:center">链式前向星数组</td></tr><tr><td style="text-align:center">tree[]</td><td style="text-align:center">线段树</td></tr></tbody></table></div><p>先进行第一次dfs，需要完成的任务是</p><ol><li>确定这个点的深度</li><li>确定父亲节点</li><li>确定以这个节点为根的子树中节点个数</li><li>确定这个点的重儿子</li></ol><p>具体实现方式见代码</p><pre><code class="lang-cpp">void dfs1(int x,int f,int depth){    deep[x]=depth;//深度    fa[x]=f;//父亲节点    size[x]=1;//子树节点个数至少有一个    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];//节点个数加上子节点的        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}</code></pre><p>然后是第二次dfs。需要完成的任务是</p><ol><li>确定新编号（dfs序）</li><li>赋权值到新编号上</li><li>确定这个点所在的链的顶端</li><li>处理每一条链</li></ol><p>还是看代码吧</p><pre><code class="lang-cpp">void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}</code></pre><blockquote><p>先处理重儿子是为了保证每一条链都是被连续处理的</p></blockquote><p>好了，剖分就结束了，<span style="text-decoration:line-through;">是不是很简单啊</span></p><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><h4 id="操作1，2"><a href="#操作1，2" class="headerlink" title="操作1，2"></a>操作1，2</h4><p>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</p><p>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</p><p>在处理u和v号节点之间路径上所有节点时，我们一般先让u和v属于同一条链，然后因为dfs序的特点就可以直接用线段树处理了。</p><p>让u和v顶端相同的方法是将u和v中较深的节点往上跳到这条链顶端的上方，跳完一个再交换跳下一个。每次更改或查询只要更改当前跳的节点到它所在链的顶端即可，最后到一条链上了以后直接处理两点之间就行了。</p><p>代码如下：</p><blockquote><p>注：我的线段树是左闭右开区间，即表示[left,right)，所以处理时右边要+1</p></blockquote><p>操作1</p><pre><code class="lang-cpp">void uprange(int u,int v,int delta){    delta%=p;//按题意取%    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换为更深的点        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];//向上跳    }    if (deep[u]&gt;deep[v]) swap(u,v);//交换为更深的点保证u的dfs序在前    change(1,id[u],id[v]+1,delta);}</code></pre><p>操作2</p><pre><code class="lang-cpp">int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}</code></pre><h4 id="操作3，4"><a href="#操作3，4" class="headerlink" title="操作3，4"></a>操作3，4</h4><p>可以根据dfs序的性质直到，子树区间右端点为id[x]+siz[x]-1，直接处理即可。</p><p>代码：</p><p>操作3</p><pre><code class="lang-cpp">inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}</code></pre><p>操作4</p><pre><code class="lang-cpp">inline int qson(int u){    return query(1,id[u],id[u]+size[u]);}</code></pre><h3 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h3><ol><li>在一些没有指定根的问题中其实以任意节点为根都是可以的</li><li>根节点开始dfs时可以以0作为它的根，顶端就是它本身</li><li>一定要记得<strong>先dfs在建树</strong>，因为线段树是处理dfs序的</li></ol><pre><code class="lang-cpp">dfs1(root,0,1);dfs2(root,root);build(1,1,n+1);</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int next,to;} edge[200005];int fa[200005],size[200005],deep[200005],w[200005],wnew[200005],head[200005],son[200005],id[200005],top[200005];struct Tree{    int left,right,sum,delta;} tree[800005];int cnt=1,ans,n,m,a,b,c,d,p,dfsord,root;inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    if (r-l==1) tree[x].sum=wnew[l];    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}inline void update(int x){    tree[x*2].sum+=tree[x].delta*(tree[x*2].right-tree[x*2].left);    tree[x*2+1].sum+=tree[x].delta*(tree[x*2+1].right-tree[x*2+1].left);    tree[x*2].sum%=p;    tree[x*2+1].sum%=p;    tree[x*2].delta+=tree[x].delta;    tree[x*2+1].delta+=tree[x].delta;    tree[x].delta=0;}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        tree[x].delta+=delta;        tree[x].sum+=delta*(tree[x].right-tree[x].left);        tree[x].sum%=p;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].sum%p;    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        return ans%p;    }}               /*  dfs1    标记每个点的深度dep[]       标记每个点的父亲fa[]    标记每个非叶子节点的子树大小(含它自己)        标记每个非叶子节点的重儿子编号son[]*/void dfs1(int x,int f,int depth){    deep[x]=depth;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}/*  dfs2    标记每个点的新编号    赋值每个点的初始值到新编号上    处理每个点所在链的顶端    处理每条链*/void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}void uprange(int u,int v,int delta){    delta%=p;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}inline int qson(int u){    return query(1,id[u],id[u]+size[u]);//子树区间右端点为id[x]+siz[x]-1 }inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}int main(){    memset(head,-1,sizeof(head));    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;root,&amp;p);    for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);        add(b,a);    }    dfs1(root,0,1);    dfs2(root,root);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d&quot;,&amp;a);        if (a==1)        {            scanf(&quot;%d%d%d&quot;,&amp;b,&amp;c,&amp;d);            uprange(b,c,d);        }        if (a==2)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            //cout&lt;&lt;wnew[id[b]]&lt;&lt;&quot; &quot;&lt;&lt;wnew[id[c]]&lt;&lt;endl;            printf(&quot;%d\n&quot;,qrange(b,c));        }        if (a==3)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            upson(b,c);        }        if (a==4)        {            scanf(&quot;%d&quot;,&amp;b);            printf(&quot;%d\n&quot;,qson(b));        }    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新……</p>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LCA问题总结</title>
      <link href="/p/lca.html"/>
      <url>/p/lca.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近公共祖先（LCA）问题指的是在一棵树中，求出任意两个点的最近的公共祖先。如在下图中：</p><p><img src="https://cdn.uniqueue.cn/lca.png" alt="LCA"></p><p>2号节点和1号节点的LCA是4,3号和2号的LCA也是4.</p><p>求LCA的方法主要有：暴力，倍增，RMQ和Tarjan。</p><p>这篇文章以<a href="https://www.luogu.org/problemnew/show/P3379" target="_blank" rel="noopener">洛谷P3379 【模板】最近公共祖先（LCA）</a>为例。</p><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><p>Tarjan算法能够通过dfs将树上节点信息和查询的信息一次性解决，但是无法应对存在修改的情况，所以是一种离线算法。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>从根节点开始，遍历每一个它的子节点；</li><li>一直递归到叶节点，再从叶节点开始将它和它的父节点运用并查集合并；</li><li>又从当前遍历到的节点u开始，遍历每一个和它有询问关系的节点。如果另一个节点v被访问过，那么u和v的LCA就是v的先前通过并查集找到的祖先。</li></ol><h3 id="细节与实现"><a href="#细节与实现" class="headerlink" title="细节与实现"></a>细节与实现</h3><ol><li>注意记录这个节点是否被访问过，防止重复访问。</li><li>输入没有指明哪个是父节点哪个是子节点，所以需要进行双向储存，空间也要随之开两倍。</li><li>由于需要遍历子节点，我采用链式前向星的方法进行储存；同样，还需要遍历有查询关系的点，查询关系也需要用一个链式前向星。</li><li>这道题中，有多组询问，还要求按照询问的顺序输出，所以解决每个答案的顺序是至关重要的。我起先想了很久怎么解决这个问题，后来才想起链式前向星也是有顺序的。但是由于每一次询问都存了两次，所以更新LCA答案时要将相邻的一对询问都更新，输出时也只能输出一次。</li><li>要处理相邻两个询问的LCA，将本次查询到的节点i和i^1节点更新即可。因为<code>[i,i^1]∈[k*2,k*2+1],k∈Z</code>，i^1即为i在同组中另一项，反之也成立。举个例子：</li></ol><pre><code>0^1=1,1^1=0 [0,1]2^1=3,3^1=2 [2,3]</code></pre><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int to,next;} edge[1000005];struct Edge2{    int to,next,lca;} ask[1000005];//链式前向星储存bool vis[500005];int f[500005];int head[1000005],hask[1000005];int n,m,a,b,c,cnte,cnta,root;inline void addedge(int u,int v){    edge[cnte].to=v;    edge[cnte].next=head[u];    head[u]=cnte++;}inline void addask(int u,int v){    ask[cnta].to=v;    ask[cnta].next=hask[u];    hask[u]=cnta++;}int find(int x){    if (f[x]==x) return f[x];    f[x]=find(f[x]);    return f[x];}void merge(int x,int y){    if (find(x)!=find(y)) f[find(x)]=find(y);}void tarjan(int u){    vis[u]=true;//记录已经访问    for (int i=head[u];i!=-1;i=edge[i].next)     if (!vis[edge[i].to])    {        tarjan(edge[i].to);//继续向下遍历        merge(edge[i].to,u);//合并    }    for (int i=hask[u];i!=-1;i=ask[i].next)    if (vis[ask[i].to]) ask[i].lca=ask[i^1].lca=find(ask[i].to);//i^1的含义是(0,1),(1,2)这些组的另一项}int main(){    memset(vis,false,sizeof(vis));    memset(head,-1,sizeof(head));    memset(hask,-1,sizeof(hask));    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;root);    for (int i=1;i&lt;=n;i++) f[i]=i;    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addedge(a,b);        addedge(b,a);    }    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addask(a,b);        addask(b,a);    }    tarjan(root);    for (int i=0;i&lt;m*2;i+=2) printf(&quot;%d\n&quot;,ask[i].lca);//因为加入两次，而相邻两次的lca又相同    return 0;}</code></pre><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-LCA </tag>
            
            <tag> 算法-Tarjan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RMQ问题_ST表总结</title>
      <link href="/p/rmq-st.html"/>
      <url>/p/rmq-st.html</url>
      
        <content type="html"><![CDATA[<h2 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h2><p>RMQ问题是指多次询问一个区间中最小或最大值的问题。但是因为不包括修改，只涉及离线操作，所以线段树或者树状数组显得有一些多余了。而且数列中的元素个数可能非常大，像线段树开四倍空间肯定是要MLE的。这里介绍一种高效的ST表来解决这种问题。</p><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>我的理解：ST表运用<strong>动态规划和二分</strong>的思想来完成。</p><p>ST表查询问题包含初始化和查询操作，其中初始化的时间复杂度为<code>O(n*logn)</code>，查询的时间复杂度仅为<code>O(1)</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要运用动态规划来完成。</p><p>我们将原来的数列用a[]储存，同时定义一个二维的<code>f[][]</code>数组，<code>f[i][j]</code>表示从第i个数起连续2^j个数中的最值，即储存<code>[i,i+2^j-1]</code>中的最值。然后我们就可以使用f数组进行动态规划。</p><h4 id="起始状态"><a href="#起始状态" class="headerlink" title="起始状态"></a>起始状态</h4><p>我们知道<code>2^0=1</code>，所以当j=0时，<code>f[i][j]</code>其实储存的就是第i项的值，这就成了我们初始化的依据。初始化可以这么写：</p><pre><code class="lang-cpp">for (int i=1;i&lt;=n;i++) f[i][0]=a[i];</code></pre><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>前面已经说过，这个状态转移的实质就是二分。在这里，我们将<code>[i,i+2^j-1]</code>二分为<code>[i,i+2^(j-1)-1]</code>和<code>[i+2^(j-1),i+2^j-1]</code>。因为每个区间中的项数在j!=0时一定是偶数，所以这样一定能分为两段项数相同的区间。于是我们得到了状态转移方程<code>f[i, j]=max(f[i,j-1], f[i+2^(j-1),j-1])</code>。状态转移可以这么写：</p><pre><code class="lang-cpp">for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);</code></pre><blockquote><p>其中1&lt;&lt;j就是2^j</p></blockquote><p>但是为什么j要写在外层循环呢？</p><p>因为这个状态转移的实质是：先更新所有长度为<code>f[i][0]</code>即1个元素，然后通过2个1个元素的最值，获得所有长度为<code>f[i][1]</code>即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为<code>f[i][2]</code>即4个元素的最值，以此类推更新所有长度的最值。</p><p>而如果是i在外，j在内的话，我们更新的顺序就是<code>f[1][0],f[1][1],f[1][2],f[1][3]</code>表示更新从1开始1个元素，2个元素，4个元素，8个元素的最值，这里<code>f[1][3]=min(min(a[0],a[1],a[2],a[3]),min(a[4],a[5],a[6],a[7]))</code>的值，但是我们根本没有计算<code>min(a[0],a[1],a[2],a[3])</code>和<code>min(a[4],a[5],a[6],a[7])</code>，所以这样的方法肯定是错误的。</p><p>所以初始化就这么写：</p><pre><code class="lang-cpp">void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于查询<code>[l,r]</code>这个区间中的最值，我们也可以将其分为两部分，再分别取两部分的最值来得到整个区间的最值。</p><p>我们取一个值<code>k=log2(r-l+1)</code>，并将k作为二分的中点，将<code>[l,r]</code>这个区间分为<code>[l,k]</code>和<code>[r-2^k+1,k]</code>这两段。可以很显然的发现，这两段是有重复的，但是对结果没有任何影响。</p><p>查询可以这么写：</p><pre><code class="lang-cpp">inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}</code></pre><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>以<a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865 【模板】ST表</a>为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int f[100005][20];int n,m,b,c;void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    st(n);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;b,&amp;c);        printf(&quot;%d\n&quot;,query(b,c));    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-RMQ </tag>
            
            <tag> 数据结构-ST表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解-洛谷P1309 瑞士轮</title>
      <link href="/p/luogu-solution-p1309.html"/>
      <url>/p/luogu-solution-p1309.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1309" target="_blank" rel="noopener">原题链接</a> <a href="https://www.luogu.org/blog/llf/solution-p1309" target="_blank" rel="noopener">洛谷博客该题解链接</a></p><hr><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。</p><p>本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>2*N 名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。</p><p>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K – 1 名和第 2K名、…… 、第2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。</p><p>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件名为swiss.in 。</p><p>输入的第一行是三个正整数N、R 、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。</p><p>第二行是2<em>N 个非负整数s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为i 的选手的初始分数。 第三行是2</em>N 个正整数w1 , w2 , …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件名为swiss.out。</p><p>输出只有一行，包含一个整数，即R 轮比赛结束后，排名第 Q 的选手的编号。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>2 4 2 7 6 6 7 10 5 20 15</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>1</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p><img src="https://cdn.luogu.org/upload/pic/98.png" alt="1309样例解释"></p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于30% 的数据，1 ≤ N ≤ 100；</p><p>对于50% 的数据，1 ≤ N ≤ 10,000 ；</p><p>对于100%的数据，1 ≤ N ≤ 100,000，1 ≤ R ≤ 50，1 ≤ Q ≤ 2N，0 ≤ s1, s2, …, s2N≤10^8，1 ≤w1, w2 , …, w2N≤ 10^8。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>Noip2011普及组第3题。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，每一轮过后次序都会被打乱，所以都需要重新排序。如果每次从头排序（用快排）则只能得60（同学亲测），所以快排不能解决这个问题。<br>仔细观察发现，不论是得分还是没得分，胜者和败者组成的序列肯定是有序的，那么每次将两个有序的序列组成一个新序列就行了，这便是归并算法可以直接解决的问题了。<br>先把第一次排序后的数据分为胜者败者两组，胜者分数++后合并，如此反复R次即可完成。<br>需要注意的是<strong>不要偷懒用队列</strong>，否则跟快排暴力得分一样，还是老老实实自己用数组模拟吧。<br>代码及注解如下：</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,r,q;struct ren{    int s,w,ord;};ren win[200005],lose[200005];ren info[200005];bool com(ren a,ren b){    if (a.s==b.s) return a.ord&lt;b.ord;    else return a.s&gt;b.s;}int main(){    cin&gt;&gt;n&gt;&gt;r&gt;&gt;q;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].s;    for (a=1;a&lt;=n*2;a++)    info[a].ord=a;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].w;    sort(info+1,info+n*2+1,com);//第一次排序可以用快排    for (a=1;a&lt;=r;a++)    {        for (b=1;b&lt;=n;b++)        {            if (info[b*2].w&gt;info[b*2-1].w)            {                info[b*2].s++;                win[b]=info[b*2];                lose[b]=info[b*2-1];            }            else            {                info[b*2-1].s++;                win[b]=info[b*2-1];                lose[b]=info[b*2];            }        }//分成win和lose两组        int e=0;        int i=1;        int j=1;        while (i&lt;=n&amp;&amp;j&lt;=n)        {            if (win[i].s&gt;lose[j].s)            {                e++;                info[e]=win[i];                i++;            }            else if (win[i].s&lt;lose[j].s)            {                e++;                info[e]=lose[j];                j++;            }            else if (win[i].s==lose[j].s)//特别注意要考虑分数相等的情况，把编号小的排在前面            {                e++;                if (win[i].ord&lt;lose[j].ord)                {                    info[e]=win[i];                    i++;                }                else if (win[i].ord&gt;lose[j].ord)                {                    info[e]=lose[j];                    j++;                }            }        }        if (i&gt;n)        while (j&lt;=n)        {            e++;            info[e]=lose[j];            j++;        }        if (j&gt;n)        while (i&lt;=n)        {            e++;            info[e]=win[i];            i++;        }    }//将原数组覆盖成比赛后的新数组    cout&lt;&lt;info[q].ord;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-归并排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几种排序方法总结</title>
      <link href="/p/sort.html"/>
      <url>/p/sort.html</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>第一次将每一个元素和它的后一个元素比较大小，如果不满足顺序则交换，这样即可确定最后一个数的位置。然后再从头开始，可以确定倒数第二个数的位置。循环n次后即可完成排序。因为每一轮排完序后都会确定一个，即“冒”出来一个，故被称作冒泡排序。<br><img src="https://cdn.uniqueue.cn/paixu1.jpg" alt="paixu1"><br>时间效率：O($n^{2}$)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>以  <a href="https://www.luogu.org/problemnew/show/P1116" target="_blank" rel="noopener">洛谷 P1116 车厢重组</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,ans;int f[10005];void change(int &amp;a,int &amp;b){    int c;    c=a;    a=b;    b=c;}int main(){    cin&gt;&gt;n;    for (a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    for (a=1;a&lt;=n;a++)      for (b=1;b&lt;=n-a;b++)//因为每次多确定一位，固少循环一次      if (f[b]&gt;f[b+1])      {          change(f[b],f[b+1]);          ans++;      }    cout&lt;&lt;ans;    return 0;}</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的原理非常简单，即将需排序的元素作为数组下标，直接输出就行了。<br><img src="https://cdn.uniqueue.cn/paixu2.jpg/" alt="paixu2"><br>时间效率：<code>O(n)</code> 但是需要很多额外空间</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。<br><img src="https://cdn.uniqueue.cn/paixu3.jpg/" alt="paixu3"><br><img src="https://cdn.uniqueue.cn/paixu4.jpg/" alt="paixu4"><br><img src="https://cdn.uniqueue.cn/paixu5.jpg/" alt="paixu5"><br>时间效率：最好：<code>O(log n)</code> 最坏：<code>O(n*log n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>以 <a href="https://www.luogu.org/problemnew/show/P1177" target="_blank" rel="noopener">洛谷 P1177 【模板】快速排序</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,p,i,j,k;queue &lt;int&gt; q;int f[100005];void merge_sort(int a,int b)//a是起点，b是终点{    int s;    if (a==b) return;    s=(a+b)/2;    merge_sort(a,s);    merge_sort(s+1,b);//递归调用    i=a;    j=s+1;    while (i&lt;=s&amp;&amp;j&lt;=b)    {        if (f[i]&gt;f[j])         {            q.push(f[j]);            j++;        }        else        {            q.push(f[i]);            i++;        }    }    if (i&gt;s)     for (int e=j;e&lt;=b;e++) q.push(f[e]);    if (j&gt;b)    for (int e=i;e&lt;=s;e++) q.push(f[e]);    k=a-1;    while (!q.empty())    {        k++;        f[k]=q.front();        q.pop();    }//归并算法}int main(){    cin&gt;&gt;n;    for (int a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    merge_sort(1,n);    for (int a=1;a&lt;=n;a++)    cout&lt;&lt;f[a]&lt;&lt;&quot; &quot;;    return 0;}</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>以第一个数组元素作为关键数据，赋值给key，即<code>key=A[0]</code>；</li><li>从j开始向前搜索，即由后开始向前搜索(j—)，找到第一个小于key的值<code>A[j]</code>，将<code>A[j]</code>和<code>A[i]</code>互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的<code>A[i]</code>，将<code>A[i]</code>和<code>A[j]</code>互换；</li><li>重复第3、4步，直到i=j，这样以后第i位上的数的前面比这个数小，后面比这个数大，即这个数位置已经确定；</li><li>将i前面和i后面的部分递归调用再次排序，直到排完。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">sort(A,A+N,com)//_huaji</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>拓扑排序</title>
      <link href="/p/topological-sort.html"/>
      <url>/p/topological-sort.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>拓扑排序是一种可以将有先决条件（即必须将a、b排在前面后再排c，缺一不可）的数据变得有序的一种排序方法。拓扑排序仅可在有向无环图中使用，同时可以判断图中是否有环。因为顺序不同，拓扑排序得到的答案可能不同。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为排序是有先决条件的，所以可以将要有先决条件的个数（在图中即为入度）记录下来，每满足一个就减一，直到个数为0便可以将其放入序列中。</p><h2 id="手动实现"><a href="#手动实现" class="headerlink" title="手动实现"></a>手动实现</h2><p>如果我们有如下的一个有向无环图，我们需要对这个图的顶点进行拓扑排序，过程如下：</p><p><img src="https://cdn.uniqueue.cn/tuopu-1.png" alt="tuopu-1"></p><p>首先，我们发现V6和v1是没有前驱的，所以我们就随机选去一个输出，我们先输出V6，删除和V6有关的边，得到如下图结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-2.png" alt="tuopu-2"></p><p>然后，我们继续寻找没有前驱的顶点，发现V1没有前驱，所以输出V1，删除和V1有关的边，得到下图的结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-3.png" alt="tuopu-3"></p><p>然后，我们又发现V4和V3都是没有前驱的，那么我们就随机选取一个顶点输出（具体看你实现的算法和图存储结构），我们输出V4，得到如下图结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-4.png" alt="tuopu-4"></p><p>然后，我们输出没有前驱的顶点V3，得到如下结果：</p><p><img src="https://cdn.uniqueue.cn/tuopu-5.png" alt="tuopu-5"></p><p>然后，我们分别输出V5和V2，最后全部顶点输出完成，该图的一个拓扑序列为：</p><p>v6–&gt;v1—&gt;v4—&gt;v3—&gt;v5—&gt;v2</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>1.用邻接表存储数据，同时对终点的结点的入度加一；<br>2.将没有先决条件便可以排序的点（即初始入度为0的点）先加入队列并输出；<br>3.从队首元素开始扩展，将与队首元素相连的结点的入度减一（等同于擦除这条边），如果该结点入度变为0，则将其入队，作为下一次查找的起点；<br>4.将队首元素出队，当队首元素为空时停止排序。</p><h2 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h2><p>有n个点，m条边的有向无环图，输入n，m，然后每一行输入一条边的信息：起点x，终点y</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,re;struct map1{    int stat,end;};map1 tu[100];int rd[100],chong[100];queue &lt;int&gt; q;int main(){    cin&gt;&gt;n&gt;&gt;m;//n点m边    for (a=1;a&lt;=m;a++)    {        cin&gt;&gt;tu[a].stat&gt;&gt;tu[a].end;        rd[tu[a].end]++;    }    for (int i=1;i&lt;=n;i++)    if (rd[i]==0) q.push(i);//将初始入度为0的结点入队    while (!q.empty())    {            cout&lt;&lt;q.front()&lt;&lt;&quot; &quot;;            for (int j=1;j&lt;=m;j++)            {                if (tu[j].stat==q.front())//找以队首元素为起点的边                {                    rd[tu[j].end]--;                    if (rd[tu[j].end]==0)                     {                        q.push(tu[j].end);                    }                }            }        q.pop();    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法-拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树总结</title>
      <link href="/p/minimum-spanning-tree.html"/>
      <url>/p/minimum-spanning-tree.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>最小生成树即为无向图中结点构成的树中各边权值之和最小的树，可以有多种情况。一般用Kruskal（克鲁斯卡尔）算法或Prim（普里姆）算法求出。</p><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>可以将Kruskal算法理解成对边的贪心算法。</p><p>1.将路径用邻接表存储，存储的值为起点、终点和权值；<br>2.将邻接表按照权值为关键字排序；<br>3.从最小权值的边开始循环，每连接起两个结点就把它们并到同一个集合（并查集实现），连接之前判断它们是否已经直接或间接相连（是否同一祖先），如没有相连则连上；<br>4.判断能否构成树：如果所以结点的祖先相同则能，反之则不能构成树。</p><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><p>示例题目：<a href="https://www.luogu.org/problemnew/show/P3366" target="_blank" rel="noopener">洛谷 P3366 【模板】最小生成树</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y,z,a,b,c,k,ans;int f[5005];struct lj{    int qi,zhong,zhi;};//邻接表存储lj map1[200005];bool com(lj a,lj b){    return a.zhi&gt;b.zhi;}//以权值为关键字排序int zx(int a){    if(a==f[a]) return a;    else     {        f[a]=zx(f[a]);        return f[a];    } }//并查集查找祖先int main(){    cin&gt;&gt;n&gt;&gt;m;    for (a=1;a&lt;=n;a++)    f[a]=a;    for (a=1;a&lt;=m;a++)    {        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;        map1[a].qi=x;        map1[a].zhong=y;        map1[a].zhi=z;    }    sort(map1,map1+m+1,com);//排序    while (m&gt;0)    {        x=map1[m].qi;        y=map1[m].zhong;        if (zx(x)!=zx(y)) //查找祖先以确定是否相连        {            f[zx(y)]=zx(x);//连接，统一祖先            ans+=map1[m].zhi;//加上权值        }        m--;    }    for (a=2;a&lt;=n;a++)    if (zx(a)!=zx(1))    {        cout&lt;&lt;&quot;orz&quot;;        return 0;    }//判断能否构成树，只有每一个结点祖先和第一个结点祖先相同，则所有结点祖先都相同    cout&lt;&lt;ans;    return 0;}</code></pre><blockquote><p>upd:2018.10.23 今天来把这个大半年的坑给填了。咕咕咕</p></blockquote><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>每次找到与当前点连接的点中权值最小且没被查找过的点进行拓展，记录一下当前点是否已经被查找过，如果全部查找完了就结束了。</p><p>过程和Dijkstra算法的堆优化写法很像，可以用一个优先队列来维护队列中权值最小的点，然后BFS即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define pr pair&lt;int,int&gt;#define mp make_pairusing namespace std;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}struct Edge{    int next,to,w;} edge[400005];int n,m,a,b,c,cnt,ct,head[5005],ans,mn[5005];bool vis[5005];inline void add(int u,int v,int w){    edge[++cnt].to=v;    edge[cnt].w=w;    edge[cnt].next=head[u];    head[u]=cnt;}inline void prim(){    priority_queue &lt;pr,vector&lt;pr&gt;,greater&lt;pr&gt; &gt; q;    q.push(mp(0,1));    for (int i=1;i&lt;=n;i++) mn[i]=1e9;    mn[1]=0;    memset(vis,0,sizeof(vis));    while (!q.empty() &amp;&amp; ct&lt;n)    {        int x=q.top().second,qf=q.top().first; q.pop();        if (vis[x]) continue;        ans+=qf;        ct++;        vis[x]=1;        for (int i=head[x];i;i=edge[i].next)        {            int y=edge[i].to,w=edge[i].w;            if (w&lt;mn[y])            {                mn[y]=w;                q.push(mp(mn[y],y));            }        }    }}int main(){    n=read(); m=read();    for (int i=1;i&lt;=m;i++)    {        a=read(); b=read(); c=read();        add(a,b,c);        add(b,a,c);    }    prim();    if (ct==n) printf(&quot;%d&quot;,ans);    else printf(&quot;orz&quot;);    return 0;}</code></pre><blockquote><p>感觉自己码风变化真大，寒假的时候还是太naive了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题-最小生成树 </tag>
            
            <tag> 算法-Kruskal </tag>
            
            <tag> 算法-Prim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOIp2017爆炸记</title>
      <link href="/p/noip2017-summary.html"/>
      <url>/p/noip2017-summary.html</url>
      
        <content type="html"><![CDATA[<h3 id="Day-N"><a href="#Day-N" class="headerlink" title="Day -N"></a>Day -N</h3><p>去年只参加PJ，凑巧拿了个一。今年第一次参加TG，还有在<del>徐妈的逼迫下</del>又参加了PJ，还想拿个高分（事实上死的很惨）</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>就复习了点简单的东西（毕竟考前三天才学会c++的文件，P转C的痛苦），中午大半时间在颓2048，感觉什么都没干</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>上午TG。妈的我第一题找了大半个小时都没找出规律就打了个暴力了事；第二题纯种模拟，二十多个变量，样例都过了，<strong>当时</strong>感觉应该没有问题；第三题直接没时间了，tan90°。中午一对答案发现就是个扩展欧几里得，连高精度都不用，数学没学好很无奈啊。<br>中午和WZX绕着电子渴基大学走了一大圈，回来考PJ。第一题<del>真难没看懂</del>；第二题15分钟不到水完，事实上后来发现endl都没有打，20分；第三题深搜，过了样例，感觉还行；第四题不会，打了个暴力走人，感觉50分的数据应该能过。估分350。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>上午去晚了，连集合都没赶上就冲进了考场，整的还有人来问我“XX学校的Llf同学来了没有”，真的尴尬死了。先看了下题，选第三题分两种情况打了个暴力，期望40；然后第一题深搜（然而却并忘了剪枝而爆炸）；第二题乱搞的DP方程过了样例结果发现是错的。感觉就要炸。</p><h3 id="Day-N-爆炸实况"><a href="#Day-N-爆炸实况" class="headerlink" title="Day N 爆炸实况"></a>Day N 爆炸实况</h3><p>第二周的星期天就拿到了我的代码。先对PJ，第一题第二题都没测，第三题测出来出了点问题只有20，第四题发现交错程序了（因为我先打了个骗分版本）珂谷数据10分。感觉只有230了。然后测TG Day1第一题测出来50，第二题20；Day2第一题40（然后绝望的发现我没有剪枝）；第二题爆0；第三题只有30。当时很绝望，但是这不是最惨的时候。<br>到了学校测了PJ的一二题，惊讶的发现第二题只有20，然后绝望的发现并没有换行。我还能说些什么……<br>后来出了官方数据，第三题测出来50还是给了我点安慰，170，绝望的分数。<br>然后TG用官方数据更加炸。105……<br>然后一直绝望了一周。平时感觉自己还行，TG不说有一等起码二等也应该有。后来仔细想了一下，<strong>对PJ的轻视，对TG的畏惧</strong>是主要原因。如果不这样，我也不至于PJ第二题根本不检查，TGD1T1连找规律都不敢。<br>半期也炸掉了，历史最差名次，又被cm姐批了一顿。<br>后悔吗？不！因为</p><blockquote><p>自己选择的路，跪着也要走完</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记-NOIp </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>我是Llf，最弱的蒟蒻，完了</p><p>本博客部分文章的markdown源文件均可通过将 <code>https://llf0703.com/p/*.html</code>改为 <code>https://md.llf0703.com/p/*.md</code> 查看</p><p>这个东西会不时更新，也许有的最新文章看不了</p><p><a href="https://bzoj.llf0703.com/" target="_blank" rel="noopener">BZOJ离线题库（By ruanxingzhi）</a></p><p>CSDN博客:  <a href="https://blog.csdn.net/Llf_0703" target="_blank" rel="noopener">Llf_0703</a></p><p>luogu:  <a href="https://www.luogu.org/space/show?uid=29696" target="_blank" rel="noopener">Llf0703</a></p><p>BZOJ:  <a href="https://www.lydsy.com/JudgeOnline/userinfo.php?user=Llf0703" target="_blank" rel="noopener">Llf0703</a></p><p>Bilibili： <a href="https://space.bilibili.com/268840304/" target="_blank" rel="noopener">Llf030703</a></p><p>逼乎:  <a href="https://www.zhihu.com/people/llf-93-87/" target="_blank" rel="noopener">Llf</a></p><p>Coding:  <a href="https://coding.net/u/Llf0703" target="_blank" rel="noopener">Llf0703</a></p><p>Gayhub:  <a href="https://github.com/Llf0703" target="_blank" rel="noopener">Llf0703</a></p>]]></content>
      
    </entry>
    
    <entry>
      <title>咕咕咕</title>
      <link href="/gugugu/index.html"/>
      <url>/gugugu/index.html</url>
      
        <content type="html"><![CDATA[<h1>    <center> 蒟蒻Llf0703鸽了这篇文章 </center></h1><p>这不是404，只是用作占坑文章的临时页面，请返回上一页。</p>]]></content>
      
    </entry>
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>标签云</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>时间轴</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
