<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>基础数论学习总结</title>
      <link href="/p/number-theory.html"/>
      <url>/p/number-theory.html</url>
      <content type="html"><![CDATA[<p>原本打算先学Splay的，但想到提高组一般不考，而且我其它东西还差的多，就先把基础数论的东西复习一下，并且加深一下难度，<del>还做了n多道水题，虽然主要是之前没过的</del>。</p><hr><h2 id="1-整除"><a href="#1-整除" class="headerlink" title="1.整除"></a>1.整除</h2><p>这里就把整除的性质列一下：</p><ol><li>如果$a \mid b$且$b \mid c$，那么$a \mid c$</li><li>$a \mid b$且$a \mid c$等价于$\forall x,y$，有$a \mid (b \times x + c \times y)$</li><li>设$m\neq 0$,那么$a \mid b $等价于$(m \times a) \mid (m \times b)$</li><li>设$x,y$满足$a \times x+b \times y=1$且$a \mid n,b \mid n$，那么$(a \times b) \mid n$</li><li>若$b=q \times d+c$,那么$d \mid b$的充要条件是$d \mid c$</li></ol><h2 id="2-同余"><a href="#2-同余" class="headerlink" title="2.同余"></a>2.同余</h2><p>同余性质：</p><ol><li>自反性 $a\equiv a(mod m) $</li><li>对称性 若$a\equiv b(mod m)$则$b\equiv a(mod m)$</li><li>传递性 若$a\equiv b(mod m),b\equiv c(mod m)$，则$a\equiv c(mod m)$</li><li>同加性 若$a\equiv b(modm)$，则$a+c\equiv b+c(modm)$</li><li>同乘性(1) 若$a\equiv b(modm)$，则$a\times c\equiv b\times c(modm)$ </li><li>同乘性(2) 若$a\equiv b(modm),c\equiv d(modm)$ ，则$a\times c\equiv b\times d(modm)$</li><li>同幂性 若$a\equiv b(modm)$，则$a^{n}\equiv b^{n} (modm)$</li></ol><h2 id="3-最大公约数-gcd"><a href="#3-最大公约数-gcd" class="headerlink" title="3.最大公约数(gcd)"></a>3.最大公约数(gcd)</h2><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><p>基础方法，不再赘述</p><pre><code class="lang-cpp">int gcd(int a,int b){    if (b==0) return a;    return gcd(b,a%b);}</code></pre><h3 id="二进制算法"><a href="#二进制算法" class="headerlink" title="二进制算法"></a>二进制算法</h3><p>不断去除因数2来提高gcd的效率</p><pre><code class="lang-cpp">inline int gcd(int x,int y){    int i,j;    if (x==0) return y;    if (y==0) return x;    for (i=0;0==(x&amp;1);i++) x&gt;&gt;=1;//去掉2    for (j=0;0==(y&amp;1);j++) y&gt;&gt;=1;    if (i&gt;j) i=j;    for (;;)    {        if (x&lt;y) x^=y,y^=x,x^=y;        if (0==(x-=y)) return y&lt;&lt;i;//如果x==y gcd==x==y        while (0==(x&amp;1)) x&gt;&gt;=1;    }}</code></pre><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>扩展欧几里得算法用来在已知$(a,b)$，求$(x,y)$，使$a\times x+b\times y=gcd(a,b)$</p><pre><code class="lang-cpp">void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}</code></pre><p>例题：<a href="https://www.luogu.org/problemnew/show/P1516" target="_blank" rel="noopener">洛谷P1516 青蛙的约会</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,a,b,c,x,y,l,X,Y;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline LL exgcd(LL l,LL r,LL &amp;X,LL &amp;Y){    if (r==0)    {        X=1; Y=0;        return l;    }    LL a=exgcd(r,l%r,Y,X);    Y-=l/r*X;    return a;}int main(){    x=read(); y=read(); m=read(); n=read(); l=read();    LL deltav=(m&gt;=n) ? m-n : n-m;    LL deltas=(m&gt;=n) ? y-x : x-y;    LL k=exgcd(deltav,l,X,Y);    if (deltas%k!=0) printf(&quot;Impossible&quot;);    else printf(&quot;%lld&quot;,(X*(deltas/k)%(l/k)+(l/k))%(l/k));    return 0;}</code></pre><h2 id="4-逆元"><a href="#4-逆元" class="headerlink" title="4.逆元"></a>4.逆元</h2><p>若$a\times x\equiv 1(modb)$，就称x是a的逆元。</p><p>可以将这个式子转化为$a\times x+b\times y=1$，然后用扩展欧几里得定理求解。</p><p>当然也有一种线性算法，在需要求连续逆元时是最优的算法。</p><blockquote><p>以下内容来自<a href="https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan" target="_blank" rel="noopener">https://www.luogu.org/blog/zjp-shadow/cheng-fa-ni-yuan</a></p></blockquote><hr><p>首先我们有一个, $1^{-1}\equiv 1(\bmod p)$</p><p>然后设 $p=k∗i+r,r&lt;i,1&lt;i&lt;p$ ,再将这个式子放到 $\bmod {p}$ 意义下就会得到：</p><p>$k∗i+r≡0(modp)$</p><p>然后乘上 $i^{-1} , r^{-1}$ 就可以得到:</p><p>$k*r^{-1}+i^{-1}\equiv 0 (\bmod p)$</p><p>$i^{-1}\equiv -k*r^{-1} (\bmod p)$</p><p>$i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} (\bmod p)$</p><hr><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3811" target="_blank" rel="noopener">洛谷P3811 【模板】乘法逆元</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,p,inv[3000005];int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;p);    inv[1]=1;    printf(&quot;%d\n&quot;,inv[1]);    for (int i=2;i&lt;=n;i++)    {        inv[i]=-(p/i)*inv[p%i];        inv[i]=(inv[i]%p+p)%p;        printf(&quot;%d\n&quot;,inv[i]);    }    return 0;}</code></pre><h2 id="5-中国剩余定理"><a href="#5-中国剩余定理" class="headerlink" title="5.中国剩余定理"></a>5.中国剩余定理</h2><p>还是就放一个我看的吧</p><p><a href="https://blog.csdn.net/acdreamers/article/details/8050018" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/8050018</a></p><p>例题：<a href="https://www.luogu.org/problemnew/show/P3868" target="_blank" rel="noopener">洛谷P3868 [TJOI2009]猜数字</a></p><p>可以用裸的中国剩余定理来做，但是要注意必须用快速乘，不然$10^{18}\times 10^{18}$肯定会超范围。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n,m,k;LL A[15],B[15];inline LL read(){    char ch=getchar();    LL f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void exgcd(LL l,LL r,LL &amp;x,LL &amp;y){    if (r==0) x=1,y=0;    else    {        exgcd(r,l%r,y,x);        y-=l/r*x;    }}inline LL gcd(LL a,LL b){    if (b==0) return a;    return gcd(b,a%b);}inline LL qmul(LL a,LL b,LL mod){    LL ans=0,k=a,f=1;    if (k&lt;0) k=-k,f*=-1;    if (b&lt;0) b=-b,b*=-1;    while (b)    {        if (b&amp;1) ans=(ans+k)%mod;        k=(k+k)%mod;        b&gt;&gt;=1;    }    return ans*f;}inline LL crt(){    LL M=1,ans=0;    for (int i=1;i&lt;=k;i++) M*=B[i];    for (int i=1;i&lt;=k;i++)    {        LL x,y,Mi=M/B[i];        exgcd(Mi,B[i],x,y);        x=(x%B[i]+B[i])%B[i];        ans=(ans+qmul(qmul(Mi,x,M),A[i],M))%M;    }    return (ans&lt;0)?ans+M:ans;}int main(){    k=read();    for (int i=1;i&lt;=k;i++) A[i]=read();    for (int i=1;i&lt;=k;i++) B[i]=read();    for (int i=1;i&lt;=k;i++) A[i]=(A[i]%B[i]+B[i])%B[i];    printf(&quot;%lld&quot;,crt());    return 0;}</code></pre><h2 id="6-素数筛"><a href="#6-素数筛" class="headerlink" title="6.素数筛"></a>6.素数筛</h2><h3 id="普通筛法"><a href="#普通筛法" class="headerlink" title="普通筛法"></a>普通筛法</h3><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    int cnt=1;    ss[0]=ss[1]=false;    for (a=2;a&lt;=sqrt(n);a++)    {        if (ss[a]) zs[cnt++]=a;        for (b=2;b&lt;=n/a;b++) ss[a*b]=false;    }}</code></pre><h3 id="高效筛法"><a href="#高效筛法" class="headerlink" title="高效筛法"></a>高效筛法</h3><p>可以很容易的想到，普通筛法中筛了很多重复的数。而高效筛法可以减少重复（其实仍然有，只是少一些）。主要思路是运用得到了的素数来标记后面的合数。</p><pre><code class="lang-cpp">inline void getprime(){    memset(ss,true,sizeof(ss));    ss[0]=ss[1]=false;    for (int i=2;i&lt;=n;i++)    {        if (ss[i]) zs[cnt++]=i;        for (int j=1;j&lt;cnt &amp;&amp; zs[j]*i&lt;=n;j++) ss[zs[j]*i]=false;    }}</code></pre><p>以上内容更新于2018.5.9</p><hr>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>点分治总结</title>
      <link href="/p/dian-fen-zhi.html"/>
      <url>/p/dian-fen-zhi.html</url>
      <content type="html"><![CDATA[<p>markdown原文: <a href="https://md.llf0703.com/p/dian-fen-zhi.md" target="_blank" rel="noopener">https://md.llf0703.com/p/dian-fen-zhi.md</a></p><p>我自己感觉点分治是一种比较<del>玄学</del>神奇的算法，感觉自己也只是理解了一点皮毛而已。这里就谈谈点分治的实现方法和一些运用。</p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>点分治其实是将一棵树的点不断分为多棵子树，分别得到子树节点到子树根的距离来进行处理。</p><p>既然要有一个点为根节点，那么应该选取哪一个点呢？</p><p>既然要向下分治，如果把一个原来的叶节点作为分治的根节点，那么遍历每一个点的时间开销是非常大的。然而如果这个点的左右子树都达到最大，那么遍历的时间开销就要少很多。而<strong>子树的重心</strong>就能满足这个性质，所以我们选取<strong>子树的重心</strong>作为分治中心，即分治子树的根。</p><h3 id="1-求重心"><a href="#1-求重心" class="headerlink" title="1.求重心"></a>1.求重心</h3><p>首先我们需要了解重心是什么</p><blockquote><p>树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心，删去重心后，生成的多棵树尽可能平衡。— 百度百科</p></blockquote><p>提取关键词：</p><ol><li><strong>其所有的子树中最大的子树节点数最少</strong></li><li><strong>生成的多棵树尽可能平衡</strong></li></ol><p>第1点告诉我们怎么求重心，只需要记录每一个点的子树大小，然后按着定义做就行了。</p><p>第2点告诉我们选择重心作为分治点的原因，因为多棵树尽可能平衡，就可以使复杂度变得最优秀。</p><p>这个不是重点，直接上代码（感觉和树剖差不多）：</p><blockquote><p>这里可以先不管<code>vis[]</code>，后面会解释<br>sizenow是当前这个子树的大小，后面会讲到<br>mx是当前分治到的最大的子树节点最小值</p></blockquote><pre><code class="lang-cpp">void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)//遍历每一个子节点  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];//加上子节点的子树大小    son[x]=max(son[x],size[y]);//求最大的子树  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)//使最大的子树节点最少  {    mx=son[x];    root=x;//记录分治中心（根节点）  }}</code></pre><h3 id="2-进行分治"><a href="#2-进行分治" class="headerlink" title="2.进行分治"></a>2.进行分治</h3><p>分治其实就是一个递归，不断地将子树进行处理就行了，注意要用<code>vis[]</code>标记已经访问防止重复。先上代码：</p><blockquote><p>solve就是解决问题，每一道题有不同的作用，这里不用管。</p></blockquote><pre><code class="lang-cpp">void divide(int x){  vis[x]=true;//标记已访问  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];//得到当前树的大小，将mx和root初始化    getroot(y,0);//得到子树的分治中心    divide(root);//分治子树  }}</code></pre><p>至于为什么有两次solve，主要是为了去重。原因如下：</p><blockquote><p>以下内容来自<a href="https://blog.csdn.net/qq_39553725/article/details/77542223" target="_blank" rel="noopener">https://blog.csdn.net/qq_39553725/article/details/77542223</a></p></blockquote><hr><p>对于以下这棵树：<br><img src="https://cdn.uniqueue.cn/dian-fen-zhi.png" alt="点分治"><br>显然A点是它的重心。<br>我们假设现在分治到了A点（当前点为A）<br>我们一开始求解贡献时，会有以下路径被处理出来：<br>A—&gt;A<br>A—&gt;B<br>A—&gt;B—&gt;C<br>A—&gt;B—&gt;D<br>A—&gt;E<br>A—&gt;E—&gt;F (按照先序遍历顺序罗列)<br>那么我们在合并答案是会将上述6条路径两两进行合并。<br>这是注意到：<br>合并A—&gt;B—&gt;C 和 A—&gt;B—&gt;D 肯定是不合法的！！<br>因为这并不是一条树上(简单)路径，出现了重边，我们要想办法把这种情况处理掉。<br>处理方法很简单，减去每个子树的单独贡献。<br>例如对于以B为根的子树，就会减去：<br>B—&gt;B<br>B—&gt;C<br>B—&gt;D<br>这三条路径组合的贡献<br>读者可能会有疑问，这与上面的6条路径并不一样啊。<br>我们再回过头来看一看这两句代码：<br>ans = ans + solve(tr,0);<br>ans = ans - solve(v,t[i].len);<br>注意到了吧，solve函数的第二个初始值并不相同。<br>我们在处理子树时，将初始长度设为连接边长，这样做就相当于个子树的每个组合都加上了A—&gt;的路径，从而变得与上面一样。<br>个人认为这是点分治一个极其重要的地方，读者们一定要理解清楚。</p><hr><p>好了，分治就完了。不过和树剖一样，只是剖分完是并没有什么卵用的，还需要具体问题具体分析。</p><h2 id="具体例题"><a href="#具体例题" class="headerlink" title="具体例题"></a>具体例题</h2><h3 id="1-洛谷P3806-【模板】点分治1"><a href="#1-洛谷P3806-【模板】点分治1" class="headerlink" title="1.洛谷P3806 【模板】点分治1"></a>1.洛谷P3806 【模板】点分治1</h3><p>题目链接：<a href="https://www.luogu.org/problemnew/show/P3806" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3806</a></p><p>对于这道题询问的距离为k的点是否存在，我们可以用一种类似桶排序的笨方法，将距离作为数组下标，统计到这个距离就将数组++，最后不为0就存在，反之不存在。</p><p>要得到两点之间的距离，只需要记录两个点分别到根的距离，然后相加即可。</p><p>这里的query函数用作求当前分治到的树中点到根的距离，solve用于相加得到两点间距离并统计。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[20005];int size[20005],son[20005],dis[20005],head[20005];bool vis[20005];int sum[10000005];//存距离是否存在，注意大小和n不一样int n,m,k,a,b,c,ord,cnt=1,mx,root,sizenow;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (son[x]&lt;mx)  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  dis[++ord]=dist;//得到到根的距离  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w);//查询子节点  }}void solve(int x,int length,bool s) //s=false时要去重{  ord=0;  query(x,0,length);  for (int i=1;i&lt;=ord-1;i++)    for (int j=i+1;j&lt;=ord;j++)    {      if (s==true) sum[dis[i]+dis[j]]++;      else sum[dis[i]+dis[j]]--; //进行统计    }}void divide(int x){  vis[x]=true;  solve(x,0,1);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    solve(y,edge[i].w,0);    mx=2147483646;root=0;sizenow=size[y];    getroot(y,0);    divide(root);  }}int main(){  memset(vis,false,sizeof(vis));  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  root=0;mx=2147483646;sizenow=n;  getroot(1,0);  divide(root);  for (int i=1;i&lt;=m;i++)  {    a=read();    if (sum[a]) printf(&quot;AYE\n&quot;);    else printf(&quot;NAY\n&quot;);  }  return 0;}</code></pre><h3 id="2-国家集训队-聪聪可可"><a href="#2-国家集训队-聪聪可可" class="headerlink" title="2.[国家集训队]聪聪可可"></a>2.[国家集训队]聪聪可可</h3><p>题目链接： </p><ul><li>洛谷 P2634： <a href="https://www.luogu.org/problemnew/show/P2634" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P2634</a> </li><li>BZOJ P2152： <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2152" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2152</a></li></ul><p>这里使用一个<code>mod3[3]</code>数组来记录两点间距离%3后的值分别为0,1,2的个数。</p><p>对每个节点求出其子树内的dis，经过该点的路径数即为<code>mod3[1]*mod3[2]*2+mod3[0]^2</code>。</p><p>因为要求答案互质，所以还需要一个求最大公约数的操作。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to,w;} edge[40005];int head[40005],size[40005],son[40005],mod3[3];bool vis[40005];int n,m,a,b,c,cnt=1,ord,root,mx,sizenow,ans;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=2147483647;root=0;sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-size[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist){  mod3[dist%3]++;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    query(y,x,dist+edge[i].w);  }}inline int solve(int x,int length){  memset(mod3,0,sizeof(mod3));  query(x,0,length);  return mod3[0]*mod3[0]+mod3[1]*mod3[2]*2;}void divide(int x){  vis[x]=true;  ans+=solve(x,0);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    ans-=solve(y,edge[i].w);    init(size[y]);    getroot(y,0);    divide(root);  }}int gcd(int x,int y)//求最大公约数{  if (y==0) return x;  return gcd(y,x%y);}int main(){  n=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  printf(&quot;%d%c%d&quot;,ans/gcd(ans,n*n),&#39;/&#39;,n*n/gcd(ans,n*n));  return 0;}</code></pre><h3 id="3-IOI2011-Race"><a href="#3-IOI2011-Race" class="headerlink" title="3.[IOI2011]Race"></a>3.[IOI2011]Race</h3><p>题目链接：</p><ul><li>洛谷 P4149：<a href="https://www.luogu.org/problemnew/show/P4149" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4149</a></li><li>BZOJ P2599: <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2599" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=2599</a></li></ul><blockquote><p>BZOJ是权限题，若没交钱就用洛谷，或者用离线BZOJ题库（by ruanxingzhi）：<br><a href="https://bzoj.llf0703.com/p/2599.html" target="_blank" rel="noopener">https://bzoj.llf0703.com/p/2599.html</a></p></blockquote><p><del>洛谷上这道题是<a href="https://www.luogu.org/space/show?uid=20438" target="_blank" rel="noopener">@larryzhong</a>大佬提供的，比我小3岁却吊打我，在这里先%%%为敬</del></p><p>因为这道题需要得到边数最小，我们对于距离为i的点建立<code>tmp[i]</code>，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边</p><p>点分治，每次先对每棵子树遍历，求出每个点i到root的距离<code>dis[i]</code>，以及走过的边数<code>d[i]</code>，那么<code>ans=min(ans,tmp[k-dis[i]]+d[i])</code>.</p><p>遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵。最后所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define maxint 1e9using namespace std;struct Edge{  int next,to,w;} edge[400005];bool vis[200005];int size[200005],son[200005],dis[200005],head[400005],esum[200005];//tmp[i]，表示在当前递归到的子树中，走到距离为i的顶点最少需要走多少边//每个点i到root的距离dis[i]，以及走过的边数esum[i]int tmp[1000005];int n,m,k,a,b,c,cnt=1,sizenow,mx,ans,root;inline int read(){  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return x*f;}inline void add(int u,int v,int w){  edge[cnt].to=v;  edge[cnt].w=w;  edge[cnt].next=head[u];  head[u]=cnt++;}inline void init(int sizen){  mx=maxint;  root=0;  sizenow=sizen;}void getroot(int x,int f){  size[x]=1;  son[x]=0;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y] || y==f) continue;    getroot(y,x);    size[x]+=size[y];    son[x]=max(son[x],size[y]);  }  son[x]=max(son[x],sizenow-son[x]);  if (mx&gt;son[x])  {    mx=son[x];    root=x;  }}void query(int x,int f,int dist,int edgesum){  dis[x]=dist;  esum[x]=edgesum;  if (dis[x]&lt;=k) ans=min(ans,tmp[k-dis[x]]+esum[x]);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    query(y,x,dist+edge[i].w,edgesum+1);  }}//遍历完这棵子树再修改被访问了的tmp[dis[i]]，然后下一棵void update(int x,int f,bool s){  if (dis[x]&lt;=k)    if (s) tmp[dis[x]]=min(tmp[dis[x]],esum[x]);    else tmp[dis[x]]=maxint;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f || vis[y]) continue;    update(y,x,s);  }}void divide(int x){  vis[x]=true;  tmp[0]=0;//每次进入dfs_solve时tmp[0]=0，因为这个当前的根到自己距离为0，走过了0条边  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    query(y,0,edge[i].w,1);    update(y,0,true);  }  for (int i=head[x];i;i=edge[i].next)//所有子树遍历完了以后，再遍历一遍所有节点，把修改到的tmp值变回inf（初始就是inf）  {    int y=edge[i].to;    if (vis[y]) continue;    update(y,0,false);  }  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (vis[y]) continue;    init(size[y]);    getroot(y,0);    divide(root);  }}int main(){  n=read();k=read();  for (int i=1;i&lt;=k;i++) tmp[i]=maxint;  ans=maxint;  for (int i=1;i&lt;n;i++)  {    a=read();b=read();c=read();    a++;b++;    add(a,b,c);    add(b,a,c);  }  init(n);  getroot(1,0);  divide(root);  if (ans==maxint) printf(&quot;-1&quot;);  else printf(&quot;%d&quot;,ans);  return 0;}</code></pre><h3 id="4-洛谷-P4178-Tree"><a href="#4-洛谷-P4178-Tree" class="headerlink" title="4.洛谷 P4178 Tree"></a>4.洛谷 P4178 Tree</h3><p>题目链接： <a href="https://www.luogu.org/problemnew/show/P4178" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4178</a></p><p><del>这道题好像比上面那道还简单一点，我也不知道我为什么先刷的上面那一道</del></p><p>注意的是可以在统计有多少个路径权值&lt;=k时可以进行一次排序，直接枚举两个端点就可以处理了，可以节省时间。</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;#define inf 0xfffffffusing namespace std;struct Edge{    int next,to,w;} edge[80005];bool vis[40005];int dis[40005],size[40005],son[40005],head[40005];int root,mx,sizenow,cnt=1,n,m,a,b,c,ord,k,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return f*x;}inline void add(int u,int v,int w){    edge[cnt].to=v;    edge[cnt].w=w;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void init(int sizen){    mx=inf; sizenow=sizen; root=0;}void getroot(int x,int f){    size[x]=1;    son[x]=0;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        getroot(y,x);        size[x]+=size[y];        son[x]=max(son[x],size[y]);    }    son[x]=max(son[x],sizenow-size[x]);    if (mx&gt;son[x])    {        mx=son[x];        root=x;    }}void query(int x,int f,int dist){    dis[++ord]=dist;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (y==f || vis[y]) continue;        query(y,x,dist+edge[i].w);    }}inline int solve(int x,int length){    ord=0;    query(x,0,length);    sort(dis+1,dis+ord+1);    int ans=0,stat=1;    while (stat&lt;ord)    {        if (dis[stat]+dis[ord]&lt;=k)        {            ans+=ord-stat;            stat++;        }        else ord--;    }    return ans;}void divide(int x){    ans+=solve(x,0);    vis[x]=true;    for (int i=head[x];i;i=edge[i].next)    {        int y=edge[i].to;        if (vis[y]) continue;        ans-=solve(y,edge[i].w);        init(size[y]);        getroot(y,0);        divide(root);    }}int main(){    n=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();c=read();        add(a,b,c);        add(b,a,c);    }    k=read();    init(n);    getroot(1,0);    divide(root);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>以上内容更新于2018.4.26</p><hr>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>题解-洛谷P4092 [HEOI2016/TJOI2016]树</title>
      <link href="/p/luogu-solution-p4092.html"/>
      <url>/p/luogu-solution-p4092.html</url>
      <content type="html"><![CDATA[<p><del>第一次写树剖没看题解A题</del>，发现题解洛谷题解区大佬里竟然没有一个做法一样的，实在是太激动了</p><hr><ul><li>树剖学习：<a href="https://llf0703.com/p/shu-lian-pou-fen.html" target="_blank" rel="noopener">https://llf0703.com/p/shu-lian-pou-fen.html</a></li><li>题目链接 <a href="https://www.luogu.org/problemnew/show/P4092" target="_blank" rel="noopener">洛谷 P4092</a>  <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4551" target="_blank" rel="noopener">BZOJ P4551</a></li></ul><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><del>裸树剖</del>，直接用线段树维护每一段区间中<strong>被标记的最深的节点</strong>就行了。先全部赋值为-1，然后向上传递时直接取两段中的最大值即可（因为越深的点dfs序越大）</p><p>还有需要注意的是查询中在链上往上跳时只要找到了有标记的节点就需要输出，否则不是最深的点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{  int next,to;} edge[200005];struct Tree{  int left,right,deepest;} tree[800005];int head[200005],size[200005],fa[200005],son[200005],deep[200005],top[200005],id[200005],dfsid[200005];int cnt=1,n,m,a,b,c,dfsord;char x;inline int read()//快读{  char ch=getchar();  int f=1,x=0;  while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)  {    if (ch==&#39;-&#39;) f=-1;    ch=getchar();  }  while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)  {    x=x*10+ch-&#39;0&#39;;    ch=getchar();  }  return f*x;}inline void add(int u,int v)//加边{  edge[cnt].to=v;  edge[cnt].next=head[u];  head[u]=cnt++;}void build(int x,int l,int r)//建树{  tree[x].left=l;  tree[x].right=r;  tree[x].deepest=-1;//注意要赋值为-1  if (r-l&gt;1)  {    build(x*2,l,(l+r)/2);    build(x*2+1,(l+r)/2,r);  }}void change(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) tree[x].deepest=l;//只有一个元素时标记的最深的节点就是它自己  else  {    int mid=(tree[x].left+tree[x].right)/2;    if (l&lt;mid) change(x*2,l,r);    if (r&gt;mid) change(x*2+1,l,r);    tree[x].deepest=max(tree[x*2].deepest,tree[x*2+1].deepest);//取两段上最深的节点  }}int query(int x,int l,int r){  if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].deepest;  else  {    int mid=(tree[x].left+tree[x].right)/2,ans=-1;//同样注意初值    if (l&lt;mid) ans=max(ans,query(x*2,l,r));    if (r&gt;mid) ans=max(ans,query(x*2+1,l,r));    return ans;  }}void dfs1(int x,int f,int dep){  deep[x]=dep;  fa[x]=f;  size[x]=1;  int mx=-1;  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==f) continue;    dfs1(y,x,dep+1);    size[x]+=size[y];    if (size[y]&gt;mx)    {      mx=size[y];      son[x]=y;    }  }}void dfs2(int x,int topf){  top[x]=topf;  id[x]=++dfsord;  dfsid[dfsord]=x;//因为是输出节点原序号，这里得到dfs序对应的节点序号  if (!son[x]) return;  dfs2(son[x],topf);  for (int i=head[x];i;i=edge[i].next)  {    int y=edge[i].to;    if (y==fa[x] || y==son[x]) continue;    dfs2(y,y);  }}inline void uprange(int u){  change(1,id[u],id[u]+1);}inline int qrange(int u,int v){  int ans=-1;  while (top[u]!=top[v])  {    if (deep[id[u]]&lt;deep[id[v]]) swap(u,v);    ans=query(1,id[top[u]],id[u]+1);    if (ans!=-1) return dfsid[ans];//只要找到就返回    u=fa[top[u]];  }  if (deep[u]&gt;deep[v]) swap(u,v);  ans=query(1,id[u],id[v]+1);  return dfsid[ans];}int main(){  n=read();m=read();  for (int i=1;i&lt;n;i++)  {    a=read();b=read();    add(a,b);    add(b,a);  }  dfs1(1,0,1);  dfs2(1,1);  build(1,1,n+1);  change(1,1,2);//注意先将根节点打上标记  for (int i=1;i&lt;=m;i++)  {    cin&gt;&gt;x;    a=read();    if (x==&#39;C&#39;) uprange(a);    else printf(&quot;%d\n&quot;,qrange(a,1));  }  return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>二分图匹配</title>
      <link href="/p/bipartite-matching.html"/>
      <url>/p/bipartite-matching.html</url>
      <content type="html"><![CDATA[<p>我是看这篇学懂的，真的写得很好，所以我就不在这里总结了，只发个模板</p><p><a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">https://blog.csdn.net/dark_scope/article/details/8880547</a></p><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3386" target="_blank" rel="noopener">洛谷 P3386【模板】二分图匹配</a></p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;bool edge[1005][1005];bool used[1005];int mch[1005];int n,m,e,a,b,c,ans;inline int read(){    char ch=getchar();    int f=1,x=0;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)     {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}bool find(int x){    for (int i=1;i&lt;=m;i++)        if (!used[i] &amp;&amp; edge[x][i])        {            used[i]=true;            if (!mch[i] || find(mch[i]))            {                mch[i]=x;                return true;            }        }    return false;}int main(){    memset(edge,false,sizeof(edge));    n=read();m=read();e=read();    for (int i=1;i&lt;=e;i++)    {        int u=read(),v=read();        if (v&gt;m) continue;        edge[u][v]=true;    }    for (int i=1;i&lt;=n;i++)    {        memset(used,false,sizeof(used));        ans+=find(i);    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>题解-洛谷P2486 [SDOI2011]染色</title>
      <link href="/p/luogu-solution-p2486.html"/>
      <url>/p/luogu-solution-p2486.html</url>
      <content type="html"><![CDATA[<p>题目链接：</p><ul><li><a href="https://www.luogu.org/problemnew/show/P2486" target="_blank" rel="noopener">洛谷 P2486</a></li><li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2243" target="_blank" rel="noopener">BZOJ P2243</a></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>可以想到，颜色段的个数也是具有可加性的，但是如果两段连接处（即线段树中左子树的最右边的点和右子树的最左端的点）的颜色是相同的话，中间就只能算作一段，需要将颜色段个数-1。</p><p>所以我们在线段树里多加两个变量，分别为这一段最左端的点颜色和最右端的颜色，合并时和查询时判断一下即可。</p><p>注意的是查询链上时也需要判断。每次查询时记录一下左端点颜色，每一次判断一下当前剖到的右端点与上一次剖到的左端点是否相同即可。又由于有u和v两个节点要不停交换，所以用<code>lastc1</code>和<code>lastc2</code>两个变量来存上一次的左端点颜色，当u和v交换时，<code>lastc1</code>和<code>lastc2</code>也需要对应交换。当u和v在一条链上的时候，两边端点都需要比较。</p><p>查询链时代码</p><pre><code class="lang-cpp">int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);//同时交换        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;//将当前右端点同上一次左端点比较        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v]) //注意交换顺序，不要弄反    {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;//都要比较    return ans;}</code></pre><blockquote><p>其中lcol和rcol在query函数中就顺便获得了</p></blockquote><p>其它的就是标准的树链剖分了。传送门：<a href="https://llf0703.com/p/shu-lian-pou-fen.html" target="_blank" rel="noopener">树链剖分总结 - Llf’s blog</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>同样，我的线段树是[left,right)形式，调用时要将右边端点+1</p></blockquote><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=200005;struct Edge{    int next,to;} edge[MAXN];struct Tree{    int left,right,leftc,rightc,sum,delta;//leftc和rightc分别是左右端点颜色} tree[MAXN*4];int deep[MAXN],top[MAXN],son[MAXN],fa[MAXN],size[MAXN],id[MAXN],w[MAXN],wnew[MAXN],head[MAXN];int n,m,a,b,c,cnt=1,dfsord,rcol,lcol,lastc1,lastc2;inline int read(){    char ch=getchar();    int x=0,f=1;    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;)    {        if (ch==&#39;-&#39;) f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}inline void pushup(int x){    tree[x].sum=tree[x*2].sum+tree[x*2+1].sum;    if (tree[x*2].rightc==tree[x*2+1].leftc) tree[x].sum--;    tree[x].leftc=tree[x*2].leftc;    tree[x].rightc=tree[x*2+1].rightc;}inline void update(int x){    tree[x*2].sum=tree[x*2+1].sum=1;    tree[x*2].leftc=tree[x*2].rightc=tree[x*2+1].leftc=tree[x*2+1].rightc=tree[x].delta;    tree[x*2].delta=tree[x*2+1].delta=tree[x].delta;    tree[x].delta=0;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    tree[x].delta=0;    if (r-l==1)     {        tree[x].leftc=tree[x].rightc=wnew[l];        tree[x].sum=1;    }    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        pushup(x);    }}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)    {        tree[x].sum=1;        tree[x].leftc=tree[x].rightc=delta;        tree[x].delta=delta;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        pushup(x);    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        if (l==tree[x].left) lcol=tree[x].leftc;        if (r==tree[x].right) rcol=tree[x].rightc;        return tree[x].sum;    }    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        if (tree[x*2].rightc==tree[x*2+1].leftc &amp;&amp; l&lt;(tree[x].left+tree[x].right)/2 &amp;&amp; r&gt;(tree[x].left+tree[x].right)/2) ans--;        return ans;    }}void dfs1(int x,int f,int dep){    deep[x]=dep;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==f) continue;        dfs1(y,x,dep+1);        size[x]+=size[y];        if (size[y]&gt;mx)         {            mx=size[y];            son[x]=y;        }    }}void dfs2(int x,int topf){    top[x]=topf;    id[x]=++dfsord;    wnew[dfsord]=w[x];    if (!son[x]) return;    dfs2(son[x],topf);    for (int i=head[x];i!=-1;i=edge[i].next)    {        int y=edge[i].to;        if (y==fa[x] || y==son[x]) continue;        dfs2(y,y);    }}void uprange(int u,int v,int delta){    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}int qrange(int u,int v){    int ans=0,lastc1=lastc2=-1;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]])         {            swap(u,v);            swap(lastc1,lastc2);        }        ans+=query(1,id[top[u]],id[u]+1);        if (rcol==lastc1) ans--;        lastc1=lcol;        u=fa[top[u]];    }    if (deep[u]&lt;deep[v])     {        swap(u,v);        swap(lastc1,lastc2);    }    ans+=query(1,id[v],id[u]+1);    if (rcol==lastc1) ans--;    if (lcol==lastc2) ans--;    return ans;}int main(){    memset(head,-1,sizeof(head));    n=read();m=read();    for (int i=1;i&lt;=n;i++) w[i]=read();    for (int i=1;i&lt;n;i++)    {        a=read();b=read();        add(a,b);        add(b,a);    }    dfs1(1,0,1);    dfs2(1,1);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        char x;        cin&gt;&gt;x;        if (x==&#39;C&#39;)        {            a=read();b=read();c=read();            uprange(a,b,c);        }        else        {            a=read();b=read();            printf(&quot;%d\n&quot;,qrange(a,b));        }    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>树链剖分总结</title>
      <link href="/p/shu-lian-pou-fen.html"/>
      <url>/p/shu-lian-pou-fen.html</url>
      <content type="html"><![CDATA[<p>作为一个上个月刚学完线段树的蒟蒻，看Splay又看不懂，便直接跳着来学树剖了。又在一个博客上看到说学树剖之前最好还要把LCA给学了，便去花了一天学了一个Tarjan求LCA（然而后来发现并不怎么需要），然后是几乎照着别人的代码把树剖抄懂的。在这里我就讲一下我理解的树剖。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>链表/链式前向星</li><li>线段树/树状数组/Splay等可以维护一段数据的数据结构</li><li><a href="https://llf0703.com/p/LCA.html" target="_blank" rel="noopener">LCA</a> （其实只涉及到一些思想，而且几乎用不到，可以先不学）</li></ol><h2 id="树剖原理"><a href="#树剖原理" class="headerlink" title="树剖原理"></a>树剖原理</h2><p>我很早之前就听说过树剖，当时觉得实在是太高大上了，但现在发现只是名字比较高端，整个原理还是很简单的，只是码量比较大。</p><p>作为蒟蒻，我在图论题中几乎都只会搜索，也靠着搜索在SCOI上拿了仅有的几十分。不过我好歹还是学过前缀和差分的，如果一个图中所有的点连成一条线，那么来找两个点之间路径长只需要维护前缀和就行了。如果一棵树中的结点都连成一条线，我们就把它称作链。如果把树上的结点分为若干条链，那么很多问题就可以变得简单多了。</p><p>所谓树链剖分就是将一棵树给剖分成若干条链，再分别处理。</p><p>当然，一个节点也是可以算一条链的，不过如果这样分还不如不分。树剖这个算法的目的，便是将一棵树中每一个非叶节点分到链中，并且每一个节点都只属于一条链，这样查询起来又可以快很多。</p><p>在这里给出一棵树（图源百度百科）：</p><p><img src="https://cdn.uniqueue.cn/shupou.jpg" alt="树剖"></p><p>在这张图中，粗线即为分成的链。要让每一个非叶节点在链上，我们就需要让一条链尽可能覆盖更多节点。所以在每一个节点的子节点中，我们选<strong>以它为根的子树节点个数最多</strong>的子节点来连成链。</p><p>比如在4号节点的子节点{8,9,10}中，以8和以10为根的子树的节点总个数为1，而以9为根的子树节点个数为3，所以我们就将9作为链上的一个节点继续向下连接。9就被称为是4号节点的<strong>重节点</strong>，其他的两个节点就被称作<strong>轻节点</strong></p><p>继续扩展，父节点和重节点间的连线被称作<strong>重边</strong>，就是粗线；父节点和轻结点的连线被称作<strong>轻边</strong>，就是图中的细线；多条重边连接起来的路径叫<strong>重链</strong>，如路径1-&gt;4-&gt;9-&gt;13-&gt;14；多条轻边连接起来的路径叫<strong>轻链</strong>，如路径1-&gt;2-&gt;5。</p><p>通过一个表格将这些定义总结一下</p><div class="table-container"><table><thead><tr><th style="text-align:center">定义</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">重节点</td><td style="text-align:center">以它为根的子树节点个数最多的节点</td></tr><tr><td style="text-align:center">轻节点</td><td style="text-align:center">所有子节点中不是重节点的节点</td></tr><tr><td style="text-align:center">重边</td><td style="text-align:center">父节点和重节点间的连线</td></tr><tr><td style="text-align:center">轻边</td><td style="text-align:center">父节点和轻结点的连线</td></tr><tr><td style="text-align:center">重链</td><td style="text-align:center">多条重边连接起来的路径</td></tr><tr><td style="text-align:center">轻链</td><td style="text-align:center">多条轻边连接起来的路径</td></tr></tbody></table></div><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们使用两次dfs就能实现剖分，但是只剖分的话是并没有什么卵用的，一般题目中还会涉及到两节点间的权值和，权值最大值等问题。这里以 <a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">洛谷P3384【模板】树链剖分</a> 为例。</p><h3 id="剖分"><a href="#剖分" class="headerlink" title="剖分"></a>剖分</h3><p>首先先解释下我使用的变量</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">fa[x]</td><td style="text-align:center">x号节点的父亲</td></tr><tr><td style="text-align:center">son[x]</td><td style="text-align:center">x号节点的重儿子（节点）</td></tr><tr><td style="text-align:center">size[x]</td><td style="text-align:center">以x号节点为根的子树中节点个数</td></tr><tr><td style="text-align:center">deep[x]</td><td style="text-align:center">x号节点的深度</td></tr><tr><td style="text-align:center">top[x]</td><td style="text-align:center">x号节点所在的链顶的节点编号</td></tr><tr><td style="text-align:center">w[x]</td><td style="text-align:center">x号节点的原权值</td></tr><tr><td style="text-align:center">wnew[x]</td><td style="text-align:center">dfs序中第x号节点的权值</td></tr><tr><td style="text-align:center">id[x]</td><td style="text-align:center">x号节点的dfs序</td></tr><tr><td style="text-align:center">edge[]和head[]</td><td style="text-align:center">链式前向星数组</td></tr><tr><td style="text-align:center">tree[]</td><td style="text-align:center">线段树</td></tr></tbody></table></div><p>先进行第一次dfs，需要完成的任务是</p><ol><li>确定这个点的深度</li><li>确定父亲节点</li><li>确定以这个节点为根的子树中节点个数</li><li>确定这个点的重儿子</li></ol><p>具体实现方式见代码</p><pre><code class="lang-cpp">void dfs1(int x,int f,int depth){    deep[x]=depth;//深度    fa[x]=f;//父亲节点    size[x]=1;//子树节点个数至少有一个    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];//节点个数加上子节点的        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}</code></pre><p>然后是第二次dfs。需要完成的任务是</p><ol><li>确定新编号（dfs序）</li><li>赋权值到新编号上</li><li>确定这个点所在的链的顶端</li><li>处理每一条链</li></ol><p>还是看代码吧</p><pre><code class="lang-cpp">void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}</code></pre><blockquote><p>先处理重儿子是为了保证每一条链都是被连续处理的</p></blockquote><p>好了，剖分就结束了，<span style="text-decoration:line-through;">是不是很简单啊</span></p><h3 id="处理问题"><a href="#处理问题" class="headerlink" title="处理问题"></a>处理问题</h3><h4 id="操作1，2"><a href="#操作1，2" class="headerlink" title="操作1，2"></a>操作1，2</h4><p>操作1： 格式： 1 x y z 表示将树从x到y结点最短路径上所有节点的值都加上z</p><p>操作2： 格式： 2 x y 表示求树从x到y结点最短路径上所有节点的值之和</p><p>在处理u和v号节点之间路径上所有节点时，我们一般先让u和v属于同一条链，然后因为dfs序的特点就可以直接用线段树处理了。</p><p>让u和v顶端相同的方法是将u和v中较深的节点往上跳到这条链顶端的上方，跳完一个再交换跳下一个。每次更改或查询只要更改当前跳的节点到它所在链的顶端即可，最后到一条链上了以后直接处理两点之间就行了。</p><p>代码如下：</p><blockquote><p>注：我的线段树是左闭右开区间，即表示[left,right)，所以处理时右边要+1</p></blockquote><p>操作1</p><pre><code class="lang-cpp">void uprange(int u,int v,int delta){    delta%=p;//按题意取%    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换为更深的点        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];//向上跳    }    if (deep[u]&gt;deep[v]) swap(u,v);//交换为更深的点保证u的dfs序在前    change(1,id[u],id[v]+1,delta);}</code></pre><p>操作2</p><pre><code class="lang-cpp">int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}</code></pre><h4 id="操作3，4"><a href="#操作3，4" class="headerlink" title="操作3，4"></a>操作3，4</h4><p>可以根据dfs序的性质直到，子树区间右端点为id[x]+siz[x]-1，直接处理即可。</p><p>代码：</p><p>操作3</p><pre><code class="lang-cpp">inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}</code></pre><p>操作4</p><pre><code class="lang-cpp">inline int qson(int u){    return query(1,id[u],id[u]+size[u]);}</code></pre><h3 id="其它细节"><a href="#其它细节" class="headerlink" title="其它细节"></a>其它细节</h3><ol><li>在一些没有指定根的问题中其实以任意节点为根都是可以的</li><li>根节点开始dfs时可以以0作为它的根，顶端就是它本身</li><li>一定要记得<strong>先dfs在建树</strong>，因为线段树是处理dfs序的</li></ol><pre><code class="lang-cpp">dfs1(root,0,1);dfs2(root,root);build(1,1,n+1);</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int next,to;} edge[200005];int fa[200005],size[200005],deep[200005],w[200005],wnew[200005],head[200005],son[200005],id[200005],top[200005];struct Tree{    int left,right,sum,delta;} tree[800005];int cnt=1,ans,n,m,a,b,c,d,p,dfsord,root;inline void add(int u,int v){    edge[cnt].to=v;    edge[cnt].next=head[u];    head[u]=cnt++;}void build(int x,int l,int r){    tree[x].left=l;    tree[x].right=r;    if (r-l==1) tree[x].sum=wnew[l];    else    {        build(x*2,l,(l+r)/2);        build(x*2+1,(l+r)/2,r);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}inline void update(int x){    tree[x*2].sum+=tree[x].delta*(tree[x*2].right-tree[x*2].left);    tree[x*2+1].sum+=tree[x].delta*(tree[x*2+1].right-tree[x*2+1].left);    tree[x*2].sum%=p;    tree[x*2+1].sum%=p;    tree[x*2].delta+=tree[x].delta;    tree[x*2+1].delta+=tree[x].delta;    tree[x].delta=0;}void change(int x,int l,int r,int delta){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right)     {        tree[x].delta+=delta;        tree[x].sum+=delta*(tree[x].right-tree[x].left);        tree[x].sum%=p;    }    else    {        if (tree[x].delta!=0) update(x);        if (l&lt;(tree[x].left+tree[x].right)/2) change(x*2,l,r,delta);        if (r&gt;(tree[x].left+tree[x].right)/2) change(x*2+1,l,r,delta);        tree[x].sum=(tree[x*2].sum+tree[x*2+1].sum)%p;    }}int query(int x,int l,int r){    if (l&lt;=tree[x].left &amp;&amp; r&gt;=tree[x].right) return tree[x].sum%p;    else    {        if (tree[x].delta!=0) update(x);        int ans=0;        if (l&lt;(tree[x].left+tree[x].right)/2) ans+=query(x*2,l,r);        if (r&gt;(tree[x].left+tree[x].right)/2) ans+=query(x*2+1,l,r);        return ans%p;    }}               /*  dfs1    标记每个点的深度dep[]       标记每个点的父亲fa[]    标记每个非叶子节点的子树大小(含它自己)        标记每个非叶子节点的重儿子编号son[]*/void dfs1(int x,int f,int depth){    deep[x]=depth;    fa[x]=f;    size[x]=1;    int mx=-1;    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==f) continue;//不搜索父节点        dfs1(v,x,depth+1);        size[x]+=size[v];        if (size[v]&gt;mx) //更新重儿子        {            mx=size[v];            son[x]=v;        }    }}/*  dfs2    标记每个点的新编号    赋值每个点的初始值到新编号上    处理每个点所在链的顶端    处理每条链*/void dfs2(int x,int topf){    id[x]=++dfsord;//标记每一个节点的dfs序    wnew[dfsord]=w[x];//得到新编号（dfs序）    top[x]=topf;//得到这条链的顶端    if (!son[x]) return;//无儿子返回    dfs2(son[x],topf);//先处理重儿子    for (int i=head[x];i!=-1;i=edge[i].next)    {        int v=edge[i].to;        if (v==fa[x] || v==son[x]) continue;        dfs2(v,v);//如果是轻儿子，新的链一定以自己为顶端    }}int qrange(int u,int v)//求u到v节点的路径中节点之和{    int ans=0;    while (top[u]!=top[v])//不停将u向上跳，直到在一条链上    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);//交换成更深的点        ans+=query(1,id[top[u]],id[u]+1);        ans%=p;        u=fa[top[u]];//向上跳    }    //已经在一条链上    if (deep[u]&gt;deep[v]) swap(u,v);    ans+=query(1,id[u],id[v]+1);    ans%=p;    return ans;}void uprange(int u,int v,int delta){    delta%=p;    while (top[u]!=top[v])    {        if (deep[top[u]]&lt;deep[top[v]]) swap(u,v);        change(1,id[top[u]],id[u]+1,delta);        u=fa[top[u]];    }    if (deep[u]&gt;deep[v]) swap(u,v);    change(1,id[u],id[v]+1,delta);}inline int qson(int u){    return query(1,id[u],id[u]+size[u]);//子树区间右端点为id[x]+siz[x]-1 }inline void upson(int u,int delta){    change(1,id[u],id[u]+size[u],delta);}int main(){    memset(head,-1,sizeof(head));    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;root,&amp;p);    for (int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]);    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b);        add(b,a);    }    dfs1(root,0,1);    dfs2(root,root);    build(1,1,n+1);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d&quot;,&amp;a);        if (a==1)        {            scanf(&quot;%d%d%d&quot;,&amp;b,&amp;c,&amp;d);            uprange(b,c,d);        }        if (a==2)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            //cout&lt;&lt;wnew[id[b]]&lt;&lt;&quot; &quot;&lt;&lt;wnew[id[c]]&lt;&lt;endl;            printf(&quot;%d\n&quot;,qrange(b,c));        }        if (a==3)        {            scanf(&quot;%d%d&quot;,&amp;b,&amp;c);            upson(b,c);        }        if (a==4)        {            scanf(&quot;%d&quot;,&amp;b);            printf(&quot;%d\n&quot;,qson(b));        }    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新……</p>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LCA问题总结</title>
      <link href="/p/lca.html"/>
      <url>/p/lca.html</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近公共祖先（LCA）问题指的是在一棵树中，求出任意两个点的最近的公共祖先。如在下图中：</p><p><img src="https://cdn.uniqueue.cn/lca.png" alt="LCA"></p><p>2号节点和1号节点的LCA是4,3号和2号的LCA也是4.</p><p>求LCA的方法主要有：暴力，倍增，RMQ和Tarjan。</p><p>这篇文章以<a href="https://www.luogu.org/problemnew/show/P3379" target="_blank" rel="noopener">洛谷P3379 【模板】最近公共祖先（LCA）</a>为例。</p><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><p>Tarjan算法能够通过dfs将树上节点信息和查询的信息一次性解决，但是无法应对存在修改的情况，所以是一种离线算法。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>从根节点开始，遍历每一个它的子节点；</li><li>一直递归到叶节点，再从叶节点开始将它和它的父节点运用并查集合并；</li><li>又从当前遍历到的节点u开始，遍历每一个和它有询问关系的节点。如果另一个节点v被访问过，那么u和v的LCA就是v的先前通过并查集找到的祖先。</li></ol><h3 id="细节与实现"><a href="#细节与实现" class="headerlink" title="细节与实现"></a>细节与实现</h3><ol><li>注意记录这个节点是否被访问过，防止重复访问。</li><li>输入没有指明哪个是父节点哪个是子节点，所以需要进行双向储存，空间也要随之开两倍。</li><li>由于需要遍历子节点，我采用链式前向星的方法进行储存；同样，还需要遍历有查询关系的点，查询关系也需要用一个链式前向星。</li><li>这道题中，有多组询问，还要求按照询问的顺序输出，所以解决每个答案的顺序是至关重要的。我起先想了很久怎么解决这个问题，后来才想起链式前向星也是有顺序的。但是由于每一次询问都存了两次，所以更新LCA答案时要将相邻的一对询问都更新，输出时也只能输出一次。</li><li>要处理相邻两个询问的LCA，将本次查询到的节点i和i^1节点更新即可。因为<code>[i,i^1]∈[k*2,k*2+1],k∈Z</code>，i^1即为i在同组中另一项，反之也成立。举个例子：</li></ol><pre><code>0^1=1,1^1=0 [0,1]2^1=3,3^1=2 [2,3]</code></pre><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{    int to,next;} edge[1000005];struct Edge2{    int to,next,lca;} ask[1000005];//链式前向星储存bool vis[500005];int f[500005];int head[1000005],hask[1000005];int n,m,a,b,c,cnte,cnta,root;inline void addedge(int u,int v){    edge[cnte].to=v;    edge[cnte].next=head[u];    head[u]=cnte++;}inline void addask(int u,int v){    ask[cnta].to=v;    ask[cnta].next=hask[u];    hask[u]=cnta++;}int find(int x){    if (f[x]==x) return f[x];    f[x]=find(f[x]);    return f[x];}void merge(int x,int y){    if (find(x)!=find(y)) f[find(x)]=find(y);}void tarjan(int u){    vis[u]=true;//记录已经访问    for (int i=head[u];i!=-1;i=edge[i].next)     if (!vis[edge[i].to])    {        tarjan(edge[i].to);//继续向下遍历        merge(edge[i].to,u);//合并    }    for (int i=hask[u];i!=-1;i=ask[i].next)    if (vis[ask[i].to]) ask[i].lca=ask[i^1].lca=find(ask[i].to);//i^1的含义是(0,1),(1,2)这些组的另一项}int main(){    memset(vis,false,sizeof(vis));    memset(head,-1,sizeof(head));    memset(hask,-1,sizeof(hask));    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;root);    for (int i=1;i&lt;=n;i++) f[i]=i;    for (int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addedge(a,b);        addedge(b,a);    }    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        addask(a,b);        addask(b,a);    }    tarjan(root);    for (int i=0;i&lt;m*2;i+=2) printf(&quot;%d\n&quot;,ask[i].lca);//因为加入两次，而相邻两次的lca又相同    return 0;}</code></pre><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RMQ问题_ST表总结</title>
      <link href="/p/rmq-st.html"/>
      <url>/p/rmq-st.html</url>
      <content type="html"><![CDATA[<h2 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题"></a>RMQ问题</h2><p>RMQ问题是指多次询问一个区间中最小或最大值的问题。但是因为不包括修改，只涉及离线操作，所以线段树或者树状数组显得有一些多余了。而且数列中的元素个数可能非常大，像线段树开四倍空间肯定是要MLE的。这里介绍一种高效的ST表来解决这种问题。</p><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>我的理解：ST表运用<strong>动态规划和二分</strong>的思想来完成。</p><p>ST表查询问题包含初始化和查询操作，其中初始化的时间复杂度为<code>O(n*logn)</code>，查询的时间复杂度仅为<code>O(1)</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化主要运用动态规划来完成。</p><p>我们将原来的数列用a[]储存，同时定义一个二维的<code>f[][]</code>数组，<code>f[i][j]</code>表示从第i个数起连续2^j个数中的最值，即储存<code>[i,i+2^j-1]</code>中的最值。然后我们就可以使用f数组进行动态规划。</p><h4 id="起始状态"><a href="#起始状态" class="headerlink" title="起始状态"></a>起始状态</h4><p>我们知道<code>2^0=1</code>，所以当j=0时，<code>f[i][j]</code>其实储存的就是第i项的值，这就成了我们初始化的依据。初始化可以这么写：</p><pre><code class="lang-cpp">for (int i=1;i&lt;=n;i++) f[i][0]=a[i];</code></pre><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>前面已经说过，这个状态转移的实质就是二分。在这里，我们将<code>[i,i+2^j-1]</code>二分为<code>[i,i+2^(j-1)-1]</code>和<code>[i+2^(j-1),i+2^j-1]</code>。因为每个区间中的项数在j!=0时一定是偶数，所以这样一定能分为两段项数相同的区间。于是我们得到了状态转移方程<code>f[i, j]=max(f[i,j-1], f[i+2^(j-1),j-1])</code>。状态转移可以这么写：</p><pre><code class="lang-cpp">for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);</code></pre><blockquote><p>其中1&lt;&lt;j就是2^j</p></blockquote><p>但是为什么j要写在外层循环呢？</p><p>因为这个状态转移的实质是：先更新所有长度为<code>f[i][0]</code>即1个元素，然后通过2个1个元素的最值，获得所有长度为<code>f[i][1]</code>即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为<code>f[i][2]</code>即4个元素的最值，以此类推更新所有长度的最值。</p><p>而如果是i在外，j在内的话，我们更新的顺序就是<code>f[1][0],f[1][1],f[1][2],f[1][3]</code>表示更新从1开始1个元素，2个元素，4个元素，8个元素的最值，这里<code>f[1][3]=min(min(a[0],a[1],a[2],a[3]),min(a[4],a[5],a[6],a[7]))</code>的值，但是我们根本没有计算<code>min(a[0],a[1],a[2],a[3])</code>和<code>min(a[4],a[5],a[6],a[7])</code>，所以这样的方法肯定是错误的。</p><p>所以初始化就这么写：</p><pre><code class="lang-cpp">void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>对于查询<code>[l,r]</code>这个区间中的最值，我们也可以将其分为两部分，再分别取两部分的最值来得到整个区间的最值。</p><p>我们取一个值<code>k=log2(r-l+1)</code>，并将k作为二分的中点，将<code>[l,r]</code>这个区间分为<code>[l,k]</code>和<code>[r-2^k+1,k]</code>这两段。可以很显然的发现，这两段是有重复的，但是对结果没有任何影响。</p><p>查询可以这么写：</p><pre><code class="lang-cpp">inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}</code></pre><h2 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h2><p>以<a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865 【模板】ST表</a>为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int f[100005][20];int n,m,b,c;void st(int n){    for (int i=1;i&lt;=n;i++) f[i][0]=a[i];    for (int j=1;(1 &lt;&lt; j)&lt;=n;j++)        for (int i=1;i+(1 &lt;&lt; j)-1&lt;=n;i++)        f[i][j]=max(f[i][j-1],f[i+(1 &lt;&lt; (j-1))][j-1]);}inline int query(int l,int r){    int k=log2(r-l+1);    return max(f[l][k],f[r-(1 &lt;&lt; k)+1][k]);}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for (int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    st(n);    for (int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d&quot;,&amp;b,&amp;c);        printf(&quot;%d\n&quot;,query(b,c));    }    return 0;}</code></pre><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>待更新。。。</p>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>题解-洛谷P1309 瑞士轮</title>
      <link href="/p/luogu-solution-p1309.html"/>
      <url>/p/luogu-solution-p1309.html</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1309" target="_blank" rel="noopener">原题链接</a> <a href="https://www.luogu.org/blog/llf/solution-p1309" target="_blank" rel="noopener">洛谷博客该题解链接</a></p><hr><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。</p><p>本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>2*N 名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。</p><p>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K – 1 名和第 2K名、…… 、第2N – 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。</p><p>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入文件名为swiss.in 。</p><p>输入的第一行是三个正整数N、R 、Q，每两个数之间用一个空格隔开，表示有 2*N 名选手、R 轮比赛，以及我们关心的名次 Q。</p><p>第二行是2<em>N 个非负整数s1, s2, …, s2N，每两个数之间用一个空格隔开，其中 si 表示编号为i 的选手的初始分数。 第三行是2</em>N 个正整数w1 , w2 , …, w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出文件名为swiss.out。</p><p>输出只有一行，包含一个整数，即R 轮比赛结束后，排名第 Q 的选手的编号。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><pre><code>2 4 2 7 6 6 7 10 5 20 15</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><pre><code>1</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p><img src="https://cdn.luogu.org/upload/pic/98.png" alt="1309样例解释"></p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于30% 的数据，1 ≤ N ≤ 100；</p><p>对于50% 的数据，1 ≤ N ≤ 10,000 ；</p><p>对于100%的数据，1 ≤ N ≤ 100,000，1 ≤ R ≤ 50，1 ≤ Q ≤ 2N，0 ≤ s1, s2, …, s2N≤10^8，1 ≤w1, w2 , …, w2N≤ 10^8。</p><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>Noip2011普及组第3题。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，每一轮过后次序都会被打乱，所以都需要重新排序。如果每次从头排序（用快排）则只能得60（同学亲测），所以快排不能解决这个问题。<br>仔细观察发现，不论是得分还是没得分，胜者和败者组成的序列肯定是有序的，那么每次将两个有序的序列组成一个新序列就行了，这便是归并算法可以直接解决的问题了。<br>先把第一次排序后的数据分为胜者败者两组，胜者分数++后合并，如此反复R次即可完成。<br>需要注意的是<strong>不要偷懒用队列</strong>，否则跟快排暴力得分一样，还是老老实实自己用数组模拟吧。<br>代码及注解如下：</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,r,q;struct ren{    int s,w,ord;};ren win[200005],lose[200005];ren info[200005];bool com(ren a,ren b){    if (a.s==b.s) return a.ord&lt;b.ord;    else return a.s&gt;b.s;}int main(){    cin&gt;&gt;n&gt;&gt;r&gt;&gt;q;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].s;    for (a=1;a&lt;=n*2;a++)    info[a].ord=a;    for (a=1;a&lt;=n*2;a++)    cin&gt;&gt;info[a].w;    sort(info+1,info+n*2+1,com);//第一次排序可以用快排    for (a=1;a&lt;=r;a++)    {        for (b=1;b&lt;=n;b++)        {            if (info[b*2].w&gt;info[b*2-1].w)            {                info[b*2].s++;                win[b]=info[b*2];                lose[b]=info[b*2-1];            }            else            {                info[b*2-1].s++;                win[b]=info[b*2-1];                lose[b]=info[b*2];            }        }//分成win和lose两组        int e=0;        int i=1;        int j=1;        while (i&lt;=n&amp;&amp;j&lt;=n)        {            if (win[i].s&gt;lose[j].s)            {                e++;                info[e]=win[i];                i++;            }            else if (win[i].s&lt;lose[j].s)            {                e++;                info[e]=lose[j];                j++;            }            else if (win[i].s==lose[j].s)//特别注意要考虑分数相等的情况，把编号小的排在前面            {                e++;                if (win[i].ord&lt;lose[j].ord)                {                    info[e]=win[i];                    i++;                }                else if (win[i].ord&gt;lose[j].ord)                {                    info[e]=lose[j];                    j++;                }            }        }        if (i&gt;n)        while (j&lt;=n)        {            e++;            info[e]=lose[j];            j++;        }        if (j&gt;n)        while (i&lt;=n)        {            e++;            info[e]=win[i];            i++;        }    }//将原数组覆盖成比赛后的新数组    cout&lt;&lt;info[q].ord;    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>几种排序方法总结</title>
      <link href="/p/sort.html"/>
      <url>/p/sort.html</url>
      <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>第一次将每一个元素和它的后一个元素比较大小，如果不满足顺序则交换，这样即可确定最后一个数的位置。然后再从头开始，可以确定倒数第二个数的位置。循环n次后即可完成排序。因为每一轮排完序后都会确定一个，即“冒”出来一个，故被称作冒泡排序。<br><img src="https://cdn.uniqueue.cn/paixu1.jpg" alt="paixu1"><br>时间效率：O($n^{2}$)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>以  <a href="https://www.luogu.org/problemnew/show/P1116" target="_blank" rel="noopener">洛谷 P1116 车厢重组</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a,b,c,d,e,ans;int f[10005];void change(int &amp;a,int &amp;b){    int c;    c=a;    a=b;    b=c;}int main(){    cin&gt;&gt;n;    for (a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    for (a=1;a&lt;=n;a++)      for (b=1;b&lt;=n-a;b++)//因为每次多确定一位，固少循环一次      if (f[b]&gt;f[b+1])      {          change(f[b],f[b+1]);          ans++;      }    cout&lt;&lt;ans;    return 0;}</code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的原理非常简单，即将需排序的元素作为数组下标，直接输出就行了。<br><img src="https://cdn.uniqueue.cn/paixu2.jpg/" alt="paixu2"><br>时间效率：<code>O(n)</code> 但是需要很多额外空间</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>运用递归将原数据不断二分，然后在回溯过程中使用归并算法将其一步步合并，最后合成一个有序数列。<br><img src="https://cdn.uniqueue.cn/paixu3.jpg/" alt="paixu3"><br><img src="https://cdn.uniqueue.cn/paixu4.jpg/" alt="paixu4"><br><img src="https://cdn.uniqueue.cn/paixu5.jpg/" alt="paixu5"><br>时间效率：最好：<code>O(log n)</code> 最坏：<code>O(n*log n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>以 <a href="https://www.luogu.org/problemnew/show/P1177" target="_blank" rel="noopener">洛谷 P1177 【模板】快速排序</a> 为例</p><pre><code class="lang-cpp">#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,p,i,j,k;queue &lt;int&gt; q;int f[100005];void merge_sort(int a,int b)//a是起点，b是终点{    int s;    if (a==b) return;    s=(a+b)/2;    merge_sort(a,s);    merge_sort(s+1,b);//递归调用    i=a;    j=s+1;    while (i&lt;=s&amp;&amp;j&lt;=b)    {        if (f[i]&gt;f[j])         {            q.push(f[j]);            j++;        }        else        {            q.push(f[i]);            i++;        }    }    if (i&gt;s)     for (int e=j;e&lt;=b;e++) q.push(f[e]);    if (j&gt;b)    for (int e=i;e&lt;=s;e++) q.push(f[e]);    k=a-1;    while (!q.empty())    {        k++;        f[k]=q.front();        q.pop();    }//归并算法}int main(){    cin&gt;&gt;n;    for (int a=1;a&lt;=n;a++)    cin&gt;&gt;f[a];    merge_sort(1,n);    for (int a=1;a&lt;=n;a++)    cout&lt;&lt;f[a]&lt;&lt;&quot; &quot;;    return 0;}</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><ol><li>设置两个变量i、j，排序开始的时候：i=0，j=N-1；</li><li>以第一个数组元素作为关键数据，赋值给key，即<code>key=A[0]</code>；</li><li>从j开始向前搜索，即由后开始向前搜索(j—)，找到第一个小于key的值<code>A[j]</code>，将<code>A[j]</code>和<code>A[i]</code>互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的<code>A[i]</code>，将<code>A[i]</code>和<code>A[j]</code>互换；</li><li>重复第3、4步，直到i=j，这样以后第i位上的数的前面比这个数小，后面比这个数大，即这个数位置已经确定；</li><li>将i前面和i后面的部分递归调用再次排序，直到排完。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">sort(A,A+N,com)//_huaji</code></pre>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>友链</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
